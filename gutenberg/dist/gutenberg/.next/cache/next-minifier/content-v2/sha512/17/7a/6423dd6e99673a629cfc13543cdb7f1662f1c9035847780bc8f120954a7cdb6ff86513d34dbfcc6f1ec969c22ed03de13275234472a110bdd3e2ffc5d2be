{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[6],{oGoC:function(t,e,s){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});const i=!0,r=!0,a=!0,n=!0;class o{constructor(t,e={}){this.label=void 0,this.keyword=void 0,this.beforeExpr=void 0,this.startsExpr=void 0,this.rightAssociative=void 0,this.isLoop=void 0,this.isAssign=void 0,this.prefix=void 0,this.postfix=void 0,this.binop=void 0,this.updateContext=void 0,this.label=t,this.keyword=e.keyword,this.beforeExpr=!!e.beforeExpr,this.startsExpr=!!e.startsExpr,this.rightAssociative=!!e.rightAssociative,this.isLoop=!!e.isLoop,this.isAssign=!!e.isAssign,this.prefix=!!e.prefix,this.postfix=!!e.postfix,this.binop=null!=e.binop?e.binop:null,this.updateContext=null}}const h=new Map;function p(t,e={}){e.keyword=t;const s=new o(t,e);return h.set(t,s),s}function c(t,e){return new o(t,{beforeExpr:i,binop:e})}const l={num:new o(\"num\",{startsExpr:r}),bigint:new o(\"bigint\",{startsExpr:r}),decimal:new o(\"decimal\",{startsExpr:r}),regexp:new o(\"regexp\",{startsExpr:r}),string:new o(\"string\",{startsExpr:r}),name:new o(\"name\",{startsExpr:r}),eof:new o(\"eof\"),bracketL:new o(\"[\",{beforeExpr:i,startsExpr:r}),bracketHashL:new o(\"#[\",{beforeExpr:i,startsExpr:r}),bracketBarL:new o(\"[|\",{beforeExpr:i,startsExpr:r}),bracketR:new o(\"]\"),bracketBarR:new o(\"|]\"),braceL:new o(\"{\",{beforeExpr:i,startsExpr:r}),braceBarL:new o(\"{|\",{beforeExpr:i,startsExpr:r}),braceHashL:new o(\"#{\",{beforeExpr:i,startsExpr:r}),braceR:new o(\"}\"),braceBarR:new o(\"|}\"),parenL:new o(\"(\",{beforeExpr:i,startsExpr:r}),parenR:new o(\")\"),comma:new o(\",\",{beforeExpr:i}),semi:new o(\";\",{beforeExpr:i}),colon:new o(\":\",{beforeExpr:i}),doubleColon:new o(\"::\",{beforeExpr:i}),dot:new o(\".\"),question:new o(\"?\",{beforeExpr:i}),questionDot:new o(\"?.\"),arrow:new o(\"=>\",{beforeExpr:i}),template:new o(\"template\"),ellipsis:new o(\"...\",{beforeExpr:i}),backQuote:new o(\"`\",{startsExpr:r}),dollarBraceL:new o(\"${\",{beforeExpr:i,startsExpr:r}),at:new o(\"@\"),hash:new o(\"#\",{startsExpr:r}),interpreterDirective:new o(\"#!...\"),eq:new o(\"=\",{beforeExpr:i,isAssign:true}),assign:new o(\"_=\",{beforeExpr:i,isAssign:true}),incDec:new o(\"++/--\",{prefix:n,postfix:!0,startsExpr:r}),bang:new o(\"!\",{beforeExpr:i,prefix:n,startsExpr:r}),tilde:new o(\"~\",{beforeExpr:i,prefix:n,startsExpr:r}),pipeline:c(\"|>\",0),nullishCoalescing:c(\"??\",1),logicalOR:c(\"||\",1),logicalAND:c(\"&&\",2),bitwiseOR:c(\"|\",3),bitwiseXOR:c(\"^\",4),bitwiseAND:c(\"&\",5),equality:c(\"==/!=/===/!==\",6),relational:c(\"</>/<=/>=\",7),bitShift:c(\"<</>>/>>>\",8),plusMin:new o(\"+/-\",{beforeExpr:i,binop:9,prefix:n,startsExpr:r}),modulo:new o(\"%\",{beforeExpr:i,binop:10,startsExpr:r}),star:new o(\"*\",{binop:10}),slash:c(\"/\",10),exponent:new o(\"**\",{beforeExpr:i,binop:11,rightAssociative:!0}),_break:p(\"break\"),_case:p(\"case\",{beforeExpr:i}),_catch:p(\"catch\"),_continue:p(\"continue\"),_debugger:p(\"debugger\"),_default:p(\"default\",{beforeExpr:i}),_do:p(\"do\",{isLoop:a,beforeExpr:i}),_else:p(\"else\",{beforeExpr:i}),_finally:p(\"finally\"),_for:p(\"for\",{isLoop:a}),_function:p(\"function\",{startsExpr:r}),_if:p(\"if\"),_return:p(\"return\",{beforeExpr:i}),_switch:p(\"switch\"),_throw:p(\"throw\",{beforeExpr:i,prefix:n,startsExpr:r}),_try:p(\"try\"),_var:p(\"var\"),_const:p(\"const\"),_while:p(\"while\",{isLoop:a}),_with:p(\"with\"),_new:p(\"new\",{beforeExpr:i,startsExpr:r}),_this:p(\"this\",{startsExpr:r}),_super:p(\"super\",{startsExpr:r}),_class:p(\"class\",{startsExpr:r}),_extends:p(\"extends\",{beforeExpr:i}),_export:p(\"export\"),_import:p(\"import\",{startsExpr:r}),_null:p(\"null\",{startsExpr:r}),_true:p(\"true\",{startsExpr:r}),_false:p(\"false\",{startsExpr:r}),_in:p(\"in\",{beforeExpr:i,binop:7}),_instanceof:p(\"instanceof\",{beforeExpr:i,binop:7}),_typeof:p(\"typeof\",{beforeExpr:i,prefix:n,startsExpr:r}),_void:p(\"void\",{beforeExpr:i,prefix:n,startsExpr:r}),_delete:p(\"delete\",{beforeExpr:i,prefix:n,startsExpr:r})},u=/\\r\\n?|[\\n\\u2028\\u2029]/,d=new RegExp(u.source,\"g\");function m(t){switch(t){case 10:case 13:case 8232:case 8233:return!0;default:return!1}}const f=/(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;function y(t){switch(t){case 9:case 11:case 12:case 32:case 160:case 5760:case 8192:case 8193:case 8194:case 8195:case 8196:case 8197:case 8198:case 8199:case 8200:case 8201:case 8202:case 8239:case 8287:case 12288:case 65279:return!0;default:return!1}}class x{constructor(t,e){this.line=void 0,this.column=void 0,this.line=t,this.column=e}}class P{constructor(t,e){this.start=void 0,this.end=void 0,this.filename=void 0,this.identifierName=void 0,this.start=t,this.end=e}}function g(t){return t[t.length-1]}const b=Object.freeze({AccessorIsGenerator:\"A %0ter cannot be a generator\",ArgumentsInClass:\"'arguments' is only allowed in functions and class methods\",AsyncFunctionInSingleStatementContext:\"Async functions can only be declared at the top level or inside a block\",AwaitBindingIdentifier:\"Can not use 'await' as identifier inside an async function\",AwaitExpressionFormalParameter:\"await is not allowed in async function parameters\",AwaitNotInAsyncContext:\"'await' is only allowed within async functions and at the top levels of modules\",AwaitNotInAsyncFunction:\"'await' is only allowed within async functions\",BadGetterArity:\"getter must not have any formal parameters\",BadSetterArity:\"setter must have exactly one formal parameter\",BadSetterRestParameter:\"setter function argument must not be a rest parameter\",ConstructorClassField:\"Classes may not have a field named 'constructor'\",ConstructorClassPrivateField:\"Classes may not have a private field named '#constructor'\",ConstructorIsAccessor:\"Class constructor may not be an accessor\",ConstructorIsAsync:\"Constructor can't be an async function\",ConstructorIsGenerator:\"Constructor can't be a generator\",DeclarationMissingInitializer:\"%0 require an initialization value\",DecoratorBeforeExport:\"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",DecoratorConstructor:\"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",DecoratorExportClass:\"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",DecoratorSemicolon:\"Decorators must not be followed by a semicolon\",DecoratorStaticBlock:\"Decorators can't be used with a static block\",DeletePrivateField:\"Deleting a private field is not allowed\",DestructureNamedImport:\"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",DuplicateConstructor:\"Duplicate constructor in the same class\",DuplicateDefaultExport:\"Only one default export allowed per module.\",DuplicateExport:\"`%0` has already been exported. Exported identifiers must be unique.\",DuplicateProto:\"Redefinition of __proto__ property\",DuplicateRegExpFlags:\"Duplicate regular expression flag\",DuplicateStaticBlock:\"Duplicate static block in the same class\",ElementAfterRest:\"Rest element must be last element\",EscapedCharNotAnIdentifier:\"Invalid Unicode escape\",ExportBindingIsString:\"A string literal cannot be used as an exported binding without `from`.\\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?\",ExportDefaultFromAsIdentifier:\"'from' is not allowed as an identifier after 'export default'\",ForInOfLoopInitializer:\"%0 loop variable declaration may not have an initializer\",GeneratorInSingleStatementContext:\"Generators can only be declared at the top level or inside a block\",IllegalBreakContinue:\"Unsyntactic %0\",IllegalLanguageModeDirective:\"Illegal 'use strict' directive in function with non-simple parameter list\",IllegalReturn:\"'return' outside of function\",ImportBindingIsString:'A string literal cannot be used as an imported binding.\\n- Did you mean `import { \"%0\" as foo }`?',ImportCallArgumentTrailingComma:\"Trailing comma is disallowed inside import(...) arguments\",ImportCallArity:\"import() requires exactly %0\",ImportCallNotNewExpression:\"Cannot use new with import(...)\",ImportCallSpreadArgument:\"... is not allowed in import()\",ImportMetaOutsideModule:\"import.meta may appear only with 'sourceType: \\\"module\\\"'\",ImportOutsideModule:\"'import' and 'export' may appear only with 'sourceType: \\\"module\\\"'\",InvalidBigIntLiteral:\"Invalid BigIntLiteral\",InvalidCodePoint:\"Code point out of bounds\",InvalidDecimal:\"Invalid decimal\",InvalidDigit:\"Expected number in radix %0\",InvalidEscapeSequence:\"Bad character escape sequence\",InvalidEscapeSequenceTemplate:\"Invalid escape sequence in template\",InvalidEscapedReservedWord:\"Escape sequence in keyword %0\",InvalidIdentifier:\"Invalid identifier %0\",InvalidLhs:\"Invalid left-hand side in %0\",InvalidLhsBinding:\"Binding invalid left-hand side in %0\",InvalidNumber:\"Invalid number\",InvalidOrMissingExponent:\"Floating-point numbers require a valid exponent after the 'e'\",InvalidOrUnexpectedToken:\"Unexpected character '%0'\",InvalidParenthesizedAssignment:\"Invalid parenthesized assignment pattern\",InvalidPrivateFieldResolution:\"Private name #%0 is not defined\",InvalidPropertyBindingPattern:\"Binding member expression\",InvalidRecordProperty:\"Only properties and spread elements are allowed in record definitions\",InvalidRestAssignmentPattern:\"Invalid rest operator's argument\",LabelRedeclaration:\"Label '%0' is already declared\",LetInLexicalBinding:\"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",LineTerminatorBeforeArrow:\"No line break is allowed before '=>'\",MalformedRegExpFlags:\"Invalid regular expression flag\",MissingClassName:\"A class name is required\",MissingEqInAssignment:\"Only '=' operator can be used for specifying default value.\",MissingUnicodeEscape:\"Expecting Unicode escape sequence \\\\uXXXX\",MixingCoalesceWithLogical:\"Nullish coalescing operator(??) requires parens when mixing with logical operators\",ModuleAttributeDifferentFromType:\"The only accepted module attribute is `type`\",ModuleAttributeInvalidValue:\"Only string literals are allowed as module attribute values\",ModuleAttributesWithDuplicateKeys:'Duplicate key \"%0\" is not allowed in module attributes',ModuleExportNameHasLoneSurrogate:\"An export name cannot include a lone surrogate, found '\\\\u%0'\",ModuleExportUndefined:\"Export '%0' is not defined\",MultipleDefaultsInSwitch:\"Multiple default clauses\",NewlineAfterThrow:\"Illegal newline after throw\",NoCatchOrFinally:\"Missing catch or finally clause\",NumberIdentifier:\"Identifier directly after number\",NumericSeparatorInEscapeSequence:\"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",ObsoleteAwaitStar:\"await* has been removed from the async functions proposal. Use Promise.all() instead.\",OptionalChainingNoNew:\"constructors in/after an Optional Chain are not allowed\",OptionalChainingNoTemplate:\"Tagged Template Literals are not allowed in optionalChain\",ParamDupe:\"Argument name clash\",PatternHasAccessor:\"Object pattern can't contain getter or setter\",PatternHasMethod:\"Object pattern can't contain methods\",PipelineBodyNoArrow:'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',PipelineBodySequenceExpression:\"Pipeline body may not be a comma-separated sequence expression\",PipelineHeadSequenceExpression:\"Pipeline head should not be a comma-separated sequence expression\",PipelineTopicUnused:\"Pipeline is in topic style but does not use topic reference\",PrimaryTopicNotAllowed:\"Topic reference was used in a lexical context without topic binding\",PrimaryTopicRequiresSmartPipeline:\"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",PrivateInExpectedIn:\"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)\",PrivateNameRedeclaration:\"Duplicate private name #%0\",RecordExpressionBarIncorrectEndSyntaxType:\"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",RecordExpressionBarIncorrectStartSyntaxType:\"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",RecordExpressionHashIncorrectStartSyntaxType:\"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",RecordNoProto:\"'__proto__' is not allowed in Record expressions\",RestTrailingComma:\"Unexpected trailing comma after rest element\",SloppyFunction:\"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",StaticPrototype:\"Classes may not have static property named prototype\",StrictDelete:\"Deleting local variable in strict mode\",StrictEvalArguments:\"Assigning to '%0' in strict mode\",StrictEvalArgumentsBinding:\"Binding '%0' in strict mode\",StrictFunction:\"In strict mode code, functions can only be declared at top level or inside a block\",StrictNumericEscape:\"The only valid numeric escape in strict mode is '\\\\0'\",StrictOctalLiteral:\"Legacy octal literals are not allowed in strict mode\",StrictWith:\"'with' in strict mode\",SuperNotAllowed:\"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",SuperPrivateField:\"Private fields can't be accessed on super\",TrailingDecorator:\"Decorators must be attached to a class element\",TupleExpressionBarIncorrectEndSyntaxType:\"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",TupleExpressionBarIncorrectStartSyntaxType:\"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",TupleExpressionHashIncorrectStartSyntaxType:\"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",UnexpectedArgumentPlaceholder:\"Unexpected argument placeholder\",UnexpectedAwaitAfterPipelineBody:'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',UnexpectedDigitAfterHash:\"Unexpected digit after hash token\",UnexpectedImportExport:\"'import' and 'export' may only appear at the top level\",UnexpectedKeyword:\"Unexpected keyword '%0'\",UnexpectedLeadingDecorator:\"Leading decorators must be attached to a class declaration\",UnexpectedLexicalDeclaration:\"Lexical declaration cannot appear in a single-statement context\",UnexpectedNewTarget:\"new.target can only be used in functions\",UnexpectedNumericSeparator:\"A numeric separator is only allowed between two digits\",UnexpectedPrivateField:\"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",UnexpectedReservedWord:\"Unexpected reserved word '%0'\",UnexpectedSuper:\"super is only allowed in object methods and classes\",UnexpectedToken:\"Unexpected token '%0'\",UnexpectedTokenUnaryExponentiation:\"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",UnsupportedBind:\"Binding should be performed on object property.\",UnsupportedDecoratorExport:\"A decorated export must export a class declaration\",UnsupportedDefaultExport:\"Only expressions, functions or classes are allowed as the `default` export.\",UnsupportedImport:\"import can only be used in import() or import.meta\",UnsupportedMetaProperty:\"The only valid meta property for %0 is %0.%1\",UnsupportedParameterDecorator:\"Decorators cannot be used to decorate parameters\",UnsupportedPropertyDecorator:\"Decorators cannot be used to decorate object literal properties\",UnsupportedSuper:\"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",UnterminatedComment:\"Unterminated comment\",UnterminatedRegExp:\"Unterminated regular expression\",UnterminatedString:\"Unterminated string constant\",UnterminatedTemplate:\"Unterminated template\",VarRedeclaration:\"Identifier '%0' has already been declared\",YieldBindingIdentifier:\"Can not use 'yield' as identifier inside a generator\",YieldInParameter:\"Yield expression is not allowed in formal parameters\",ZeroDigitNumericSeparator:\"Numeric separator can not be used after leading 0\"});class T{constructor(t,e,s,i){this.token=void 0,this.isExpr=void 0,this.preserveSpace=void 0,this.override=void 0,this.token=t,this.isExpr=!!e,this.preserveSpace=!!s,this.override=i}}const A={braceStatement:new T(\"{\",!1),braceExpression:new T(\"{\",!0),recordExpression:new T(\"#{\",!0),templateQuasi:new T(\"${\",!1),parenStatement:new T(\"(\",!1),parenExpression:new T(\"(\",!0),template:new T(\"`\",!0,!0,(t=>t.readTmplToken())),functionExpression:new T(\"function\",!0),functionStatement:new T(\"function\",!1)};l.parenR.updateContext=l.braceR.updateContext=function(){if(1===this.state.context.length)return void(this.state.exprAllowed=!0);let t=this.state.context.pop();t===A.braceStatement&&\"function\"===this.curContext().token&&(t=this.state.context.pop()),this.state.exprAllowed=!t.isExpr},l.name.updateContext=function(t){let e=!1;t!==l.dot&&(\"of\"!==this.state.value||this.state.exprAllowed||t===l._function||t===l._class||(e=!0)),this.state.exprAllowed=e,this.state.isIterator&&(this.state.isIterator=!1)},l.braceL.updateContext=function(t){this.state.context.push(this.braceIsBlock(t)?A.braceStatement:A.braceExpression),this.state.exprAllowed=!0},l.dollarBraceL.updateContext=function(){this.state.context.push(A.templateQuasi),this.state.exprAllowed=!0},l.parenL.updateContext=function(t){const e=t===l._if||t===l._for||t===l._with||t===l._while;this.state.context.push(e?A.parenStatement:A.parenExpression),this.state.exprAllowed=!0},l.incDec.updateContext=function(){},l._function.updateContext=l._class.updateContext=function(t){!t.beforeExpr||t===l.semi||t===l._else||t===l._return&&this.hasPrecedingLineBreak()||(t===l.colon||t===l.braceL)&&this.curContext()===A.b_stat?this.state.context.push(A.functionStatement):this.state.context.push(A.functionExpression),this.state.exprAllowed=!1},l.backQuote.updateContext=function(){this.curContext()===A.template?this.state.context.pop():this.state.context.push(A.template),this.state.exprAllowed=!1},l.braceHashL.updateContext=function(){this.state.context.push(A.recordExpression),this.state.exprAllowed=!0};let w=\"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\",E=\"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";const S=new RegExp(\"[\"+w+\"]\"),C=new RegExp(\"[\"+w+E+\"]\");w=E=null;const N=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938],k=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];function I(t,e){let s=65536;for(let i=0,r=e.length;i<r;i+=2){if(s+=e[i],s>t)return!1;if(s+=e[i+1],s>=t)return!0}return!1}function v(t){return t<65?36===t:t<=90||(t<97?95===t:t<=122||(t<=65535?t>=170&&S.test(String.fromCharCode(t)):I(t,N)))}function L(t){return t<48?36===t:t<58||!(t<65)&&(t<=90||(t<97?95===t:t<=122||(t<=65535?t>=170&&C.test(String.fromCharCode(t)):I(t,N)||I(t,k))))}const D=[\"implements\",\"interface\",\"let\",\"package\",\"private\",\"protected\",\"public\",\"static\",\"yield\"],M=[\"eval\",\"arguments\"],R=new Set([\"break\",\"case\",\"catch\",\"continue\",\"debugger\",\"default\",\"do\",\"else\",\"finally\",\"for\",\"function\",\"if\",\"return\",\"switch\",\"throw\",\"try\",\"var\",\"const\",\"while\",\"with\",\"new\",\"this\",\"super\",\"class\",\"extends\",\"export\",\"import\",\"null\",\"true\",\"false\",\"in\",\"instanceof\",\"typeof\",\"void\",\"delete\"]),O=new Set(D),F=new Set(M);function B(t,e){return e&&\"await\"===t||\"enum\"===t}function _(t,e){return B(t,e)||O.has(t)}function j(t){return F.has(t)}function U(t,e){return _(t,e)||j(t)}function q(t){return R.has(t)}const V=/^in(stanceof)?$/;const z=128,H=128,K=1024,W=new Set([\"_\",\"any\",\"bool\",\"boolean\",\"empty\",\"extends\",\"false\",\"interface\",\"mixed\",\"null\",\"number\",\"static\",\"string\",\"true\",\"typeof\",\"void\"]),J=Object.freeze({AmbiguousConditionalArrow:\"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",AmbiguousDeclareModuleKind:\"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",AssignReservedType:\"Cannot overwrite reserved type %0\",DeclareClassElement:\"The `declare` modifier can only appear on class fields.\",DeclareClassFieldInitializer:\"Initializers are not allowed in fields with the `declare` modifier.\",DuplicateDeclareModuleExports:\"Duplicate `declare module.exports` statement\",EnumBooleanMemberNotInitialized:\"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",EnumDuplicateMemberName:\"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",EnumInconsistentMemberValues:\"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",EnumInvalidExplicitType:\"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",EnumInvalidExplicitTypeUnknownSupplied:\"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",EnumInvalidMemberInitializerPrimaryType:\"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",EnumInvalidMemberInitializerSymbolType:\"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",EnumInvalidMemberInitializerUnknownType:\"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",EnumInvalidMemberName:\"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",EnumNumberMemberNotInitialized:\"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",EnumStringMemberInconsistentlyInitailized:\"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",ImportTypeShorthandOnlyInPureImport:\"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",InexactInsideExact:\"Explicit inexact syntax cannot appear inside an explicit exact object type\",InexactInsideNonObject:\"Explicit inexact syntax cannot appear in class or interface definitions\",InexactVariance:\"Explicit inexact syntax cannot have variance\",InvalidNonTypeImportInDeclareModule:\"Imports within a `declare module` body must always be `import type` or `import typeof`\",MissingTypeParamDefault:\"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",NestedDeclareModule:\"`declare module` cannot be used inside another `declare module`\",NestedFlowComment:\"Cannot have a flow comment inside another flow comment\",OptionalBindingPattern:\"A binding pattern parameter cannot be optional in an implementation signature.\",SpreadVariance:\"Spread properties cannot have variance\",TypeBeforeInitializer:\"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",TypeCastInPattern:\"The type cast expression is expected to be wrapped with parenthesis\",UnexpectedExplicitInexactInObject:\"Explicit inexact syntax must appear at the end of an inexact object\",UnexpectedReservedType:\"Unexpected reserved type %0\",UnexpectedReservedUnderscore:\"`_` is only allowed as a type argument to call or new\",UnexpectedSpaceBetweenModuloChecks:\"Spaces between `%` and `checks` are not allowed here.\",UnexpectedSpreadType:\"Spread operator cannot appear in class or interface definitions\",UnexpectedSubtractionOperand:'Unexpected token, expected \"number\" or \"bigint\"',UnexpectedTokenAfterTypeParameter:\"Expected an arrow function after this type parameter declaration\",UnexpectedTypeParameterBeforeAsyncArrowFunction:\"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",UnsupportedDeclareExportKind:\"`declare export %0` is not supported. Use `%1` instead\",UnsupportedStatementInDeclareModule:\"Only declares and type imports are allowed inside declare module\",UnterminatedFlowComment:\"Unterminated flow-comment\"});function X(t){return\"type\"===t.importKind||\"typeof\"===t.importKind}function G(t){return(t.type===l.name||!!t.type.keyword)&&\"from\"!==t.value}const Q={const:\"declare export var\",let:\"declare export var\",type:\"export type\",interface:\"export interface\"};const Y=/\\*?\\s*@((?:no)?flow)\\b/;const $={quot:'\"',amp:\"&\",apos:\"'\",lt:\"<\",gt:\">\",nbsp:\"\\xa0\",iexcl:\"\\xa1\",cent:\"\\xa2\",pound:\"\\xa3\",curren:\"\\xa4\",yen:\"\\xa5\",brvbar:\"\\xa6\",sect:\"\\xa7\",uml:\"\\xa8\",copy:\"\\xa9\",ordf:\"\\xaa\",laquo:\"\\xab\",not:\"\\xac\",shy:\"\\xad\",reg:\"\\xae\",macr:\"\\xaf\",deg:\"\\xb0\",plusmn:\"\\xb1\",sup2:\"\\xb2\",sup3:\"\\xb3\",acute:\"\\xb4\",micro:\"\\xb5\",para:\"\\xb6\",middot:\"\\xb7\",cedil:\"\\xb8\",sup1:\"\\xb9\",ordm:\"\\xba\",raquo:\"\\xbb\",frac14:\"\\xbc\",frac12:\"\\xbd\",frac34:\"\\xbe\",iquest:\"\\xbf\",Agrave:\"\\xc0\",Aacute:\"\\xc1\",Acirc:\"\\xc2\",Atilde:\"\\xc3\",Auml:\"\\xc4\",Aring:\"\\xc5\",AElig:\"\\xc6\",Ccedil:\"\\xc7\",Egrave:\"\\xc8\",Eacute:\"\\xc9\",Ecirc:\"\\xca\",Euml:\"\\xcb\",Igrave:\"\\xcc\",Iacute:\"\\xcd\",Icirc:\"\\xce\",Iuml:\"\\xcf\",ETH:\"\\xd0\",Ntilde:\"\\xd1\",Ograve:\"\\xd2\",Oacute:\"\\xd3\",Ocirc:\"\\xd4\",Otilde:\"\\xd5\",Ouml:\"\\xd6\",times:\"\\xd7\",Oslash:\"\\xd8\",Ugrave:\"\\xd9\",Uacute:\"\\xda\",Ucirc:\"\\xdb\",Uuml:\"\\xdc\",Yacute:\"\\xdd\",THORN:\"\\xde\",szlig:\"\\xdf\",agrave:\"\\xe0\",aacute:\"\\xe1\",acirc:\"\\xe2\",atilde:\"\\xe3\",auml:\"\\xe4\",aring:\"\\xe5\",aelig:\"\\xe6\",ccedil:\"\\xe7\",egrave:\"\\xe8\",eacute:\"\\xe9\",ecirc:\"\\xea\",euml:\"\\xeb\",igrave:\"\\xec\",iacute:\"\\xed\",icirc:\"\\xee\",iuml:\"\\xef\",eth:\"\\xf0\",ntilde:\"\\xf1\",ograve:\"\\xf2\",oacute:\"\\xf3\",ocirc:\"\\xf4\",otilde:\"\\xf5\",ouml:\"\\xf6\",divide:\"\\xf7\",oslash:\"\\xf8\",ugrave:\"\\xf9\",uacute:\"\\xfa\",ucirc:\"\\xfb\",uuml:\"\\xfc\",yacute:\"\\xfd\",thorn:\"\\xfe\",yuml:\"\\xff\",OElig:\"\\u0152\",oelig:\"\\u0153\",Scaron:\"\\u0160\",scaron:\"\\u0161\",Yuml:\"\\u0178\",fnof:\"\\u0192\",circ:\"\\u02c6\",tilde:\"\\u02dc\",Alpha:\"\\u0391\",Beta:\"\\u0392\",Gamma:\"\\u0393\",Delta:\"\\u0394\",Epsilon:\"\\u0395\",Zeta:\"\\u0396\",Eta:\"\\u0397\",Theta:\"\\u0398\",Iota:\"\\u0399\",Kappa:\"\\u039a\",Lambda:\"\\u039b\",Mu:\"\\u039c\",Nu:\"\\u039d\",Xi:\"\\u039e\",Omicron:\"\\u039f\",Pi:\"\\u03a0\",Rho:\"\\u03a1\",Sigma:\"\\u03a3\",Tau:\"\\u03a4\",Upsilon:\"\\u03a5\",Phi:\"\\u03a6\",Chi:\"\\u03a7\",Psi:\"\\u03a8\",Omega:\"\\u03a9\",alpha:\"\\u03b1\",beta:\"\\u03b2\",gamma:\"\\u03b3\",delta:\"\\u03b4\",epsilon:\"\\u03b5\",zeta:\"\\u03b6\",eta:\"\\u03b7\",theta:\"\\u03b8\",iota:\"\\u03b9\",kappa:\"\\u03ba\",lambda:\"\\u03bb\",mu:\"\\u03bc\",nu:\"\\u03bd\",xi:\"\\u03be\",omicron:\"\\u03bf\",pi:\"\\u03c0\",rho:\"\\u03c1\",sigmaf:\"\\u03c2\",sigma:\"\\u03c3\",tau:\"\\u03c4\",upsilon:\"\\u03c5\",phi:\"\\u03c6\",chi:\"\\u03c7\",psi:\"\\u03c8\",omega:\"\\u03c9\",thetasym:\"\\u03d1\",upsih:\"\\u03d2\",piv:\"\\u03d6\",ensp:\"\\u2002\",emsp:\"\\u2003\",thinsp:\"\\u2009\",zwnj:\"\\u200c\",zwj:\"\\u200d\",lrm:\"\\u200e\",rlm:\"\\u200f\",ndash:\"\\u2013\",mdash:\"\\u2014\",lsquo:\"\\u2018\",rsquo:\"\\u2019\",sbquo:\"\\u201a\",ldquo:\"\\u201c\",rdquo:\"\\u201d\",bdquo:\"\\u201e\",dagger:\"\\u2020\",Dagger:\"\\u2021\",bull:\"\\u2022\",hellip:\"\\u2026\",permil:\"\\u2030\",prime:\"\\u2032\",Prime:\"\\u2033\",lsaquo:\"\\u2039\",rsaquo:\"\\u203a\",oline:\"\\u203e\",frasl:\"\\u2044\",euro:\"\\u20ac\",image:\"\\u2111\",weierp:\"\\u2118\",real:\"\\u211c\",trade:\"\\u2122\",alefsym:\"\\u2135\",larr:\"\\u2190\",uarr:\"\\u2191\",rarr:\"\\u2192\",darr:\"\\u2193\",harr:\"\\u2194\",crarr:\"\\u21b5\",lArr:\"\\u21d0\",uArr:\"\\u21d1\",rArr:\"\\u21d2\",dArr:\"\\u21d3\",hArr:\"\\u21d4\",forall:\"\\u2200\",part:\"\\u2202\",exist:\"\\u2203\",empty:\"\\u2205\",nabla:\"\\u2207\",isin:\"\\u2208\",notin:\"\\u2209\",ni:\"\\u220b\",prod:\"\\u220f\",sum:\"\\u2211\",minus:\"\\u2212\",lowast:\"\\u2217\",radic:\"\\u221a\",prop:\"\\u221d\",infin:\"\\u221e\",ang:\"\\u2220\",and:\"\\u2227\",or:\"\\u2228\",cap:\"\\u2229\",cup:\"\\u222a\",int:\"\\u222b\",there4:\"\\u2234\",sim:\"\\u223c\",cong:\"\\u2245\",asymp:\"\\u2248\",ne:\"\\u2260\",equiv:\"\\u2261\",le:\"\\u2264\",ge:\"\\u2265\",sub:\"\\u2282\",sup:\"\\u2283\",nsub:\"\\u2284\",sube:\"\\u2286\",supe:\"\\u2287\",oplus:\"\\u2295\",otimes:\"\\u2297\",perp:\"\\u22a5\",sdot:\"\\u22c5\",lceil:\"\\u2308\",rceil:\"\\u2309\",lfloor:\"\\u230a\",rfloor:\"\\u230b\",lang:\"\\u2329\",rang:\"\\u232a\",loz:\"\\u25ca\",spades:\"\\u2660\",clubs:\"\\u2663\",hearts:\"\\u2665\",diams:\"\\u2666\"},Z=/^[\\da-fA-F]+$/,tt=/^\\d+$/,et=Object.freeze({AttributeIsEmpty:\"JSX attributes must only be assigned a non-empty expression\",MissingClosingTagFragment:\"Expected corresponding JSX closing tag for <>\",MissingClosingTagElement:\"Expected corresponding JSX closing tag for <%0>\",UnexpectedSequenceExpression:\"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",UnsupportedJsxValue:\"JSX value should be either an expression or a quoted JSX text\",UnterminatedJsxContent:\"Unterminated JSX contents\",UnwrappedAdjacentJSXElements:\"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"});function st(t){return!!t&&(\"JSXOpeningFragment\"===t.type||\"JSXClosingFragment\"===t.type)}function it(t){if(\"JSXIdentifier\"===t.type)return t.name;if(\"JSXNamespacedName\"===t.type)return t.namespace.name+\":\"+t.name.name;if(\"JSXMemberExpression\"===t.type)return it(t.object)+\".\"+it(t.property);throw new Error(\"Node had unexpected type: \"+t.type)}A.j_oTag=new T(\"<tag\",!1),A.j_cTag=new T(\"</tag\",!1),A.j_expr=new T(\"<tag>...</tag>\",!0,!0),l.jsxName=new o(\"jsxName\"),l.jsxText=new o(\"jsxText\",{beforeExpr:!0}),l.jsxTagStart=new o(\"jsxTagStart\",{startsExpr:!0}),l.jsxTagEnd=new o(\"jsxTagEnd\"),l.jsxTagStart.updateContext=function(){this.state.context.push(A.j_expr),this.state.context.push(A.j_oTag),this.state.exprAllowed=!1},l.jsxTagEnd.updateContext=function(t){const e=this.state.context.pop();e===A.j_oTag&&t===l.slash||e===A.j_cTag?(this.state.context.pop(),this.state.exprAllowed=this.curContext()===A.j_expr):this.state.exprAllowed=!0};class rt{constructor(t){this.flags=void 0,this.var=[],this.lexical=[],this.functions=[],this.flags=t}}class at{constructor(t,e){this.scopeStack=[],this.undefinedExports=new Map,this.undefinedPrivateNames=new Map,this.raise=t,this.inModule=e}get inFunction(){return(2&this.currentVarScope().flags)>0}get allowSuper(){return(16&this.currentThisScope().flags)>0}get allowDirectSuper(){return(32&this.currentThisScope().flags)>0}get inClass(){return(64&this.currentThisScope().flags)>0}get inNonArrowFunction(){return(2&this.currentThisScope().flags)>0}get treatFunctionsAsVar(){return this.treatFunctionsAsVarInScope(this.currentScope())}createScope(t){return new rt(t)}enter(t){this.scopeStack.push(this.createScope(t))}exit(){this.scopeStack.pop()}treatFunctionsAsVarInScope(t){return!!(2&t.flags||!this.inModule&&1&t.flags)}declareName(t,e,s){let i=this.currentScope();if(8&e||16&e)this.checkRedeclarationInScope(i,t,e,s),16&e?i.functions.push(t):i.lexical.push(t),8&e&&this.maybeExportDefined(i,t);else if(4&e)for(let r=this.scopeStack.length-1;r>=0&&(i=this.scopeStack[r],this.checkRedeclarationInScope(i,t,e,s),i.var.push(t),this.maybeExportDefined(i,t),!(131&i.flags));--r);this.inModule&&1&i.flags&&this.undefinedExports.delete(t)}maybeExportDefined(t,e){this.inModule&&1&t.flags&&this.undefinedExports.delete(e)}checkRedeclarationInScope(t,e,s,i){this.isRedeclaredInScope(t,e,s)&&this.raise(i,b.VarRedeclaration,e)}isRedeclaredInScope(t,e,s){return!!(1&s)&&(8&s?t.lexical.indexOf(e)>-1||t.functions.indexOf(e)>-1||t.var.indexOf(e)>-1:16&s?t.lexical.indexOf(e)>-1||!this.treatFunctionsAsVarInScope(t)&&t.var.indexOf(e)>-1:t.lexical.indexOf(e)>-1&&!(8&t.flags&&t.lexical[0]===e)||!this.treatFunctionsAsVarInScope(t)&&t.functions.indexOf(e)>-1)}checkLocalExport(t){-1===this.scopeStack[0].lexical.indexOf(t.name)&&-1===this.scopeStack[0].var.indexOf(t.name)&&-1===this.scopeStack[0].functions.indexOf(t.name)&&this.undefinedExports.set(t.name,t.start)}currentScope(){return this.scopeStack[this.scopeStack.length-1]}currentVarScope(){for(let t=this.scopeStack.length-1;;t--){const e=this.scopeStack[t];if(131&e.flags)return e}}currentThisScope(){for(let t=this.scopeStack.length-1;;t--){const e=this.scopeStack[t];if((131&e.flags||64&e.flags)&&!(4&e.flags))return e}}}class nt extends rt{constructor(...t){super(...t),this.types=[],this.enums=[],this.constEnums=[],this.classes=[],this.exportOnlyBindings=[]}}class ot extends at{createScope(t){return new nt(t)}declareName(t,e,s){const i=this.currentScope();if(e&K)return this.maybeExportDefined(i,t),void i.exportOnlyBindings.push(t);super.declareName(...arguments),2&e&&(1&e||(this.checkRedeclarationInScope(i,t,e,s),this.maybeExportDefined(i,t)),i.types.push(t)),256&e&&i.enums.push(t),512&e&&i.constEnums.push(t),e&H&&i.classes.push(t)}isRedeclaredInScope(t,e,s){if(t.enums.indexOf(e)>-1){if(256&s){return!!(512&s)!==t.constEnums.indexOf(e)>-1}return!0}return s&H&&t.classes.indexOf(e)>-1?t.lexical.indexOf(e)>-1&&!!(1&s):!!(2&s&&t.types.indexOf(e)>-1)||super.isRedeclaredInScope(...arguments)}checkLocalExport(t){-1===this.scopeStack[0].types.indexOf(t.name)&&-1===this.scopeStack[0].exportOnlyBindings.indexOf(t.name)&&super.checkLocalExport(t)}}class ht{constructor(){this.stacks=[]}enter(t){this.stacks.push(t)}exit(){this.stacks.pop()}currentFlags(){return this.stacks[this.stacks.length-1]}get hasAwait(){return(2&this.currentFlags())>0}get hasYield(){return(1&this.currentFlags())>0}get hasReturn(){return(4&this.currentFlags())>0}get hasIn(){return(8&this.currentFlags())>0}}function pt(t,e){return(t?2:0)|(e?1:0)}function ct(t){if(null==t)throw new Error(`Unexpected ${t} value.`);return t}function lt(t){if(!t)throw new Error(\"Assert fail\")}const ut=Object.freeze({ClassMethodHasDeclare:\"Class methods cannot have the 'declare' modifier\",ClassMethodHasReadonly:\"Class methods cannot have the 'readonly' modifier\",ConstructorHasTypeParameters:\"Type parameters cannot appear on a constructor declaration.\",DeclareClassFieldHasInitializer:\"Initializers are not allowed in ambient contexts.\",DeclareFunctionHasImplementation:\"An implementation cannot be declared in ambient contexts.\",DuplicateModifier:\"Duplicate modifier: '%0'\",EmptyHeritageClauseType:\"'%0' list cannot be empty.\",EmptyTypeArguments:\"Type argument list cannot be empty.\",EmptyTypeParameters:\"Type parameter list cannot be empty.\",IndexSignatureHasAbstract:\"Index signatures cannot have the 'abstract' modifier\",IndexSignatureHasAccessibility:\"Index signatures cannot have an accessibility modifier ('%0')\",IndexSignatureHasStatic:\"Index signatures cannot have the 'static' modifier\",IndexSignatureHasDeclare:\"Index signatures cannot have the 'declare' modifier\",InvalidTupleMemberLabel:\"Tuple members must be labeled with a simple identifier.\",MixedLabeledAndUnlabeledElements:\"Tuple members must all have names or all not have names.\",OptionalTypeBeforeRequired:\"A required element cannot follow an optional element.\",PatternIsOptional:\"A binding pattern parameter cannot be optional in an implementation signature.\",PrivateElementHasAbstract:\"Private elements cannot have the 'abstract' modifier.\",PrivateElementHasAccessibility:\"Private elements cannot have an accessibility modifier ('%0')\",TypeAnnotationAfterAssign:\"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",UnexpectedParameterModifier:\"A parameter property is only allowed in a constructor implementation.\",UnexpectedReadonly:\"'readonly' type modifier is only permitted on array and tuple literal types.\",UnexpectedTypeAnnotation:\"Did not expect a type annotation here.\",UnexpectedTypeCastInParameter:\"Unexpected type cast in parameter position.\",UnsupportedImportTypeArgument:\"Argument in a type import must be a string literal\",UnsupportedParameterPropertyKind:\"A parameter property may not be declared using a binding pattern.\",UnsupportedSignatureParameterKind:\"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\"});l.placeholder=new o(\"%%\",{startsExpr:!0});function dt(t,e){return t.some((t=>Array.isArray(t)?t[0]===e:t===e))}function mt(t,e,s){const i=t.find((t=>Array.isArray(t)?t[0]===e:t===e));return i&&Array.isArray(i)?i[1][s]:null}const ft=[\"minimal\",\"smart\",\"fsharp\"],yt=[\"hash\",\"bar\"];const xt={estree:t=>class extends t{estreeParseRegExpLiteral({pattern:t,flags:e}){let s=null;try{s=new RegExp(t,e)}catch(r){}const i=this.estreeParseLiteral(s);return i.regex={pattern:t,flags:e},i}estreeParseBigIntLiteral(t){let e;try{e=BigInt(t)}catch(i){e=null}const s=this.estreeParseLiteral(e);return s.bigint=String(s.value||t),s}estreeParseDecimalLiteral(t){const e=this.estreeParseLiteral(null);return e.decimal=String(e.value||t),e}estreeParseLiteral(t){return this.parseLiteral(t,\"Literal\")}directiveToStmt(t){const e=t.value,s=this.startNodeAt(t.start,t.loc.start),i=this.startNodeAt(e.start,e.loc.start);return i.value=e.extra.expressionValue,i.raw=e.extra.raw,s.expression=this.finishNodeAt(i,\"Literal\",e.end,e.loc.end),s.directive=e.extra.raw.slice(1,-1),this.finishNodeAt(s,\"ExpressionStatement\",t.end,t.loc.end)}initFunction(t,e){super.initFunction(t,e),t.expression=!1}checkDeclaration(t){null!=t&&this.isObjectProperty(t)?this.checkDeclaration(t.value):super.checkDeclaration(t)}getObjectOrClassMethodParams(t){return t.value.params}isValidDirective(t){var e;return\"ExpressionStatement\"===t.type&&\"Literal\"===t.expression.type&&\"string\"===typeof t.expression.value&&!(null==(e=t.expression.extra)?void 0:e.parenthesized)}stmtToDirective(t){const e=super.stmtToDirective(t),s=t.expression.value;return this.addExtra(e.value,\"expressionValue\",s),e}parseBlockBody(t,...e){super.parseBlockBody(t,...e);const s=t.directives.map((t=>this.directiveToStmt(t)));t.body=s.concat(t.body),delete t.directives}pushClassMethod(t,e,s,i,r,a){this.parseMethod(e,s,i,r,a,\"ClassMethod\",!0),e.typeParameters&&(e.value.typeParameters=e.typeParameters,delete e.typeParameters),t.body.push(e)}parseExprAtom(t){switch(this.state.type){case l.num:case l.string:return this.estreeParseLiteral(this.state.value);case l.regexp:return this.estreeParseRegExpLiteral(this.state.value);case l.bigint:return this.estreeParseBigIntLiteral(this.state.value);case l.decimal:return this.estreeParseDecimalLiteral(this.state.value);case l._null:return this.estreeParseLiteral(null);case l._true:return this.estreeParseLiteral(!0);case l._false:return this.estreeParseLiteral(!1);default:return super.parseExprAtom(t)}}parseLiteral(t,e,s,i){const r=super.parseLiteral(t,e,s,i);return r.raw=r.extra.raw,delete r.extra,r}parseFunctionBody(t,e,s=!1){super.parseFunctionBody(t,e,s),t.expression=\"BlockStatement\"!==t.body.type}parseMethod(t,e,s,i,r,a,n=!1){let o=this.startNode();return o.kind=t.kind,o=super.parseMethod(o,e,s,i,r,a,n),o.type=\"FunctionExpression\",delete o.kind,t.value=o,a=\"ClassMethod\"===a?\"MethodDefinition\":a,this.finishNode(t,a)}parseObjectMethod(t,e,s,i,r){const a=super.parseObjectMethod(t,e,s,i,r);return a&&(a.type=\"Property\",\"method\"===a.kind&&(a.kind=\"init\"),a.shorthand=!1),a}parseObjectProperty(t,e,s,i,r){const a=super.parseObjectProperty(t,e,s,i,r);return a&&(a.kind=\"init\",a.type=\"Property\"),a}toAssignable(t,e=!1){return null!=t&&this.isObjectProperty(t)?(this.toAssignable(t.value,e),t):super.toAssignable(t,e)}toAssignableObjectExpressionProp(t,...e){\"get\"===t.kind||\"set\"===t.kind?this.raise(t.key.start,b.PatternHasAccessor):t.method?this.raise(t.key.start,b.PatternHasMethod):super.toAssignableObjectExpressionProp(t,...e)}finishCallExpression(t,e){return super.finishCallExpression(t,e),\"Import\"===t.callee.type&&(t.type=\"ImportExpression\",t.source=t.arguments[0],delete t.arguments,delete t.callee),t}toReferencedArguments(t){\"ImportExpression\"!==t.type&&super.toReferencedArguments(t)}parseExport(t){switch(super.parseExport(t),t.type){case\"ExportAllDeclaration\":t.exported=null;break;case\"ExportNamedDeclaration\":1===t.specifiers.length&&\"ExportNamespaceSpecifier\"===t.specifiers[0].type&&(t.type=\"ExportAllDeclaration\",t.exported=t.specifiers[0].exported,delete t.specifiers)}return t}parseSubscript(t,e,s,i,r){const a=super.parseSubscript(t,e,s,i,r);if(r.optionalChainMember){if(\"OptionalMemberExpression\"!==a.type&&\"OptionalCallExpression\"!==a.type||(a.type=a.type.substring(8)),r.stop){const t=this.startNodeAtNode(a);return t.expression=a,this.finishNode(t,\"ChainExpression\")}}else\"MemberExpression\"!==a.type&&\"CallExpression\"!==a.type||(a.optional=!1);return a}hasPropertyAsPrivateName(t){return\"ChainExpression\"===t.type&&(t=t.expression),super.hasPropertyAsPrivateName(t)}isOptionalChain(t){return\"ChainExpression\"===t.type}isObjectProperty(t){return\"Property\"===t.type&&\"init\"===t.kind&&!t.method}isObjectMethod(t){return t.method||\"get\"===t.kind||\"set\"===t.kind}},jsx:t=>class extends t{jsxReadToken(){let t=\"\",e=this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,et.UnterminatedJsxContent);const s=this.input.charCodeAt(this.state.pos);switch(s){case 60:case 123:return this.state.pos===this.state.start?60===s&&this.state.exprAllowed?(++this.state.pos,this.finishToken(l.jsxTagStart)):super.getTokenFromCode(s):(t+=this.input.slice(e,this.state.pos),this.finishToken(l.jsxText,t));case 38:t+=this.input.slice(e,this.state.pos),t+=this.jsxReadEntity(),e=this.state.pos;break;default:m(s)?(t+=this.input.slice(e,this.state.pos),t+=this.jsxReadNewLine(!0),e=this.state.pos):++this.state.pos}}}jsxReadNewLine(t){const e=this.input.charCodeAt(this.state.pos);let s;return++this.state.pos,13===e&&10===this.input.charCodeAt(this.state.pos)?(++this.state.pos,s=t?\"\\n\":\"\\r\\n\"):s=String.fromCharCode(e),++this.state.curLine,this.state.lineStart=this.state.pos,s}jsxReadString(t){let e=\"\",s=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,b.UnterminatedString);const i=this.input.charCodeAt(this.state.pos);if(i===t)break;38===i?(e+=this.input.slice(s,this.state.pos),e+=this.jsxReadEntity(),s=this.state.pos):m(i)?(e+=this.input.slice(s,this.state.pos),e+=this.jsxReadNewLine(!1),s=this.state.pos):++this.state.pos}return e+=this.input.slice(s,this.state.pos++),this.finishToken(l.string,e)}jsxReadEntity(){let t,e=\"\",s=0,i=this.input[this.state.pos];const r=++this.state.pos;for(;this.state.pos<this.length&&s++<10;){if(i=this.input[this.state.pos++],\";\"===i){\"#\"===e[0]?\"x\"===e[1]?(e=e.substr(2),Z.test(e)&&(t=String.fromCodePoint(parseInt(e,16)))):(e=e.substr(1),tt.test(e)&&(t=String.fromCodePoint(parseInt(e,10)))):t=$[e];break}e+=i}return t||(this.state.pos=r,\"&\")}jsxReadWord(){let t;const e=this.state.pos;do{t=this.input.charCodeAt(++this.state.pos)}while(L(t)||45===t);return this.finishToken(l.jsxName,this.input.slice(e,this.state.pos))}jsxParseIdentifier(){const t=this.startNode();return this.match(l.jsxName)?t.name=this.state.value:this.state.type.keyword?t.name=this.state.type.keyword:this.unexpected(),this.next(),this.finishNode(t,\"JSXIdentifier\")}jsxParseNamespacedName(){const t=this.state.start,e=this.state.startLoc,s=this.jsxParseIdentifier();if(!this.eat(l.colon))return s;const i=this.startNodeAt(t,e);return i.namespace=s,i.name=this.jsxParseIdentifier(),this.finishNode(i,\"JSXNamespacedName\")}jsxParseElementName(){const t=this.state.start,e=this.state.startLoc;let s=this.jsxParseNamespacedName();if(\"JSXNamespacedName\"===s.type)return s;for(;this.eat(l.dot);){const i=this.startNodeAt(t,e);i.object=s,i.property=this.jsxParseIdentifier(),s=this.finishNode(i,\"JSXMemberExpression\")}return s}jsxParseAttributeValue(){let t;switch(this.state.type){case l.braceL:return t=this.startNode(),this.next(),t=this.jsxParseExpressionContainer(t),\"JSXEmptyExpression\"===t.expression.type&&this.raise(t.start,et.AttributeIsEmpty),t;case l.jsxTagStart:case l.string:return this.parseExprAtom();default:throw this.raise(this.state.start,et.UnsupportedJsxValue)}}jsxParseEmptyExpression(){const t=this.startNodeAt(this.state.lastTokEnd,this.state.lastTokEndLoc);return this.finishNodeAt(t,\"JSXEmptyExpression\",this.state.start,this.state.startLoc)}jsxParseSpreadChild(t){return this.next(),t.expression=this.parseExpression(),this.expect(l.braceR),this.finishNode(t,\"JSXSpreadChild\")}jsxParseExpressionContainer(t){if(this.match(l.braceR))t.expression=this.jsxParseEmptyExpression();else{const e=this.parseExpression();t.expression=e}return this.expect(l.braceR),this.finishNode(t,\"JSXExpressionContainer\")}jsxParseAttribute(){const t=this.startNode();return this.eat(l.braceL)?(this.expect(l.ellipsis),t.argument=this.parseMaybeAssignAllowIn(),this.expect(l.braceR),this.finishNode(t,\"JSXSpreadAttribute\")):(t.name=this.jsxParseNamespacedName(),t.value=this.eat(l.eq)?this.jsxParseAttributeValue():null,this.finishNode(t,\"JSXAttribute\"))}jsxParseOpeningElementAt(t,e){const s=this.startNodeAt(t,e);return this.match(l.jsxTagEnd)?(this.expect(l.jsxTagEnd),this.finishNode(s,\"JSXOpeningFragment\")):(s.name=this.jsxParseElementName(),this.jsxParseOpeningElementAfterName(s))}jsxParseOpeningElementAfterName(t){const e=[];for(;!this.match(l.slash)&&!this.match(l.jsxTagEnd);)e.push(this.jsxParseAttribute());return t.attributes=e,t.selfClosing=this.eat(l.slash),this.expect(l.jsxTagEnd),this.finishNode(t,\"JSXOpeningElement\")}jsxParseClosingElementAt(t,e){const s=this.startNodeAt(t,e);return this.match(l.jsxTagEnd)?(this.expect(l.jsxTagEnd),this.finishNode(s,\"JSXClosingFragment\")):(s.name=this.jsxParseElementName(),this.expect(l.jsxTagEnd),this.finishNode(s,\"JSXClosingElement\"))}jsxParseElementAt(t,e){const s=this.startNodeAt(t,e),i=[],r=this.jsxParseOpeningElementAt(t,e);let a=null;if(!r.selfClosing){t:for(;;)switch(this.state.type){case l.jsxTagStart:if(t=this.state.start,e=this.state.startLoc,this.next(),this.eat(l.slash)){a=this.jsxParseClosingElementAt(t,e);break t}i.push(this.jsxParseElementAt(t,e));break;case l.jsxText:i.push(this.parseExprAtom());break;case l.braceL:{const t=this.startNode();this.next(),this.match(l.ellipsis)?i.push(this.jsxParseSpreadChild(t)):i.push(this.jsxParseExpressionContainer(t));break}default:throw this.unexpected()}st(r)&&!st(a)?this.raise(a.start,et.MissingClosingTagFragment):!st(r)&&st(a)?this.raise(a.start,et.MissingClosingTagElement,it(r.name)):st(r)||st(a)||it(a.name)!==it(r.name)&&this.raise(a.start,et.MissingClosingTagElement,it(r.name))}if(st(r)?(s.openingFragment=r,s.closingFragment=a):(s.openingElement=r,s.closingElement=a),s.children=i,this.isRelational(\"<\"))throw this.raise(this.state.start,et.UnwrappedAdjacentJSXElements);return st(r)?this.finishNode(s,\"JSXFragment\"):this.finishNode(s,\"JSXElement\")}jsxParseElement(){const t=this.state.start,e=this.state.startLoc;return this.next(),this.jsxParseElementAt(t,e)}parseExprAtom(t){return this.match(l.jsxText)?this.parseLiteral(this.state.value,\"JSXText\"):this.match(l.jsxTagStart)?this.jsxParseElement():this.isRelational(\"<\")&&33!==this.input.charCodeAt(this.state.pos)?(this.finishToken(l.jsxTagStart),this.jsxParseElement()):super.parseExprAtom(t)}getTokenFromCode(t){if(this.state.inPropertyName)return super.getTokenFromCode(t);const e=this.curContext();if(e===A.j_expr)return this.jsxReadToken();if(e===A.j_oTag||e===A.j_cTag){if(v(t))return this.jsxReadWord();if(62===t)return++this.state.pos,this.finishToken(l.jsxTagEnd);if((34===t||39===t)&&e===A.j_oTag)return this.jsxReadString(t)}return 60===t&&this.state.exprAllowed&&33!==this.input.charCodeAt(this.state.pos+1)?(++this.state.pos,this.finishToken(l.jsxTagStart)):super.getTokenFromCode(t)}updateContext(t){if(this.match(l.braceL)){const e=this.curContext();e===A.j_oTag?this.state.context.push(A.braceExpression):e===A.j_expr?this.state.context.push(A.templateQuasi):super.updateContext(t),this.state.exprAllowed=!0}else{if(!this.match(l.slash)||t!==l.jsxTagStart)return super.updateContext(t);this.state.context.length-=2,this.state.context.push(A.j_cTag),this.state.exprAllowed=!1}}},flow:t=>class extends t{constructor(t,e){super(t,e),this.flowPragma=void 0,this.flowPragma=void 0}shouldParseTypes(){return this.getPluginOption(\"flow\",\"all\")||\"flow\"===this.flowPragma}shouldParseEnums(){return!!this.getPluginOption(\"flow\",\"enums\")}finishToken(t,e){return t!==l.string&&t!==l.semi&&t!==l.interpreterDirective&&void 0===this.flowPragma&&(this.flowPragma=null),super.finishToken(t,e)}addComment(t){if(void 0===this.flowPragma){const e=Y.exec(t.value);if(e)if(\"flow\"===e[1])this.flowPragma=\"flow\";else{if(\"noflow\"!==e[1])throw new Error(\"Unexpected flow pragma\");this.flowPragma=\"noflow\"}else;}return super.addComment(t)}flowParseTypeInitialiser(t){const e=this.state.inType;this.state.inType=!0,this.expect(t||l.colon);const s=this.flowParseType();return this.state.inType=e,s}flowParsePredicate(){const t=this.startNode(),e=this.state.startLoc,s=this.state.start;this.expect(l.modulo);const i=this.state.startLoc;return this.expectContextual(\"checks\"),e.line===i.line&&e.column===i.column-1||this.raise(s,J.UnexpectedSpaceBetweenModuloChecks),this.eat(l.parenL)?(t.value=this.parseExpression(),this.expect(l.parenR),this.finishNode(t,\"DeclaredPredicate\")):this.finishNode(t,\"InferredPredicate\")}flowParseTypeAndPredicateInitialiser(){const t=this.state.inType;this.state.inType=!0,this.expect(l.colon);let e=null,s=null;return this.match(l.modulo)?(this.state.inType=t,s=this.flowParsePredicate()):(e=this.flowParseType(),this.state.inType=t,this.match(l.modulo)&&(s=this.flowParsePredicate())),[e,s]}flowParseDeclareClass(t){return this.next(),this.flowParseInterfaceish(t,!0),this.finishNode(t,\"DeclareClass\")}flowParseDeclareFunction(t){this.next();const e=t.id=this.parseIdentifier(),s=this.startNode(),i=this.startNode();this.isRelational(\"<\")?s.typeParameters=this.flowParseTypeParameterDeclaration():s.typeParameters=null,this.expect(l.parenL);const r=this.flowParseFunctionTypeParams();return s.params=r.params,s.rest=r.rest,this.expect(l.parenR),[s.returnType,t.predicate]=this.flowParseTypeAndPredicateInitialiser(),i.typeAnnotation=this.finishNode(s,\"FunctionTypeAnnotation\"),e.typeAnnotation=this.finishNode(i,\"TypeAnnotation\"),this.resetEndLocation(e),this.semicolon(),this.finishNode(t,\"DeclareFunction\")}flowParseDeclare(t,e){if(this.match(l._class))return this.flowParseDeclareClass(t);if(this.match(l._function))return this.flowParseDeclareFunction(t);if(this.match(l._var))return this.flowParseDeclareVariable(t);if(this.eatContextual(\"module\"))return this.match(l.dot)?this.flowParseDeclareModuleExports(t):(e&&this.raise(this.state.lastTokStart,J.NestedDeclareModule),this.flowParseDeclareModule(t));if(this.isContextual(\"type\"))return this.flowParseDeclareTypeAlias(t);if(this.isContextual(\"opaque\"))return this.flowParseDeclareOpaqueType(t);if(this.isContextual(\"interface\"))return this.flowParseDeclareInterface(t);if(this.match(l._export))return this.flowParseDeclareExportDeclaration(t,e);throw this.unexpected()}flowParseDeclareVariable(t){return this.next(),t.id=this.flowParseTypeAnnotatableIdentifier(!0),this.scope.declareName(t.id.name,5,t.id.start),this.semicolon(),this.finishNode(t,\"DeclareVariable\")}flowParseDeclareModule(t){this.scope.enter(0),this.match(l.string)?t.id=this.parseExprAtom():t.id=this.parseIdentifier();const e=t.body=this.startNode(),s=e.body=[];for(this.expect(l.braceL);!this.match(l.braceR);){let t=this.startNode();this.match(l._import)?(this.next(),this.isContextual(\"type\")||this.match(l._typeof)||this.raise(this.state.lastTokStart,J.InvalidNonTypeImportInDeclareModule),this.parseImport(t)):(this.expectContextual(\"declare\",J.UnsupportedStatementInDeclareModule),t=this.flowParseDeclare(t,!0)),s.push(t)}this.scope.exit(),this.expect(l.braceR),this.finishNode(e,\"BlockStatement\");let i=null,r=!1;return s.forEach((t=>{!function(t){return\"DeclareExportAllDeclaration\"===t.type||\"DeclareExportDeclaration\"===t.type&&(!t.declaration||\"TypeAlias\"!==t.declaration.type&&\"InterfaceDeclaration\"!==t.declaration.type)}(t)?\"DeclareModuleExports\"===t.type&&(r&&this.raise(t.start,J.DuplicateDeclareModuleExports),\"ES\"===i&&this.raise(t.start,J.AmbiguousDeclareModuleKind),i=\"CommonJS\",r=!0):(\"CommonJS\"===i&&this.raise(t.start,J.AmbiguousDeclareModuleKind),i=\"ES\")})),t.kind=i||\"CommonJS\",this.finishNode(t,\"DeclareModule\")}flowParseDeclareExportDeclaration(t,e){if(this.expect(l._export),this.eat(l._default))return this.match(l._function)||this.match(l._class)?t.declaration=this.flowParseDeclare(this.startNode()):(t.declaration=this.flowParseType(),this.semicolon()),t.default=!0,this.finishNode(t,\"DeclareExportDeclaration\");if(this.match(l._const)||this.isLet()||(this.isContextual(\"type\")||this.isContextual(\"interface\"))&&!e){const t=this.state.value,e=Q[t];throw this.raise(this.state.start,J.UnsupportedDeclareExportKind,t,e)}if(this.match(l._var)||this.match(l._function)||this.match(l._class)||this.isContextual(\"opaque\"))return t.declaration=this.flowParseDeclare(this.startNode()),t.default=!1,this.finishNode(t,\"DeclareExportDeclaration\");if(this.match(l.star)||this.match(l.braceL)||this.isContextual(\"interface\")||this.isContextual(\"type\")||this.isContextual(\"opaque\"))return\"ExportNamedDeclaration\"===(t=this.parseExport(t)).type&&(t.type=\"ExportDeclaration\",t.default=!1,delete t.exportKind),t.type=\"Declare\"+t.type,t;throw this.unexpected()}flowParseDeclareModuleExports(t){return this.next(),this.expectContextual(\"exports\"),t.typeAnnotation=this.flowParseTypeAnnotation(),this.semicolon(),this.finishNode(t,\"DeclareModuleExports\")}flowParseDeclareTypeAlias(t){return this.next(),this.flowParseTypeAlias(t),t.type=\"DeclareTypeAlias\",t}flowParseDeclareOpaqueType(t){return this.next(),this.flowParseOpaqueType(t,!0),t.type=\"DeclareOpaqueType\",t}flowParseDeclareInterface(t){return this.next(),this.flowParseInterfaceish(t),this.finishNode(t,\"DeclareInterface\")}flowParseInterfaceish(t,e=!1){if(t.id=this.flowParseRestrictedIdentifier(!e,!0),this.scope.declareName(t.id.name,e?17:9,t.id.start),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterDeclaration():t.typeParameters=null,t.extends=[],t.implements=[],t.mixins=[],this.eat(l._extends))do{t.extends.push(this.flowParseInterfaceExtends())}while(!e&&this.eat(l.comma));if(this.isContextual(\"mixins\")){this.next();do{t.mixins.push(this.flowParseInterfaceExtends())}while(this.eat(l.comma))}if(this.isContextual(\"implements\")){this.next();do{t.implements.push(this.flowParseInterfaceExtends())}while(this.eat(l.comma))}t.body=this.flowParseObjectType({allowStatic:e,allowExact:!1,allowSpread:!1,allowProto:e,allowInexact:!1})}flowParseInterfaceExtends(){const t=this.startNode();return t.id=this.flowParseQualifiedTypeIdentifier(),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterInstantiation():t.typeParameters=null,this.finishNode(t,\"InterfaceExtends\")}flowParseInterface(t){return this.flowParseInterfaceish(t),this.finishNode(t,\"InterfaceDeclaration\")}checkNotUnderscore(t){\"_\"===t&&this.raise(this.state.start,J.UnexpectedReservedUnderscore)}checkReservedType(t,e,s){W.has(t)&&this.raise(e,s?J.AssignReservedType:J.UnexpectedReservedType,t)}flowParseRestrictedIdentifier(t,e){return this.checkReservedType(this.state.value,this.state.start,e),this.parseIdentifier(t)}flowParseTypeAlias(t){return t.id=this.flowParseRestrictedIdentifier(!1,!0),this.scope.declareName(t.id.name,9,t.id.start),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterDeclaration():t.typeParameters=null,t.right=this.flowParseTypeInitialiser(l.eq),this.semicolon(),this.finishNode(t,\"TypeAlias\")}flowParseOpaqueType(t,e){return this.expectContextual(\"type\"),t.id=this.flowParseRestrictedIdentifier(!0,!0),this.scope.declareName(t.id.name,9,t.id.start),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterDeclaration():t.typeParameters=null,t.supertype=null,this.match(l.colon)&&(t.supertype=this.flowParseTypeInitialiser(l.colon)),t.impltype=null,e||(t.impltype=this.flowParseTypeInitialiser(l.eq)),this.semicolon(),this.finishNode(t,\"OpaqueType\")}flowParseTypeParameter(t=!1){const e=this.state.start,s=this.startNode(),i=this.flowParseVariance(),r=this.flowParseTypeAnnotatableIdentifier();return s.name=r.name,s.variance=i,s.bound=r.typeAnnotation,this.match(l.eq)?(this.eat(l.eq),s.default=this.flowParseType()):t&&this.raise(e,J.MissingTypeParamDefault),this.finishNode(s,\"TypeParameter\")}flowParseTypeParameterDeclaration(){const t=this.state.inType,e=this.startNode();e.params=[],this.state.inType=!0,this.isRelational(\"<\")||this.match(l.jsxTagStart)?this.next():this.unexpected();let s=!1;do{const t=this.flowParseTypeParameter(s);e.params.push(t),t.default&&(s=!0),this.isRelational(\">\")||this.expect(l.comma)}while(!this.isRelational(\">\"));return this.expectRelational(\">\"),this.state.inType=t,this.finishNode(e,\"TypeParameterDeclaration\")}flowParseTypeParameterInstantiation(){const t=this.startNode(),e=this.state.inType;t.params=[],this.state.inType=!0,this.expectRelational(\"<\");const s=this.state.noAnonFunctionType;for(this.state.noAnonFunctionType=!1;!this.isRelational(\">\");)t.params.push(this.flowParseType()),this.isRelational(\">\")||this.expect(l.comma);return this.state.noAnonFunctionType=s,this.expectRelational(\">\"),this.state.inType=e,this.finishNode(t,\"TypeParameterInstantiation\")}flowParseTypeParameterInstantiationCallOrNew(){const t=this.startNode(),e=this.state.inType;for(t.params=[],this.state.inType=!0,this.expectRelational(\"<\");!this.isRelational(\">\");)t.params.push(this.flowParseTypeOrImplicitInstantiation()),this.isRelational(\">\")||this.expect(l.comma);return this.expectRelational(\">\"),this.state.inType=e,this.finishNode(t,\"TypeParameterInstantiation\")}flowParseInterfaceType(){const t=this.startNode();if(this.expectContextual(\"interface\"),t.extends=[],this.eat(l._extends))do{t.extends.push(this.flowParseInterfaceExtends())}while(this.eat(l.comma));return t.body=this.flowParseObjectType({allowStatic:!1,allowExact:!1,allowSpread:!1,allowProto:!1,allowInexact:!1}),this.finishNode(t,\"InterfaceTypeAnnotation\")}flowParseObjectPropertyKey(){return this.match(l.num)||this.match(l.string)?this.parseExprAtom():this.parseIdentifier(!0)}flowParseObjectTypeIndexer(t,e,s){return t.static=e,this.lookahead().type===l.colon?(t.id=this.flowParseObjectPropertyKey(),t.key=this.flowParseTypeInitialiser()):(t.id=null,t.key=this.flowParseType()),this.expect(l.bracketR),t.value=this.flowParseTypeInitialiser(),t.variance=s,this.finishNode(t,\"ObjectTypeIndexer\")}flowParseObjectTypeInternalSlot(t,e){return t.static=e,t.id=this.flowParseObjectPropertyKey(),this.expect(l.bracketR),this.expect(l.bracketR),this.isRelational(\"<\")||this.match(l.parenL)?(t.method=!0,t.optional=!1,t.value=this.flowParseObjectTypeMethodish(this.startNodeAt(t.start,t.loc.start))):(t.method=!1,this.eat(l.question)&&(t.optional=!0),t.value=this.flowParseTypeInitialiser()),this.finishNode(t,\"ObjectTypeInternalSlot\")}flowParseObjectTypeMethodish(t){for(t.params=[],t.rest=null,t.typeParameters=null,this.isRelational(\"<\")&&(t.typeParameters=this.flowParseTypeParameterDeclaration()),this.expect(l.parenL);!this.match(l.parenR)&&!this.match(l.ellipsis);)t.params.push(this.flowParseFunctionTypeParam()),this.match(l.parenR)||this.expect(l.comma);return this.eat(l.ellipsis)&&(t.rest=this.flowParseFunctionTypeParam()),this.expect(l.parenR),t.returnType=this.flowParseTypeInitialiser(),this.finishNode(t,\"FunctionTypeAnnotation\")}flowParseObjectTypeCallProperty(t,e){const s=this.startNode();return t.static=e,t.value=this.flowParseObjectTypeMethodish(s),this.finishNode(t,\"ObjectTypeCallProperty\")}flowParseObjectType({allowStatic:t,allowExact:e,allowSpread:s,allowProto:i,allowInexact:r}){const a=this.state.inType;this.state.inType=!0;const n=this.startNode();let o,h;n.callProperties=[],n.properties=[],n.indexers=[],n.internalSlots=[];let p=!1;for(e&&this.match(l.braceBarL)?(this.expect(l.braceBarL),o=l.braceBarR,h=!0):(this.expect(l.braceL),o=l.braceR,h=!1),n.exact=h;!this.match(o);){let e=!1,a=null,o=null;const c=this.startNode();if(i&&this.isContextual(\"proto\")){const e=this.lookahead();e.type!==l.colon&&e.type!==l.question&&(this.next(),a=this.state.start,t=!1)}if(t&&this.isContextual(\"static\")){const t=this.lookahead();t.type!==l.colon&&t.type!==l.question&&(this.next(),e=!0)}const u=this.flowParseVariance();if(this.eat(l.bracketL))null!=a&&this.unexpected(a),this.eat(l.bracketL)?(u&&this.unexpected(u.start),n.internalSlots.push(this.flowParseObjectTypeInternalSlot(c,e))):n.indexers.push(this.flowParseObjectTypeIndexer(c,e,u));else if(this.match(l.parenL)||this.isRelational(\"<\"))null!=a&&this.unexpected(a),u&&this.unexpected(u.start),n.callProperties.push(this.flowParseObjectTypeCallProperty(c,e));else{let t=\"init\";if(this.isContextual(\"get\")||this.isContextual(\"set\")){const e=this.lookahead();e.type!==l.name&&e.type!==l.string&&e.type!==l.num||(t=this.state.value,this.next())}const i=this.flowParseObjectTypeProperty(c,e,a,u,t,s,null!=r?r:!h);null===i?(p=!0,o=this.state.lastTokStart):n.properties.push(i)}this.flowObjectTypeSemicolon(),!o||this.match(l.braceR)||this.match(l.braceBarR)||this.raise(o,J.UnexpectedExplicitInexactInObject)}this.expect(o),s&&(n.inexact=p);const c=this.finishNode(n,\"ObjectTypeAnnotation\");return this.state.inType=a,c}flowParseObjectTypeProperty(t,e,s,i,r,a,n){if(this.eat(l.ellipsis)){return this.match(l.comma)||this.match(l.semi)||this.match(l.braceR)||this.match(l.braceBarR)?(a?n||this.raise(this.state.lastTokStart,J.InexactInsideExact):this.raise(this.state.lastTokStart,J.InexactInsideNonObject),i&&this.raise(i.start,J.InexactVariance),null):(a||this.raise(this.state.lastTokStart,J.UnexpectedSpreadType),null!=s&&this.unexpected(s),i&&this.raise(i.start,J.SpreadVariance),t.argument=this.flowParseType(),this.finishNode(t,\"ObjectTypeSpreadProperty\"))}{t.key=this.flowParseObjectPropertyKey(),t.static=e,t.proto=null!=s,t.kind=r;let a=!1;return this.isRelational(\"<\")||this.match(l.parenL)?(t.method=!0,null!=s&&this.unexpected(s),i&&this.unexpected(i.start),t.value=this.flowParseObjectTypeMethodish(this.startNodeAt(t.start,t.loc.start)),\"get\"!==r&&\"set\"!==r||this.flowCheckGetterSetterParams(t)):(\"init\"!==r&&this.unexpected(),t.method=!1,this.eat(l.question)&&(a=!0),t.value=this.flowParseTypeInitialiser(),t.variance=i),t.optional=a,this.finishNode(t,\"ObjectTypeProperty\")}}flowCheckGetterSetterParams(t){const e=\"get\"===t.kind?0:1,s=t.start;t.value.params.length+(t.value.rest?1:0)!==e&&(\"get\"===t.kind?this.raise(s,b.BadGetterArity):this.raise(s,b.BadSetterArity)),\"set\"===t.kind&&t.value.rest&&this.raise(s,b.BadSetterRestParameter)}flowObjectTypeSemicolon(){this.eat(l.semi)||this.eat(l.comma)||this.match(l.braceR)||this.match(l.braceBarR)||this.unexpected()}flowParseQualifiedTypeIdentifier(t,e,s){t=t||this.state.start,e=e||this.state.startLoc;let i=s||this.flowParseRestrictedIdentifier(!0);for(;this.eat(l.dot);){const s=this.startNodeAt(t,e);s.qualification=i,s.id=this.flowParseRestrictedIdentifier(!0),i=this.finishNode(s,\"QualifiedTypeIdentifier\")}return i}flowParseGenericType(t,e,s){const i=this.startNodeAt(t,e);return i.typeParameters=null,i.id=this.flowParseQualifiedTypeIdentifier(t,e,s),this.isRelational(\"<\")&&(i.typeParameters=this.flowParseTypeParameterInstantiation()),this.finishNode(i,\"GenericTypeAnnotation\")}flowParseTypeofType(){const t=this.startNode();return this.expect(l._typeof),t.argument=this.flowParsePrimaryType(),this.finishNode(t,\"TypeofTypeAnnotation\")}flowParseTupleType(){const t=this.startNode();for(t.types=[],this.expect(l.bracketL);this.state.pos<this.length&&!this.match(l.bracketR)&&(t.types.push(this.flowParseType()),!this.match(l.bracketR));)this.expect(l.comma);return this.expect(l.bracketR),this.finishNode(t,\"TupleTypeAnnotation\")}flowParseFunctionTypeParam(){let t=null,e=!1,s=null;const i=this.startNode(),r=this.lookahead();return r.type===l.colon||r.type===l.question?(t=this.parseIdentifier(),this.eat(l.question)&&(e=!0),s=this.flowParseTypeInitialiser()):s=this.flowParseType(),i.name=t,i.optional=e,i.typeAnnotation=s,this.finishNode(i,\"FunctionTypeParam\")}reinterpretTypeAsFunctionTypeParam(t){const e=this.startNodeAt(t.start,t.loc.start);return e.name=null,e.optional=!1,e.typeAnnotation=t,this.finishNode(e,\"FunctionTypeParam\")}flowParseFunctionTypeParams(t=[]){let e=null;for(;!this.match(l.parenR)&&!this.match(l.ellipsis);)t.push(this.flowParseFunctionTypeParam()),this.match(l.parenR)||this.expect(l.comma);return this.eat(l.ellipsis)&&(e=this.flowParseFunctionTypeParam()),{params:t,rest:e}}flowIdentToTypeAnnotation(t,e,s,i){switch(i.name){case\"any\":return this.finishNode(s,\"AnyTypeAnnotation\");case\"bool\":case\"boolean\":return this.finishNode(s,\"BooleanTypeAnnotation\");case\"mixed\":return this.finishNode(s,\"MixedTypeAnnotation\");case\"empty\":return this.finishNode(s,\"EmptyTypeAnnotation\");case\"number\":return this.finishNode(s,\"NumberTypeAnnotation\");case\"string\":return this.finishNode(s,\"StringTypeAnnotation\");case\"symbol\":return this.finishNode(s,\"SymbolTypeAnnotation\");default:return this.checkNotUnderscore(i.name),this.flowParseGenericType(t,e,i)}}flowParsePrimaryType(){const t=this.state.start,e=this.state.startLoc,s=this.startNode();let i,r,a=!1;const n=this.state.noAnonFunctionType;switch(this.state.type){case l.name:return this.isContextual(\"interface\")?this.flowParseInterfaceType():this.flowIdentToTypeAnnotation(t,e,s,this.parseIdentifier());case l.braceL:return this.flowParseObjectType({allowStatic:!1,allowExact:!1,allowSpread:!0,allowProto:!1,allowInexact:!0});case l.braceBarL:return this.flowParseObjectType({allowStatic:!1,allowExact:!0,allowSpread:!0,allowProto:!1,allowInexact:!1});case l.bracketL:return this.state.noAnonFunctionType=!1,r=this.flowParseTupleType(),this.state.noAnonFunctionType=n,r;case l.relational:if(\"<\"===this.state.value)return s.typeParameters=this.flowParseTypeParameterDeclaration(),this.expect(l.parenL),i=this.flowParseFunctionTypeParams(),s.params=i.params,s.rest=i.rest,this.expect(l.parenR),this.expect(l.arrow),s.returnType=this.flowParseType(),this.finishNode(s,\"FunctionTypeAnnotation\");break;case l.parenL:if(this.next(),!this.match(l.parenR)&&!this.match(l.ellipsis))if(this.match(l.name)){const t=this.lookahead().type;a=t!==l.question&&t!==l.colon}else a=!0;if(a){if(this.state.noAnonFunctionType=!1,r=this.flowParseType(),this.state.noAnonFunctionType=n,this.state.noAnonFunctionType||!(this.match(l.comma)||this.match(l.parenR)&&this.lookahead().type===l.arrow))return this.expect(l.parenR),r;this.eat(l.comma)}return i=r?this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r)]):this.flowParseFunctionTypeParams(),s.params=i.params,s.rest=i.rest,this.expect(l.parenR),this.expect(l.arrow),s.returnType=this.flowParseType(),s.typeParameters=null,this.finishNode(s,\"FunctionTypeAnnotation\");case l.string:return this.parseLiteral(this.state.value,\"StringLiteralTypeAnnotation\");case l._true:case l._false:return s.value=this.match(l._true),this.next(),this.finishNode(s,\"BooleanLiteralTypeAnnotation\");case l.plusMin:if(\"-\"===this.state.value){if(this.next(),this.match(l.num))return this.parseLiteral(-this.state.value,\"NumberLiteralTypeAnnotation\",s.start,s.loc.start);if(this.match(l.bigint))return this.parseLiteral(-this.state.value,\"BigIntLiteralTypeAnnotation\",s.start,s.loc.start);throw this.raise(this.state.start,J.UnexpectedSubtractionOperand)}throw this.unexpected();case l.num:return this.parseLiteral(this.state.value,\"NumberLiteralTypeAnnotation\");case l.bigint:return this.parseLiteral(this.state.value,\"BigIntLiteralTypeAnnotation\");case l._void:return this.next(),this.finishNode(s,\"VoidTypeAnnotation\");case l._null:return this.next(),this.finishNode(s,\"NullLiteralTypeAnnotation\");case l._this:return this.next(),this.finishNode(s,\"ThisTypeAnnotation\");case l.star:return this.next(),this.finishNode(s,\"ExistsTypeAnnotation\");default:if(\"typeof\"===this.state.type.keyword)return this.flowParseTypeofType();if(this.state.type.keyword){const t=this.state.type.label;return this.next(),super.createIdentifier(s,t)}}throw this.unexpected()}flowParsePostfixType(){const t=this.state.start,e=this.state.startLoc;let s=this.flowParsePrimaryType();for(;this.match(l.bracketL)&&!this.canInsertSemicolon();){const i=this.startNodeAt(t,e);i.elementType=s,this.expect(l.bracketL),this.expect(l.bracketR),s=this.finishNode(i,\"ArrayTypeAnnotation\")}return s}flowParsePrefixType(){const t=this.startNode();return this.eat(l.question)?(t.typeAnnotation=this.flowParsePrefixType(),this.finishNode(t,\"NullableTypeAnnotation\")):this.flowParsePostfixType()}flowParseAnonFunctionWithoutParens(){const t=this.flowParsePrefixType();if(!this.state.noAnonFunctionType&&this.eat(l.arrow)){const e=this.startNodeAt(t.start,t.loc.start);return e.params=[this.reinterpretTypeAsFunctionTypeParam(t)],e.rest=null,e.returnType=this.flowParseType(),e.typeParameters=null,this.finishNode(e,\"FunctionTypeAnnotation\")}return t}flowParseIntersectionType(){const t=this.startNode();this.eat(l.bitwiseAND);const e=this.flowParseAnonFunctionWithoutParens();for(t.types=[e];this.eat(l.bitwiseAND);)t.types.push(this.flowParseAnonFunctionWithoutParens());return 1===t.types.length?e:this.finishNode(t,\"IntersectionTypeAnnotation\")}flowParseUnionType(){const t=this.startNode();this.eat(l.bitwiseOR);const e=this.flowParseIntersectionType();for(t.types=[e];this.eat(l.bitwiseOR);)t.types.push(this.flowParseIntersectionType());return 1===t.types.length?e:this.finishNode(t,\"UnionTypeAnnotation\")}flowParseType(){const t=this.state.inType;this.state.inType=!0;const e=this.flowParseUnionType();return this.state.inType=t,this.state.exprAllowed=this.state.exprAllowed||this.state.noAnonFunctionType,e}flowParseTypeOrImplicitInstantiation(){if(this.state.type===l.name&&\"_\"===this.state.value){const t=this.state.start,e=this.state.startLoc,s=this.parseIdentifier();return this.flowParseGenericType(t,e,s)}return this.flowParseType()}flowParseTypeAnnotation(){const t=this.startNode();return t.typeAnnotation=this.flowParseTypeInitialiser(),this.finishNode(t,\"TypeAnnotation\")}flowParseTypeAnnotatableIdentifier(t){const e=t?this.parseIdentifier():this.flowParseRestrictedIdentifier();return this.match(l.colon)&&(e.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(e)),e}typeCastToParameter(t){return t.expression.typeAnnotation=t.typeAnnotation,this.resetEndLocation(t.expression,t.typeAnnotation.end,t.typeAnnotation.loc.end),t.expression}flowParseVariance(){let t=null;return this.match(l.plusMin)&&(t=this.startNode(),\"+\"===this.state.value?t.kind=\"plus\":t.kind=\"minus\",this.next(),this.finishNode(t,\"Variance\")),t}parseFunctionBody(t,e,s=!1){return e?this.forwardNoArrowParamsConversionAt(t,(()=>super.parseFunctionBody(t,!0,s))):super.parseFunctionBody(t,!1,s)}parseFunctionBodyAndFinish(t,e,s=!1){if(this.match(l.colon)){const e=this.startNode();[e.typeAnnotation,t.predicate]=this.flowParseTypeAndPredicateInitialiser(),t.returnType=e.typeAnnotation?this.finishNode(e,\"TypeAnnotation\"):null}super.parseFunctionBodyAndFinish(t,e,s)}parseStatement(t,e){if(this.state.strict&&this.match(l.name)&&\"interface\"===this.state.value){const t=this.lookahead();if(t.type===l.name||q(t.value)){const t=this.startNode();return this.next(),this.flowParseInterface(t)}}else if(this.shouldParseEnums()&&this.isContextual(\"enum\")){const t=this.startNode();return this.next(),this.flowParseEnumDeclaration(t)}const s=super.parseStatement(t,e);return void 0!==this.flowPragma||this.isValidDirective(s)||(this.flowPragma=null),s}parseExpressionStatement(t,e){if(\"Identifier\"===e.type)if(\"declare\"===e.name){if(this.match(l._class)||this.match(l.name)||this.match(l._function)||this.match(l._var)||this.match(l._export))return this.flowParseDeclare(t)}else if(this.match(l.name)){if(\"interface\"===e.name)return this.flowParseInterface(t);if(\"type\"===e.name)return this.flowParseTypeAlias(t);if(\"opaque\"===e.name)return this.flowParseOpaqueType(t,!1)}return super.parseExpressionStatement(t,e)}shouldParseExportDeclaration(){return this.isContextual(\"type\")||this.isContextual(\"interface\")||this.isContextual(\"opaque\")||this.shouldParseEnums()&&this.isContextual(\"enum\")||super.shouldParseExportDeclaration()}isExportDefaultSpecifier(){return(!this.match(l.name)||!(\"type\"===this.state.value||\"interface\"===this.state.value||\"opaque\"===this.state.value||this.shouldParseEnums()&&\"enum\"===this.state.value))&&super.isExportDefaultSpecifier()}parseExportDefaultExpression(){if(this.shouldParseEnums()&&this.isContextual(\"enum\")){const t=this.startNode();return this.next(),this.flowParseEnumDeclaration(t)}return super.parseExportDefaultExpression()}parseConditional(t,e,s,i){if(!this.match(l.question))return t;if(i){const r=this.tryParse((()=>super.parseConditional(t,e,s)));return r.node?(r.error&&(this.state=r.failState),r.node):(i.start=r.error.pos||this.state.start,t)}this.expect(l.question);const r=this.state.clone(),a=this.state.noArrowAt,n=this.startNodeAt(e,s);let{consequent:o,failed:h}=this.tryParseConditionalConsequent(),[p,c]=this.getArrowLikeExpressions(o);if(h||c.length>0){const t=[...a];if(c.length>0){this.state=r,this.state.noArrowAt=t;for(let e=0;e<c.length;e++)t.push(c[e].start);({consequent:o,failed:h}=this.tryParseConditionalConsequent()),[p,c]=this.getArrowLikeExpressions(o)}h&&p.length>1&&this.raise(r.start,J.AmbiguousConditionalArrow),h&&1===p.length&&(this.state=r,this.state.noArrowAt=t.concat(p[0].start),({consequent:o,failed:h}=this.tryParseConditionalConsequent()))}return this.getArrowLikeExpressions(o,!0),this.state.noArrowAt=a,this.expect(l.colon),n.test=t,n.consequent=o,n.alternate=this.forwardNoArrowParamsConversionAt(n,(()=>this.parseMaybeAssign(void 0,void 0,void 0))),this.finishNode(n,\"ConditionalExpression\")}tryParseConditionalConsequent(){this.state.noArrowParamsConversionAt.push(this.state.start);const t=this.parseMaybeAssignAllowIn(),e=!this.match(l.colon);return this.state.noArrowParamsConversionAt.pop(),{consequent:t,failed:e}}getArrowLikeExpressions(t,e){const s=[t],i=[];for(;0!==s.length;){const t=s.pop();\"ArrowFunctionExpression\"===t.type?(t.typeParameters||!t.returnType?this.finishArrowValidation(t):i.push(t),s.push(t.body)):\"ConditionalExpression\"===t.type&&(s.push(t.consequent),s.push(t.alternate))}return e?(i.forEach((t=>this.finishArrowValidation(t))),[i,[]]):function(t,e){const s=[],i=[];for(let r=0;r<t.length;r++)(e(t[r],r,t)?s:i).push(t[r]);return[s,i]}(i,(t=>t.params.every((t=>this.isAssignable(t,!0)))))}finishArrowValidation(t){var e;this.toAssignableList(t.params,null==(e=t.extra)?void 0:e.trailingComma,!1),this.scope.enter(6),super.checkParams(t,!1,!0),this.scope.exit()}forwardNoArrowParamsConversionAt(t,e){let s;return-1!==this.state.noArrowParamsConversionAt.indexOf(t.start)?(this.state.noArrowParamsConversionAt.push(this.state.start),s=e(),this.state.noArrowParamsConversionAt.pop()):s=e(),s}parseParenItem(t,e,s){if(t=super.parseParenItem(t,e,s),this.eat(l.question)&&(t.optional=!0,this.resetEndLocation(t)),this.match(l.colon)){const i=this.startNodeAt(e,s);return i.expression=t,i.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(i,\"TypeCastExpression\")}return t}assertModuleNodeAllowed(t){\"ImportDeclaration\"===t.type&&(\"type\"===t.importKind||\"typeof\"===t.importKind)||\"ExportNamedDeclaration\"===t.type&&\"type\"===t.exportKind||\"ExportAllDeclaration\"===t.type&&\"type\"===t.exportKind||super.assertModuleNodeAllowed(t)}parseExport(t){const e=super.parseExport(t);return\"ExportNamedDeclaration\"!==e.type&&\"ExportAllDeclaration\"!==e.type||(e.exportKind=e.exportKind||\"value\"),e}parseExportDeclaration(t){if(this.isContextual(\"type\")){t.exportKind=\"type\";const e=this.startNode();return this.next(),this.match(l.braceL)?(t.specifiers=this.parseExportSpecifiers(),this.parseExportFrom(t),null):this.flowParseTypeAlias(e)}if(this.isContextual(\"opaque\")){t.exportKind=\"type\";const e=this.startNode();return this.next(),this.flowParseOpaqueType(e,!1)}if(this.isContextual(\"interface\")){t.exportKind=\"type\";const e=this.startNode();return this.next(),this.flowParseInterface(e)}if(this.shouldParseEnums()&&this.isContextual(\"enum\")){t.exportKind=\"value\";const e=this.startNode();return this.next(),this.flowParseEnumDeclaration(e)}return super.parseExportDeclaration(t)}eatExportStar(t){return!!super.eatExportStar(...arguments)||!(!this.isContextual(\"type\")||this.lookahead().type!==l.star)&&(t.exportKind=\"type\",this.next(),this.next(),!0)}maybeParseExportNamespaceSpecifier(t){const e=this.state.start,s=super.maybeParseExportNamespaceSpecifier(t);return s&&\"type\"===t.exportKind&&this.unexpected(e),s}parseClassId(t,e,s){super.parseClassId(t,e,s),this.isRelational(\"<\")&&(t.typeParameters=this.flowParseTypeParameterDeclaration())}parseClassMember(t,e,s){const i=this.state.start;if(this.isContextual(\"declare\")){if(this.parseClassMemberFromModifier(t,e))return;e.declare=!0}super.parseClassMember(t,e,s),e.declare&&(\"ClassProperty\"!==e.type&&\"ClassPrivateProperty\"!==e.type?this.raise(i,J.DeclareClassElement):e.value&&this.raise(e.value.start,J.DeclareClassFieldInitializer))}getTokenFromCode(t){const e=this.input.charCodeAt(this.state.pos+1);return 123===t&&124===e?this.finishOp(l.braceBarL,2):!this.state.inType||62!==t&&60!==t?this.state.inType&&63===t?this.finishOp(l.question,1):function(t,e){return 64===t&&64===e}(t,e)?(this.state.isIterator=!0,super.readWord()):super.getTokenFromCode(t):this.finishOp(l.relational,1)}isAssignable(t,e){switch(t.type){case\"Identifier\":case\"ObjectPattern\":case\"ArrayPattern\":case\"AssignmentPattern\":return!0;case\"ObjectExpression\":{const e=t.properties.length-1;return t.properties.every(((t,s)=>\"ObjectMethod\"!==t.type&&(s===e||\"SpreadElement\"===t.type)&&this.isAssignable(t)))}case\"ObjectProperty\":return this.isAssignable(t.value);case\"SpreadElement\":return this.isAssignable(t.argument);case\"ArrayExpression\":return t.elements.every((t=>this.isAssignable(t)));case\"AssignmentExpression\":return\"=\"===t.operator;case\"ParenthesizedExpression\":case\"TypeCastExpression\":return this.isAssignable(t.expression);case\"MemberExpression\":case\"OptionalMemberExpression\":return!e;default:return!1}}toAssignable(t,e=!1){return\"TypeCastExpression\"===t.type?super.toAssignable(this.typeCastToParameter(t),e):super.toAssignable(t,e)}toAssignableList(t,e,s){for(let i=0;i<t.length;i++){const e=t[i];\"TypeCastExpression\"===(null==e?void 0:e.type)&&(t[i]=this.typeCastToParameter(e))}return super.toAssignableList(t,e,s)}toReferencedList(t,e){for(let i=0;i<t.length;i++){var s;const r=t[i];r&&\"TypeCastExpression\"===r.type&&!(null==(s=r.extra)?void 0:s.parenthesized)&&(t.length>1||!e)&&this.raise(r.typeAnnotation.start,J.TypeCastInPattern)}return t}parseArrayLike(t,e,s,i){const r=super.parseArrayLike(t,e,s,i);return e&&!this.state.maybeInArrowParameters&&this.toReferencedList(r.elements),r}checkLVal(t,...e){if(\"TypeCastExpression\"!==t.type)return super.checkLVal(t,...e)}parseClassProperty(t){return this.match(l.colon)&&(t.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassProperty(t)}parseClassPrivateProperty(t){return this.match(l.colon)&&(t.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassPrivateProperty(t)}isClassMethod(){return this.isRelational(\"<\")||super.isClassMethod()}isClassProperty(){return this.match(l.colon)||super.isClassProperty()}isNonstaticConstructor(t){return!this.match(l.colon)&&super.isNonstaticConstructor(t)}pushClassMethod(t,e,s,i,r,a){e.variance&&this.unexpected(e.variance.start),delete e.variance,this.isRelational(\"<\")&&(e.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassMethod(t,e,s,i,r,a)}pushClassPrivateMethod(t,e,s,i){e.variance&&this.unexpected(e.variance.start),delete e.variance,this.isRelational(\"<\")&&(e.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassPrivateMethod(t,e,s,i)}parseClassSuper(t){if(super.parseClassSuper(t),t.superClass&&this.isRelational(\"<\")&&(t.superTypeParameters=this.flowParseTypeParameterInstantiation()),this.isContextual(\"implements\")){this.next();const e=t.implements=[];do{const t=this.startNode();t.id=this.flowParseRestrictedIdentifier(!0),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterInstantiation():t.typeParameters=null,e.push(this.finishNode(t,\"ClassImplements\"))}while(this.eat(l.comma))}}parsePropertyName(t,e){const s=this.flowParseVariance(),i=super.parsePropertyName(t,e);return t.variance=s,i}parseObjPropValue(t,e,s,i,r,a,n,o){let h;t.variance&&this.unexpected(t.variance.start),delete t.variance,this.isRelational(\"<\")&&!n&&(h=this.flowParseTypeParameterDeclaration(),this.match(l.parenL)||this.unexpected()),super.parseObjPropValue(t,e,s,i,r,a,n,o),h&&((t.value||t).typeParameters=h)}parseAssignableListItemTypes(t){return this.eat(l.question)&&(\"Identifier\"!==t.type&&this.raise(t.start,J.OptionalBindingPattern),t.optional=!0),this.match(l.colon)&&(t.typeAnnotation=this.flowParseTypeAnnotation()),this.resetEndLocation(t),t}parseMaybeDefault(t,e,s){const i=super.parseMaybeDefault(t,e,s);return\"AssignmentPattern\"===i.type&&i.typeAnnotation&&i.right.start<i.typeAnnotation.start&&this.raise(i.typeAnnotation.start,J.TypeBeforeInitializer),i}shouldParseDefaultImport(t){return X(t)?G(this.state):super.shouldParseDefaultImport(t)}parseImportSpecifierLocal(t,e,s,i){e.local=X(t)?this.flowParseRestrictedIdentifier(!0,!0):this.parseIdentifier(),this.checkLVal(e.local,i,9),t.specifiers.push(this.finishNode(e,s))}maybeParseDefaultImportSpecifier(t){t.importKind=\"value\";let e=null;if(this.match(l._typeof)?e=\"typeof\":this.isContextual(\"type\")&&(e=\"type\"),e){const s=this.lookahead();\"type\"===e&&s.type===l.star&&this.unexpected(s.start),(G(s)||s.type===l.braceL||s.type===l.star)&&(this.next(),t.importKind=e)}return super.maybeParseDefaultImportSpecifier(t)}parseImportSpecifier(t){const e=this.startNode(),s=this.state.start,i=this.parseModuleExportName();let r=null;\"Identifier\"===i.type&&(\"type\"===i.name?r=\"type\":\"typeof\"===i.name&&(r=\"typeof\"));let a=!1;if(this.isContextual(\"as\")&&!this.isLookaheadContextual(\"as\")){const t=this.parseIdentifier(!0);null===r||this.match(l.name)||this.state.type.keyword?(e.imported=i,e.importKind=null,e.local=this.parseIdentifier()):(e.imported=t,e.importKind=r,e.local=t.__clone())}else if(null!==r&&(this.match(l.name)||this.state.type.keyword))e.imported=this.parseIdentifier(!0),e.importKind=r,this.eatContextual(\"as\")?e.local=this.parseIdentifier():(a=!0,e.local=e.imported.__clone());else{if(\"StringLiteral\"===i.type)throw this.raise(e.start,b.ImportBindingIsString,i.value);a=!0,e.imported=i,e.importKind=null,e.local=e.imported.__clone()}const n=X(t),o=X(e);n&&o&&this.raise(s,J.ImportTypeShorthandOnlyInPureImport),(n||o)&&this.checkReservedType(e.local.name,e.local.start,!0),!a||n||o||this.checkReservedWord(e.local.name,e.start,!0,!0),this.checkLVal(e.local,\"import specifier\",9),t.specifiers.push(this.finishNode(e,\"ImportSpecifier\"))}parseFunctionParams(t,e){const s=t.kind;\"get\"!==s&&\"set\"!==s&&this.isRelational(\"<\")&&(t.typeParameters=this.flowParseTypeParameterDeclaration()),super.parseFunctionParams(t,e)}parseVarId(t,e){super.parseVarId(t,e),this.match(l.colon)&&(t.id.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(t.id))}parseAsyncArrowFromCallExpression(t,e){if(this.match(l.colon)){const e=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0,t.returnType=this.flowParseTypeAnnotation(),this.state.noAnonFunctionType=e}return super.parseAsyncArrowFromCallExpression(t,e)}shouldParseAsyncArrow(){return this.match(l.colon)||super.shouldParseAsyncArrow()}parseMaybeAssign(t,e,s){var i;let r,a=null;if(this.hasPlugin(\"jsx\")&&(this.match(l.jsxTagStart)||this.isRelational(\"<\"))){if(a=this.state.clone(),r=this.tryParse((()=>super.parseMaybeAssign(t,e,s)),a),!r.error)return r.node;const{context:i}=this.state;i[i.length-1]===A.j_oTag?i.length-=2:i[i.length-1]===A.j_expr&&(i.length-=1)}if((null==(i=r)?void 0:i.error)||this.isRelational(\"<\")){var n,o;let i;a=a||this.state.clone();const h=this.tryParse((r=>{var a;i=this.flowParseTypeParameterDeclaration();const n=this.forwardNoArrowParamsConversionAt(i,(()=>{const r=super.parseMaybeAssign(t,e,s);return this.resetStartLocationFromNode(r,i),r}));\"ArrowFunctionExpression\"!==n.type&&(null==(a=n.extra)?void 0:a.parenthesized)&&r();const o=this.maybeUnwrapTypeCastExpression(n);return o.typeParameters=i,this.resetStartLocationFromNode(o,i),n}),a);let p=null;if(h.node&&\"ArrowFunctionExpression\"===this.maybeUnwrapTypeCastExpression(h.node).type){if(!h.error&&!h.aborted)return h.node.async&&this.raise(i.start,J.UnexpectedTypeParameterBeforeAsyncArrowFunction),h.node;p=h.node}if(null==(n=r)?void 0:n.node)return this.state=r.failState,r.node;if(p)return this.state=h.failState,p;if(null==(o=r)?void 0:o.thrown)throw r.error;if(h.thrown)throw h.error;throw this.raise(i.start,J.UnexpectedTokenAfterTypeParameter)}return super.parseMaybeAssign(t,e,s)}parseArrow(t){if(this.match(l.colon)){const e=this.tryParse((()=>{const e=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0;const s=this.startNode();return[s.typeAnnotation,t.predicate]=this.flowParseTypeAndPredicateInitialiser(),this.state.noAnonFunctionType=e,this.canInsertSemicolon()&&this.unexpected(),this.match(l.arrow)||this.unexpected(),s}));if(e.thrown)return null;e.error&&(this.state=e.failState),t.returnType=e.node.typeAnnotation?this.finishNode(e.node,\"TypeAnnotation\"):null}return super.parseArrow(t)}shouldParseArrow(){return this.match(l.colon)||super.shouldParseArrow()}setArrowFunctionParameters(t,e){-1!==this.state.noArrowParamsConversionAt.indexOf(t.start)?t.params=e:super.setArrowFunctionParameters(t,e)}checkParams(t,e,s){if(!s||-1===this.state.noArrowParamsConversionAt.indexOf(t.start))return super.checkParams(...arguments)}parseParenAndDistinguishExpression(t){return super.parseParenAndDistinguishExpression(t&&-1===this.state.noArrowAt.indexOf(this.state.start))}parseSubscripts(t,e,s,i){if(\"Identifier\"===t.type&&\"async\"===t.name&&-1!==this.state.noArrowAt.indexOf(e)){this.next();const i=this.startNodeAt(e,s);i.callee=t,i.arguments=this.parseCallExpressionArguments(l.parenR,!1),t=this.finishNode(i,\"CallExpression\")}else if(\"Identifier\"===t.type&&\"async\"===t.name&&this.isRelational(\"<\")){const r=this.state.clone(),a=this.tryParse((t=>this.parseAsyncArrowWithTypeParameters(e,s)||t()),r);if(!a.error&&!a.aborted)return a.node;const n=this.tryParse((()=>super.parseSubscripts(t,e,s,i)),r);if(n.node&&!n.error)return n.node;if(a.node)return this.state=a.failState,a.node;if(n.node)return this.state=n.failState,n.node;throw a.error||n.error}return super.parseSubscripts(t,e,s,i)}parseSubscript(t,e,s,i,r){if(this.match(l.questionDot)&&this.isLookaheadToken_lt()){if(r.optionalChainMember=!0,i)return r.stop=!0,t;this.next();const a=this.startNodeAt(e,s);return a.callee=t,a.typeArguments=this.flowParseTypeParameterInstantiation(),this.expect(l.parenL),a.arguments=this.parseCallExpressionArguments(l.parenR,!1),a.optional=!0,this.finishCallExpression(a,!0)}if(!i&&this.shouldParseTypes()&&this.isRelational(\"<\")){const i=this.startNodeAt(e,s);i.callee=t;const a=this.tryParse((()=>(i.typeArguments=this.flowParseTypeParameterInstantiationCallOrNew(),this.expect(l.parenL),i.arguments=this.parseCallExpressionArguments(l.parenR,!1),r.optionalChainMember&&(i.optional=!1),this.finishCallExpression(i,r.optionalChainMember))));if(a.node)return a.error&&(this.state=a.failState),a.node}return super.parseSubscript(t,e,s,i,r)}parseNewArguments(t){let e=null;this.shouldParseTypes()&&this.isRelational(\"<\")&&(e=this.tryParse((()=>this.flowParseTypeParameterInstantiationCallOrNew())).node),t.typeArguments=e,super.parseNewArguments(t)}parseAsyncArrowWithTypeParameters(t,e){const s=this.startNodeAt(t,e);if(this.parseFunctionParams(s),this.parseArrow(s))return this.parseArrowExpression(s,void 0,!0)}readToken_mult_modulo(t){const e=this.input.charCodeAt(this.state.pos+1);if(42===t&&47===e&&this.state.hasFlowComment)return this.state.hasFlowComment=!1,this.state.pos+=2,void this.nextToken();super.readToken_mult_modulo(t)}readToken_pipe_amp(t){const e=this.input.charCodeAt(this.state.pos+1);124!==t||125!==e?super.readToken_pipe_amp(t):this.finishOp(l.braceBarR,2)}parseTopLevel(t,e){const s=super.parseTopLevel(t,e);return this.state.hasFlowComment&&this.raise(this.state.pos,J.UnterminatedFlowComment),s}skipBlockComment(){if(this.hasPlugin(\"flowComments\")&&this.skipFlowComment())return this.state.hasFlowComment&&this.unexpected(null,J.NestedFlowComment),this.hasFlowCommentCompletion(),this.state.pos+=this.skipFlowComment(),void(this.state.hasFlowComment=!0);if(this.state.hasFlowComment){const t=this.input.indexOf(\"*-/\",this.state.pos+=2);if(-1===t)throw this.raise(this.state.pos-2,b.UnterminatedComment);this.state.pos=t+3}else super.skipBlockComment()}skipFlowComment(){const{pos:t}=this.state;let e=2;for(;[32,9].includes(this.input.charCodeAt(t+e));)e++;const s=this.input.charCodeAt(e+t),i=this.input.charCodeAt(e+t+1);return 58===s&&58===i?e+2:\"flow-include\"===this.input.slice(e+t,e+t+12)?e+12:58===s&&58!==i&&e}hasFlowCommentCompletion(){if(-1===this.input.indexOf(\"*/\",this.state.pos))throw this.raise(this.state.pos,b.UnterminatedComment)}flowEnumErrorBooleanMemberNotInitialized(t,{enumName:e,memberName:s}){this.raise(t,J.EnumBooleanMemberNotInitialized,s,e)}flowEnumErrorInvalidMemberName(t,{enumName:e,memberName:s}){const i=s[0].toUpperCase()+s.slice(1);this.raise(t,J.EnumInvalidMemberName,s,i,e)}flowEnumErrorDuplicateMemberName(t,{enumName:e,memberName:s}){this.raise(t,J.EnumDuplicateMemberName,s,e)}flowEnumErrorInconsistentMemberValues(t,{enumName:e}){this.raise(t,J.EnumInconsistentMemberValues,e)}flowEnumErrorInvalidExplicitType(t,{enumName:e,suppliedType:s}){return this.raise(t,null===s?J.EnumInvalidExplicitTypeUnknownSupplied:J.EnumInvalidExplicitType,e,s)}flowEnumErrorInvalidMemberInitializer(t,{enumName:e,explicitType:s,memberName:i}){let r=null;switch(s){case\"boolean\":case\"number\":case\"string\":r=J.EnumInvalidMemberInitializerPrimaryType;break;case\"symbol\":r=J.EnumInvalidMemberInitializerSymbolType;break;default:r=J.EnumInvalidMemberInitializerUnknownType}return this.raise(t,r,e,i,s)}flowEnumErrorNumberMemberNotInitialized(t,{enumName:e,memberName:s}){this.raise(t,J.EnumNumberMemberNotInitialized,e,s)}flowEnumErrorStringMemberInconsistentlyInitailized(t,{enumName:e}){this.raise(t,J.EnumStringMemberInconsistentlyInitailized,e)}flowEnumMemberInit(){const t=this.state.start,e=()=>this.match(l.comma)||this.match(l.braceR);switch(this.state.type){case l.num:{const s=this.parseLiteral(this.state.value,\"NumericLiteral\");return e()?{type:\"number\",pos:s.start,value:s}:{type:\"invalid\",pos:t}}case l.string:{const s=this.parseLiteral(this.state.value,\"StringLiteral\");return e()?{type:\"string\",pos:s.start,value:s}:{type:\"invalid\",pos:t}}case l._true:case l._false:{const s=this.parseBooleanLiteral();return e()?{type:\"boolean\",pos:s.start,value:s}:{type:\"invalid\",pos:t}}default:return{type:\"invalid\",pos:t}}}flowEnumMemberRaw(){const t=this.state.start;return{id:this.parseIdentifier(!0),init:this.eat(l.eq)?this.flowEnumMemberInit():{type:\"none\",pos:t}}}flowEnumCheckExplicitTypeMismatch(t,e,s){const{explicitType:i}=e;null!==i&&i!==s&&this.flowEnumErrorInvalidMemberInitializer(t,e)}flowEnumMembers({enumName:t,explicitType:e}){const s=new Set,i={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]};for(;!this.match(l.braceR);){const r=this.startNode(),{id:a,init:n}=this.flowEnumMemberRaw(),o=a.name;if(\"\"===o)continue;/^[a-z]/.test(o)&&this.flowEnumErrorInvalidMemberName(a.start,{enumName:t,memberName:o}),s.has(o)&&this.flowEnumErrorDuplicateMemberName(a.start,{enumName:t,memberName:o}),s.add(o);const h={enumName:t,explicitType:e,memberName:o};switch(r.id=a,n.type){case\"boolean\":this.flowEnumCheckExplicitTypeMismatch(n.pos,h,\"boolean\"),r.init=n.value,i.booleanMembers.push(this.finishNode(r,\"EnumBooleanMember\"));break;case\"number\":this.flowEnumCheckExplicitTypeMismatch(n.pos,h,\"number\"),r.init=n.value,i.numberMembers.push(this.finishNode(r,\"EnumNumberMember\"));break;case\"string\":this.flowEnumCheckExplicitTypeMismatch(n.pos,h,\"string\"),r.init=n.value,i.stringMembers.push(this.finishNode(r,\"EnumStringMember\"));break;case\"invalid\":throw this.flowEnumErrorInvalidMemberInitializer(n.pos,h);case\"none\":switch(e){case\"boolean\":this.flowEnumErrorBooleanMemberNotInitialized(n.pos,h);break;case\"number\":this.flowEnumErrorNumberMemberNotInitialized(n.pos,h);break;default:i.defaultedMembers.push(this.finishNode(r,\"EnumDefaultedMember\"))}}this.match(l.braceR)||this.expect(l.comma)}return i}flowEnumStringMembers(t,e,{enumName:s}){if(0===t.length)return e;if(0===e.length)return t;if(e.length>t.length){for(let e=0;e<t.length;e++){const i=t[e];this.flowEnumErrorStringMemberInconsistentlyInitailized(i.start,{enumName:s})}return e}for(let i=0;i<e.length;i++){const t=e[i];this.flowEnumErrorStringMemberInconsistentlyInitailized(t.start,{enumName:s})}return t}flowEnumParseExplicitType({enumName:t}){if(this.eatContextual(\"of\")){if(!this.match(l.name))throw this.flowEnumErrorInvalidExplicitType(this.state.start,{enumName:t,suppliedType:null});const{value:e}=this.state;return this.next(),\"boolean\"!==e&&\"number\"!==e&&\"string\"!==e&&\"symbol\"!==e&&this.flowEnumErrorInvalidExplicitType(this.state.start,{enumName:t,suppliedType:e}),e}return null}flowEnumBody(t,{enumName:e,nameLoc:s}){const i=this.flowEnumParseExplicitType({enumName:e});this.expect(l.braceL);const r=this.flowEnumMembers({enumName:e,explicitType:i});switch(i){case\"boolean\":return t.explicitType=!0,t.members=r.booleanMembers,this.expect(l.braceR),this.finishNode(t,\"EnumBooleanBody\");case\"number\":return t.explicitType=!0,t.members=r.numberMembers,this.expect(l.braceR),this.finishNode(t,\"EnumNumberBody\");case\"string\":return t.explicitType=!0,t.members=this.flowEnumStringMembers(r.stringMembers,r.defaultedMembers,{enumName:e}),this.expect(l.braceR),this.finishNode(t,\"EnumStringBody\");case\"symbol\":return t.members=r.defaultedMembers,this.expect(l.braceR),this.finishNode(t,\"EnumSymbolBody\");default:{const i=()=>(t.members=[],this.expect(l.braceR),this.finishNode(t,\"EnumStringBody\"));t.explicitType=!1;const a=r.booleanMembers.length,n=r.numberMembers.length,o=r.stringMembers.length,h=r.defaultedMembers.length;if(a||n||o||h){if(a||n){if(!n&&!o&&a>=h){for(let t=0,s=r.defaultedMembers;t<s.length;t++){const i=s[t];this.flowEnumErrorBooleanMemberNotInitialized(i.start,{enumName:e,memberName:i.id.name})}return t.members=r.booleanMembers,this.expect(l.braceR),this.finishNode(t,\"EnumBooleanBody\")}if(!a&&!o&&n>=h){for(let t=0,s=r.defaultedMembers;t<s.length;t++){const i=s[t];this.flowEnumErrorNumberMemberNotInitialized(i.start,{enumName:e,memberName:i.id.name})}return t.members=r.numberMembers,this.expect(l.braceR),this.finishNode(t,\"EnumNumberBody\")}return this.flowEnumErrorInconsistentMemberValues(s,{enumName:e}),i()}return t.members=this.flowEnumStringMembers(r.stringMembers,r.defaultedMembers,{enumName:e}),this.expect(l.braceR),this.finishNode(t,\"EnumStringBody\")}return i()}}}flowParseEnumDeclaration(t){const e=this.parseIdentifier();return t.id=e,t.body=this.flowEnumBody(this.startNode(),{enumName:e.name,nameLoc:e.start}),this.finishNode(t,\"EnumDeclaration\")}updateContext(t){this.match(l.name)&&\"of\"===this.state.value&&t===l.name&&\"interface\"===this.input.slice(this.state.lastTokStart,this.state.lastTokEnd)?this.state.exprAllowed=!1:super.updateContext(t)}isLookaheadToken_lt(){const t=this.nextTokenStart();if(60===this.input.charCodeAt(t)){const e=this.input.charCodeAt(t+1);return 60!==e&&61!==e}return!1}maybeUnwrapTypeCastExpression(t){return\"TypeCastExpression\"===t.type?t.expression:t}},typescript:t=>class extends t{getScopeHandler(){return ot}tsIsIdentifier(){return this.match(l.name)}tsNextTokenCanFollowModifier(){return this.next(),(this.match(l.bracketL)||this.match(l.braceL)||this.match(l.star)||this.match(l.ellipsis)||this.match(l.hash)||this.isLiteralPropertyName())&&!this.hasPrecedingLineBreak()}tsParseModifier(t){if(!this.match(l.name))return;const e=this.state.value;return-1!==t.indexOf(e)&&this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))?e:void 0}tsParseModifiers(t,e){for(;;){const s=this.state.start,i=this.tsParseModifier(e);if(!i)break;Object.hasOwnProperty.call(t,i)&&this.raise(s,ut.DuplicateModifier,i),t[i]=!0}}tsIsListTerminator(t){switch(t){case\"EnumMembers\":case\"TypeMembers\":return this.match(l.braceR);case\"HeritageClauseElement\":return this.match(l.braceL);case\"TupleElementTypes\":return this.match(l.bracketR);case\"TypeParametersOrArguments\":return this.isRelational(\">\")}throw new Error(\"Unreachable\")}tsParseList(t,e){const s=[];for(;!this.tsIsListTerminator(t);)s.push(e());return s}tsParseDelimitedList(t,e){return ct(this.tsParseDelimitedListWorker(t,e,!0))}tsParseDelimitedListWorker(t,e,s){const i=[];for(;!this.tsIsListTerminator(t);){const r=e();if(null==r)return;if(i.push(r),!this.eat(l.comma)){if(this.tsIsListTerminator(t))break;return void(s&&this.expect(l.comma))}}return i}tsParseBracketedList(t,e,s,i){i||(s?this.expect(l.bracketL):this.expectRelational(\"<\"));const r=this.tsParseDelimitedList(t,e);return s?this.expect(l.bracketR):this.expectRelational(\">\"),r}tsParseImportType(){const t=this.startNode();return this.expect(l._import),this.expect(l.parenL),this.match(l.string)||this.raise(this.state.start,ut.UnsupportedImportTypeArgument),t.argument=this.parseExprAtom(),this.expect(l.parenR),this.eat(l.dot)&&(t.qualifier=this.tsParseEntityName(!0)),this.isRelational(\"<\")&&(t.typeParameters=this.tsParseTypeArguments()),this.finishNode(t,\"TSImportType\")}tsParseEntityName(t){let e=this.parseIdentifier();for(;this.eat(l.dot);){const s=this.startNodeAtNode(e);s.left=e,s.right=this.parseIdentifier(t),e=this.finishNode(s,\"TSQualifiedName\")}return e}tsParseTypeReference(){const t=this.startNode();return t.typeName=this.tsParseEntityName(!1),!this.hasPrecedingLineBreak()&&this.isRelational(\"<\")&&(t.typeParameters=this.tsParseTypeArguments()),this.finishNode(t,\"TSTypeReference\")}tsParseThisTypePredicate(t){this.next();const e=this.startNodeAtNode(t);return e.parameterName=t,e.typeAnnotation=this.tsParseTypeAnnotation(!1),e.asserts=!1,this.finishNode(e,\"TSTypePredicate\")}tsParseThisTypeNode(){const t=this.startNode();return this.next(),this.finishNode(t,\"TSThisType\")}tsParseTypeQuery(){const t=this.startNode();return this.expect(l._typeof),this.match(l._import)?t.exprName=this.tsParseImportType():t.exprName=this.tsParseEntityName(!0),this.finishNode(t,\"TSTypeQuery\")}tsParseTypeParameter(){const t=this.startNode();return t.name=this.parseIdentifierName(t.start),t.constraint=this.tsEatThenParseType(l._extends),t.default=this.tsEatThenParseType(l.eq),this.finishNode(t,\"TSTypeParameter\")}tsTryParseTypeParameters(){if(this.isRelational(\"<\"))return this.tsParseTypeParameters()}tsParseTypeParameters(){const t=this.startNode();return this.isRelational(\"<\")||this.match(l.jsxTagStart)?this.next():this.unexpected(),t.params=this.tsParseBracketedList(\"TypeParametersOrArguments\",this.tsParseTypeParameter.bind(this),!1,!0),0===t.params.length&&this.raise(t.start,ut.EmptyTypeParameters),this.finishNode(t,\"TSTypeParameterDeclaration\")}tsTryNextParseConstantContext(){return this.lookahead().type===l._const?(this.next(),this.tsParseTypeReference()):null}tsFillSignature(t,e){const s=t===l.arrow;e.typeParameters=this.tsTryParseTypeParameters(),this.expect(l.parenL),e.parameters=this.tsParseBindingListForSignature(),(s||this.match(t))&&(e.typeAnnotation=this.tsParseTypeOrTypePredicateAnnotation(t))}tsParseBindingListForSignature(){return this.parseBindingList(l.parenR,41).map((t=>(\"Identifier\"!==t.type&&\"RestElement\"!==t.type&&\"ObjectPattern\"!==t.type&&\"ArrayPattern\"!==t.type&&this.raise(t.start,ut.UnsupportedSignatureParameterKind,t.type),t)))}tsParseTypeMemberSemicolon(){this.eat(l.comma)||this.semicolon()}tsParseSignatureMember(t,e){return this.tsFillSignature(l.colon,e),this.tsParseTypeMemberSemicolon(),this.finishNode(e,t)}tsIsUnambiguouslyIndexSignature(){return this.next(),this.eat(l.name)&&this.match(l.colon)}tsTryParseIndexSignature(t){if(!this.match(l.bracketL)||!this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))return;this.expect(l.bracketL);const e=this.parseIdentifier();e.typeAnnotation=this.tsParseTypeAnnotation(),this.resetEndLocation(e),this.expect(l.bracketR),t.parameters=[e];const s=this.tsTryParseTypeAnnotation();return s&&(t.typeAnnotation=s),this.tsParseTypeMemberSemicolon(),this.finishNode(t,\"TSIndexSignature\")}tsParsePropertyOrMethodSignature(t,e){this.eat(l.question)&&(t.optional=!0);const s=t;if(e||!this.match(l.parenL)&&!this.isRelational(\"<\")){const t=s;e&&(t.readonly=!0);const i=this.tsTryParseTypeAnnotation();return i&&(t.typeAnnotation=i),this.tsParseTypeMemberSemicolon(),this.finishNode(t,\"TSPropertySignature\")}{const t=s;return this.tsFillSignature(l.colon,t),this.tsParseTypeMemberSemicolon(),this.finishNode(t,\"TSMethodSignature\")}}tsParseTypeMember(){const t=this.startNode();if(this.match(l.parenL)||this.isRelational(\"<\"))return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\",t);if(this.match(l._new)){const e=this.startNode();return this.next(),this.match(l.parenL)||this.isRelational(\"<\")?this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\",t):(t.key=this.createIdentifier(e,\"new\"),this.tsParsePropertyOrMethodSignature(t,!1))}const e=!!this.tsParseModifier([\"readonly\"]),s=this.tsTryParseIndexSignature(t);return s?(e&&(t.readonly=!0),s):(this.parsePropertyName(t,!1),this.tsParsePropertyOrMethodSignature(t,e))}tsParseTypeLiteral(){const t=this.startNode();return t.members=this.tsParseObjectTypeMembers(),this.finishNode(t,\"TSTypeLiteral\")}tsParseObjectTypeMembers(){this.expect(l.braceL);const t=this.tsParseList(\"TypeMembers\",this.tsParseTypeMember.bind(this));return this.expect(l.braceR),t}tsIsStartOfMappedType(){return this.next(),this.eat(l.plusMin)?this.isContextual(\"readonly\"):(this.isContextual(\"readonly\")&&this.next(),!!this.match(l.bracketL)&&(this.next(),!!this.tsIsIdentifier()&&(this.next(),this.match(l._in))))}tsParseMappedTypeParameter(){const t=this.startNode();return t.name=this.parseIdentifierName(t.start),t.constraint=this.tsExpectThenParseType(l._in),this.finishNode(t,\"TSTypeParameter\")}tsParseMappedType(){const t=this.startNode();return this.expect(l.braceL),this.match(l.plusMin)?(t.readonly=this.state.value,this.next(),this.expectContextual(\"readonly\")):this.eatContextual(\"readonly\")&&(t.readonly=!0),this.expect(l.bracketL),t.typeParameter=this.tsParseMappedTypeParameter(),t.nameType=this.eatContextual(\"as\")?this.tsParseType():null,this.expect(l.bracketR),this.match(l.plusMin)?(t.optional=this.state.value,this.next(),this.expect(l.question)):this.eat(l.question)&&(t.optional=!0),t.typeAnnotation=this.tsTryParseType(),this.semicolon(),this.expect(l.braceR),this.finishNode(t,\"TSMappedType\")}tsParseTupleType(){const t=this.startNode();t.elementTypes=this.tsParseBracketedList(\"TupleElementTypes\",this.tsParseTupleElementType.bind(this),!0,!1);let e=!1,s=null;return t.elementTypes.forEach((t=>{var i;let{type:r}=t;!e||\"TSRestType\"===r||\"TSOptionalType\"===r||\"TSNamedTupleMember\"===r&&t.optional||this.raise(t.start,ut.OptionalTypeBeforeRequired),e=e||\"TSNamedTupleMember\"===r&&t.optional||\"TSOptionalType\"===r,\"TSRestType\"===r&&(r=(t=t.typeAnnotation).type);const a=\"TSNamedTupleMember\"===r;s=null!=(i=s)?i:a,s!==a&&this.raise(t.start,ut.MixedLabeledAndUnlabeledElements)})),this.finishNode(t,\"TSTupleType\")}tsParseTupleElementType(){const{start:t,startLoc:e}=this.state,s=this.eat(l.ellipsis);let i=this.tsParseType();const r=this.eat(l.question);if(this.eat(l.colon)){const t=this.startNodeAtNode(i);t.optional=r,\"TSTypeReference\"!==i.type||i.typeParameters||\"Identifier\"!==i.typeName.type?(this.raise(i.start,ut.InvalidTupleMemberLabel),t.label=i):t.label=i.typeName,t.elementType=this.tsParseType(),i=this.finishNode(t,\"TSNamedTupleMember\")}else if(r){const t=this.startNodeAtNode(i);t.typeAnnotation=i,i=this.finishNode(t,\"TSOptionalType\")}if(s){const s=this.startNodeAt(t,e);s.typeAnnotation=i,i=this.finishNode(s,\"TSRestType\")}return i}tsParseParenthesizedType(){const t=this.startNode();return this.expect(l.parenL),t.typeAnnotation=this.tsParseType(),this.expect(l.parenR),this.finishNode(t,\"TSParenthesizedType\")}tsParseFunctionOrConstructorType(t){const e=this.startNode();return\"TSConstructorType\"===t&&this.expect(l._new),this.tsFillSignature(l.arrow,e),this.finishNode(e,t)}tsParseLiteralTypeNode(){const t=this.startNode();return t.literal=(()=>{switch(this.state.type){case l.num:case l.bigint:case l.string:case l._true:case l._false:return this.parseExprAtom();default:throw this.unexpected()}})(),this.finishNode(t,\"TSLiteralType\")}tsParseTemplateLiteralType(){const t=this.startNode();return t.literal=this.parseTemplate(!1),this.finishNode(t,\"TSLiteralType\")}parseTemplateSubstitution(){return this.state.inType?this.tsParseType():super.parseTemplateSubstitution()}tsParseThisTypeOrThisTypePredicate(){const t=this.tsParseThisTypeNode();return this.isContextual(\"is\")&&!this.hasPrecedingLineBreak()?this.tsParseThisTypePredicate(t):t}tsParseNonArrayType(){switch(this.state.type){case l.name:case l._void:case l._null:{const t=this.match(l._void)?\"TSVoidKeyword\":this.match(l._null)?\"TSNullKeyword\":function(t){switch(t){case\"any\":return\"TSAnyKeyword\";case\"boolean\":return\"TSBooleanKeyword\";case\"bigint\":return\"TSBigIntKeyword\";case\"never\":return\"TSNeverKeyword\";case\"number\":return\"TSNumberKeyword\";case\"object\":return\"TSObjectKeyword\";case\"string\":return\"TSStringKeyword\";case\"symbol\":return\"TSSymbolKeyword\";case\"undefined\":return\"TSUndefinedKeyword\";case\"unknown\":return\"TSUnknownKeyword\";default:return}}(this.state.value);if(void 0!==t&&46!==this.lookaheadCharCode()){const e=this.startNode();return this.next(),this.finishNode(e,t)}return this.tsParseTypeReference()}case l.string:case l.num:case l.bigint:case l._true:case l._false:return this.tsParseLiteralTypeNode();case l.plusMin:if(\"-\"===this.state.value){const t=this.startNode(),e=this.lookahead();if(e.type!==l.num&&e.type!==l.bigint)throw this.unexpected();return t.literal=this.parseMaybeUnary(),this.finishNode(t,\"TSLiteralType\")}break;case l._this:return this.tsParseThisTypeOrThisTypePredicate();case l._typeof:return this.tsParseTypeQuery();case l._import:return this.tsParseImportType();case l.braceL:return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))?this.tsParseMappedType():this.tsParseTypeLiteral();case l.bracketL:return this.tsParseTupleType();case l.parenL:return this.tsParseParenthesizedType();case l.backQuote:return this.tsParseTemplateLiteralType()}throw this.unexpected()}tsParseArrayTypeOrHigher(){let t=this.tsParseNonArrayType();for(;!this.hasPrecedingLineBreak()&&this.eat(l.bracketL);)if(this.match(l.bracketR)){const e=this.startNodeAtNode(t);e.elementType=t,this.expect(l.bracketR),t=this.finishNode(e,\"TSArrayType\")}else{const e=this.startNodeAtNode(t);e.objectType=t,e.indexType=this.tsParseType(),this.expect(l.bracketR),t=this.finishNode(e,\"TSIndexedAccessType\")}return t}tsParseTypeOperator(t){const e=this.startNode();return this.expectContextual(t),e.operator=t,e.typeAnnotation=this.tsParseTypeOperatorOrHigher(),\"readonly\"===t&&this.tsCheckTypeAnnotationForReadOnly(e),this.finishNode(e,\"TSTypeOperator\")}tsCheckTypeAnnotationForReadOnly(t){switch(t.typeAnnotation.type){case\"TSTupleType\":case\"TSArrayType\":return;default:this.raise(t.start,ut.UnexpectedReadonly)}}tsParseInferType(){const t=this.startNode();this.expectContextual(\"infer\");const e=this.startNode();return e.name=this.parseIdentifierName(e.start),t.typeParameter=this.finishNode(e,\"TSTypeParameter\"),this.finishNode(t,\"TSInferType\")}tsParseTypeOperatorOrHigher(){const t=[\"keyof\",\"unique\",\"readonly\"].find((t=>this.isContextual(t)));return t?this.tsParseTypeOperator(t):this.isContextual(\"infer\")?this.tsParseInferType():this.tsParseArrayTypeOrHigher()}tsParseUnionOrIntersectionType(t,e,s){this.eat(s);let i=e();if(this.match(s)){const r=[i];for(;this.eat(s);)r.push(e());const a=this.startNodeAtNode(i);a.types=r,i=this.finishNode(a,t)}return i}tsParseIntersectionTypeOrHigher(){return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\",this.tsParseTypeOperatorOrHigher.bind(this),l.bitwiseAND)}tsParseUnionTypeOrHigher(){return this.tsParseUnionOrIntersectionType(\"TSUnionType\",this.tsParseIntersectionTypeOrHigher.bind(this),l.bitwiseOR)}tsIsStartOfFunctionType(){return!!this.isRelational(\"<\")||this.match(l.parenL)&&this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))}tsSkipParameterStart(){if(this.match(l.name)||this.match(l._this))return this.next(),!0;if(this.match(l.braceL)){let t=1;for(this.next();t>0;)this.match(l.braceL)?++t:this.match(l.braceR)&&--t,this.next();return!0}if(this.match(l.bracketL)){let t=1;for(this.next();t>0;)this.match(l.bracketL)?++t:this.match(l.bracketR)&&--t,this.next();return!0}return!1}tsIsUnambiguouslyStartOfFunctionType(){if(this.next(),this.match(l.parenR)||this.match(l.ellipsis))return!0;if(this.tsSkipParameterStart()){if(this.match(l.colon)||this.match(l.comma)||this.match(l.question)||this.match(l.eq))return!0;if(this.match(l.parenR)&&(this.next(),this.match(l.arrow)))return!0}return!1}tsParseTypeOrTypePredicateAnnotation(t){return this.tsInType((()=>{const e=this.startNode();this.expect(t);const s=!!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));if(s&&this.match(l._this)){let t=this.tsParseThisTypeOrThisTypePredicate();if(\"TSThisType\"===t.type){const s=this.startNodeAtNode(e);s.parameterName=t,s.asserts=!0,t=this.finishNode(s,\"TSTypePredicate\")}else t.asserts=!0;return e.typeAnnotation=t,this.finishNode(e,\"TSTypeAnnotation\")}const i=this.tsIsIdentifier()&&this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));if(!i){if(!s)return this.tsParseTypeAnnotation(!1,e);const t=this.startNodeAtNode(e);return t.parameterName=this.parseIdentifier(),t.asserts=s,e.typeAnnotation=this.finishNode(t,\"TSTypePredicate\"),this.finishNode(e,\"TSTypeAnnotation\")}const r=this.tsParseTypeAnnotation(!1),a=this.startNodeAtNode(e);return a.parameterName=i,a.typeAnnotation=r,a.asserts=s,e.typeAnnotation=this.finishNode(a,\"TSTypePredicate\"),this.finishNode(e,\"TSTypeAnnotation\")}))}tsTryParseTypeOrTypePredicateAnnotation(){return this.match(l.colon)?this.tsParseTypeOrTypePredicateAnnotation(l.colon):void 0}tsTryParseTypeAnnotation(){return this.match(l.colon)?this.tsParseTypeAnnotation():void 0}tsTryParseType(){return this.tsEatThenParseType(l.colon)}tsParseTypePredicatePrefix(){const t=this.parseIdentifier();if(this.isContextual(\"is\")&&!this.hasPrecedingLineBreak())return this.next(),t}tsParseTypePredicateAsserts(){if(!this.match(l.name)||\"asserts\"!==this.state.value||this.hasPrecedingLineBreak())return!1;const t=this.state.containsEsc;return this.next(),!(!this.match(l.name)&&!this.match(l._this))&&(t&&this.raise(this.state.lastTokStart,b.InvalidEscapedReservedWord,\"asserts\"),!0)}tsParseTypeAnnotation(t=!0,e=this.startNode()){return this.tsInType((()=>{t&&this.expect(l.colon),e.typeAnnotation=this.tsParseType()})),this.finishNode(e,\"TSTypeAnnotation\")}tsParseType(){lt(this.state.inType);const t=this.tsParseNonConditionalType();if(this.hasPrecedingLineBreak()||!this.eat(l._extends))return t;const e=this.startNodeAtNode(t);return e.checkType=t,e.extendsType=this.tsParseNonConditionalType(),this.expect(l.question),e.trueType=this.tsParseType(),this.expect(l.colon),e.falseType=this.tsParseType(),this.finishNode(e,\"TSConditionalType\")}tsParseNonConditionalType(){return this.tsIsStartOfFunctionType()?this.tsParseFunctionOrConstructorType(\"TSFunctionType\"):this.match(l._new)?this.tsParseFunctionOrConstructorType(\"TSConstructorType\"):this.tsParseUnionTypeOrHigher()}tsParseTypeAssertion(){const t=this.startNode(),e=this.tsTryNextParseConstantContext();return t.typeAnnotation=e||this.tsNextThenParseType(),this.expectRelational(\">\"),t.expression=this.parseMaybeUnary(),this.finishNode(t,\"TSTypeAssertion\")}tsParseHeritageClause(t){const e=this.state.start,s=this.tsParseDelimitedList(\"HeritageClauseElement\",this.tsParseExpressionWithTypeArguments.bind(this));return s.length||this.raise(e,ut.EmptyHeritageClauseType,t),s}tsParseExpressionWithTypeArguments(){const t=this.startNode();return t.expression=this.tsParseEntityName(!1),this.isRelational(\"<\")&&(t.typeParameters=this.tsParseTypeArguments()),this.finishNode(t,\"TSExpressionWithTypeArguments\")}tsParseInterfaceDeclaration(t){t.id=this.parseIdentifier(),this.checkLVal(t.id,\"typescript interface declaration\",130),t.typeParameters=this.tsTryParseTypeParameters(),this.eat(l._extends)&&(t.extends=this.tsParseHeritageClause(\"extends\"));const e=this.startNode();return e.body=this.tsInType(this.tsParseObjectTypeMembers.bind(this)),t.body=this.finishNode(e,\"TSInterfaceBody\"),this.finishNode(t,\"TSInterfaceDeclaration\")}tsParseTypeAliasDeclaration(t){return t.id=this.parseIdentifier(),this.checkLVal(t.id,\"typescript type alias\",2),t.typeParameters=this.tsTryParseTypeParameters(),t.typeAnnotation=this.tsInType((()=>{if(this.expect(l.eq),this.isContextual(\"intrinsic\")&&this.lookahead().type!==l.dot){const t=this.startNode();return this.next(),this.finishNode(t,\"TSIntrinsicKeyword\")}return this.tsParseType()})),this.semicolon(),this.finishNode(t,\"TSTypeAliasDeclaration\")}tsInNoContext(t){const e=this.state.context;this.state.context=[e[0]];try{return t()}finally{this.state.context=e}}tsInType(t){const e=this.state.inType;this.state.inType=!0;try{return t()}finally{this.state.inType=e}}tsEatThenParseType(t){return this.match(t)?this.tsNextThenParseType():void 0}tsExpectThenParseType(t){return this.tsDoThenParseType((()=>this.expect(t)))}tsNextThenParseType(){return this.tsDoThenParseType((()=>this.next()))}tsDoThenParseType(t){return this.tsInType((()=>(t(),this.tsParseType())))}tsParseEnumMember(){const t=this.startNode();return t.id=this.match(l.string)?this.parseExprAtom():this.parseIdentifier(!0),this.eat(l.eq)&&(t.initializer=this.parseMaybeAssignAllowIn()),this.finishNode(t,\"TSEnumMember\")}tsParseEnumDeclaration(t,e){return e&&(t.const=!0),t.id=this.parseIdentifier(),this.checkLVal(t.id,\"typescript enum declaration\",e?779:267),this.expect(l.braceL),t.members=this.tsParseDelimitedList(\"EnumMembers\",this.tsParseEnumMember.bind(this)),this.expect(l.braceR),this.finishNode(t,\"TSEnumDeclaration\")}tsParseModuleBlock(){const t=this.startNode();return this.scope.enter(0),this.expect(l.braceL),this.parseBlockOrModuleBlockBody(t.body=[],void 0,!0,l.braceR),this.scope.exit(),this.finishNode(t,\"TSModuleBlock\")}tsParseModuleOrNamespaceDeclaration(t,e=!1){if(t.id=this.parseIdentifier(),e||this.checkLVal(t.id,\"module or namespace declaration\",1024),this.eat(l.dot)){const e=this.startNode();this.tsParseModuleOrNamespaceDeclaration(e,!0),t.body=e}else this.scope.enter(z),this.prodParam.enter(0),t.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit();return this.finishNode(t,\"TSModuleDeclaration\")}tsParseAmbientExternalModuleDeclaration(t){return this.isContextual(\"global\")?(t.global=!0,t.id=this.parseIdentifier()):this.match(l.string)?t.id=this.parseExprAtom():this.unexpected(),this.match(l.braceL)?(this.scope.enter(z),this.prodParam.enter(0),t.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit()):this.semicolon(),this.finishNode(t,\"TSModuleDeclaration\")}tsParseImportEqualsDeclaration(t,e){return t.isExport=e||!1,t.id=this.parseIdentifier(),this.checkLVal(t.id,\"import equals declaration\",9),this.expect(l.eq),t.moduleReference=this.tsParseModuleReference(),this.semicolon(),this.finishNode(t,\"TSImportEqualsDeclaration\")}tsIsExternalModuleReference(){return this.isContextual(\"require\")&&40===this.lookaheadCharCode()}tsParseModuleReference(){return this.tsIsExternalModuleReference()?this.tsParseExternalModuleReference():this.tsParseEntityName(!1)}tsParseExternalModuleReference(){const t=this.startNode();if(this.expectContextual(\"require\"),this.expect(l.parenL),!this.match(l.string))throw this.unexpected();return t.expression=this.parseExprAtom(),this.expect(l.parenR),this.finishNode(t,\"TSExternalModuleReference\")}tsLookAhead(t){const e=this.state.clone(),s=t();return this.state=e,s}tsTryParseAndCatch(t){const e=this.tryParse((e=>t()||e()));if(!e.aborted&&e.node)return e.error&&(this.state=e.failState),e.node}tsTryParse(t){const e=this.state.clone(),s=t();return void 0!==s&&!1!==s?s:void(this.state=e)}tsTryParseDeclare(t){if(this.isLineTerminator())return;let e,s=this.state.type;return this.isContextual(\"let\")&&(s=l._var,e=\"let\"),this.tsInDeclareContext((()=>{switch(s){case l._function:return t.declare=!0,this.parseFunctionStatement(t,!1,!0);case l._class:return t.declare=!0,this.parseClass(t,!0,!1);case l._const:if(this.match(l._const)&&this.isLookaheadContextual(\"enum\"))return this.expect(l._const),this.expectContextual(\"enum\"),this.tsParseEnumDeclaration(t,!0);case l._var:return e=e||this.state.value,this.parseVarStatement(t,e);case l.name:{const e=this.state.value;return\"global\"===e?this.tsParseAmbientExternalModuleDeclaration(t):this.tsParseDeclaration(t,e,!0)}}}))}tsTryParseExportDeclaration(){return this.tsParseDeclaration(this.startNode(),this.state.value,!0)}tsParseExpressionStatement(t,e){switch(e.name){case\"declare\":{const e=this.tsTryParseDeclare(t);if(e)return e.declare=!0,e;break}case\"global\":if(this.match(l.braceL)){this.scope.enter(z),this.prodParam.enter(0);const s=t;return s.global=!0,s.id=e,s.body=this.tsParseModuleBlock(),this.scope.exit(),this.prodParam.exit(),this.finishNode(s,\"TSModuleDeclaration\")}break;default:return this.tsParseDeclaration(t,e.name,!1)}}tsParseDeclaration(t,e,s){switch(e){case\"abstract\":if(this.tsCheckLineTerminatorAndMatch(l._class,s)){const e=t;return e.abstract=!0,s&&(this.next(),this.match(l._class)||this.unexpected(null,l._class)),this.parseClass(e,!0,!1)}break;case\"enum\":if(s||this.match(l.name))return s&&this.next(),this.tsParseEnumDeclaration(t,!1);break;case\"interface\":if(this.tsCheckLineTerminatorAndMatch(l.name,s))return s&&this.next(),this.tsParseInterfaceDeclaration(t);break;case\"module\":if(s&&this.next(),this.match(l.string))return this.tsParseAmbientExternalModuleDeclaration(t);if(this.tsCheckLineTerminatorAndMatch(l.name,s))return this.tsParseModuleOrNamespaceDeclaration(t);break;case\"namespace\":if(this.tsCheckLineTerminatorAndMatch(l.name,s))return s&&this.next(),this.tsParseModuleOrNamespaceDeclaration(t);break;case\"type\":if(this.tsCheckLineTerminatorAndMatch(l.name,s))return s&&this.next(),this.tsParseTypeAliasDeclaration(t)}}tsCheckLineTerminatorAndMatch(t,e){return(e||this.match(t))&&!this.isLineTerminator()}tsTryParseGenericAsyncArrowFunction(t,e){if(!this.isRelational(\"<\"))return;const s=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=!0;const i=this.tsTryParseAndCatch((()=>{const s=this.startNodeAt(t,e);return s.typeParameters=this.tsParseTypeParameters(),super.parseFunctionParams(s),s.returnType=this.tsTryParseTypeOrTypePredicateAnnotation(),this.expect(l.arrow),s}));return this.state.maybeInArrowParameters=s,i?this.parseArrowExpression(i,null,!0):void 0}tsParseTypeArguments(){const t=this.startNode();return t.params=this.tsInType((()=>this.tsInNoContext((()=>(this.expectRelational(\"<\"),this.tsParseDelimitedList(\"TypeParametersOrArguments\",this.tsParseType.bind(this))))))),0===t.params.length&&this.raise(t.start,ut.EmptyTypeArguments),this.state.exprAllowed=!1,this.expectRelational(\">\"),this.finishNode(t,\"TSTypeParameterInstantiation\")}tsIsDeclarationStart(){if(this.match(l.name))switch(this.state.value){case\"abstract\":case\"declare\":case\"enum\":case\"interface\":case\"module\":case\"namespace\":case\"type\":return!0}return!1}isExportDefaultSpecifier(){return!this.tsIsDeclarationStart()&&super.isExportDefaultSpecifier()}parseAssignableListItem(t,e){const s=this.state.start,i=this.state.startLoc;let r,a=!1;void 0!==t&&(r=this.parseAccessModifier(),a=!!this.tsParseModifier([\"readonly\"]),!1===t&&(r||a)&&this.raise(s,ut.UnexpectedParameterModifier));const n=this.parseMaybeDefault();this.parseAssignableListItemTypes(n);const o=this.parseMaybeDefault(n.start,n.loc.start,n);if(r||a){const t=this.startNodeAt(s,i);return e.length&&(t.decorators=e),r&&(t.accessibility=r),a&&(t.readonly=a),\"Identifier\"!==o.type&&\"AssignmentPattern\"!==o.type&&this.raise(t.start,ut.UnsupportedParameterPropertyKind),t.parameter=o,this.finishNode(t,\"TSParameterProperty\")}return e.length&&(n.decorators=e),o}parseFunctionBodyAndFinish(t,e,s=!1){this.match(l.colon)&&(t.returnType=this.tsParseTypeOrTypePredicateAnnotation(l.colon));const i=\"FunctionDeclaration\"===e?\"TSDeclareFunction\":\"ClassMethod\"===e?\"TSDeclareMethod\":void 0;i&&!this.match(l.braceL)&&this.isLineTerminator()?this.finishNode(t,i):\"TSDeclareFunction\"===i&&this.state.isDeclareContext&&(this.raise(t.start,ut.DeclareFunctionHasImplementation),t.declare)?super.parseFunctionBodyAndFinish(t,i,s):super.parseFunctionBodyAndFinish(t,e,s)}registerFunctionStatementId(t){!t.body&&t.id?this.checkLVal(t.id,\"function name\",1024):super.registerFunctionStatementId(...arguments)}tsCheckForInvalidTypeCasts(t){t.forEach((t=>{\"TSTypeCastExpression\"===(null==t?void 0:t.type)&&this.raise(t.typeAnnotation.start,ut.UnexpectedTypeAnnotation)}))}toReferencedList(t,e){return this.tsCheckForInvalidTypeCasts(t),t}parseArrayLike(...t){const e=super.parseArrayLike(...t);return\"ArrayExpression\"===e.type&&this.tsCheckForInvalidTypeCasts(e.elements),e}parseSubscript(t,e,s,i,r){if(!this.hasPrecedingLineBreak()&&this.match(l.bang)){this.state.exprAllowed=!1,this.next();const i=this.startNodeAt(e,s);return i.expression=t,this.finishNode(i,\"TSNonNullExpression\")}if(this.isRelational(\"<\")){const a=this.tsTryParseAndCatch((()=>{if(!i&&this.atPossibleAsyncArrow(t)){const t=this.tsTryParseGenericAsyncArrowFunction(e,s);if(t)return t}const a=this.startNodeAt(e,s);a.callee=t;const n=this.tsParseTypeArguments();if(n){if(!i&&this.eat(l.parenL))return a.arguments=this.parseCallExpressionArguments(l.parenR,!1),this.tsCheckForInvalidTypeCasts(a.arguments),a.typeParameters=n,this.finishCallExpression(a,r.optionalChainMember);if(this.match(l.backQuote)){const i=this.parseTaggedTemplateExpression(t,e,s,r);return i.typeParameters=n,i}}this.unexpected()}));if(a)return a}return super.parseSubscript(t,e,s,i,r)}parseNewArguments(t){if(this.isRelational(\"<\")){const e=this.tsTryParseAndCatch((()=>{const t=this.tsParseTypeArguments();return this.match(l.parenL)||this.unexpected(),t}));e&&(t.typeParameters=e)}super.parseNewArguments(t)}parseExprOp(t,e,s,i){if(ct(l._in.binop)>i&&!this.hasPrecedingLineBreak()&&this.isContextual(\"as\")){const r=this.startNodeAt(e,s);r.expression=t;const a=this.tsTryNextParseConstantContext();return r.typeAnnotation=a||this.tsNextThenParseType(),this.finishNode(r,\"TSAsExpression\"),this.reScan_lt_gt(),this.parseExprOp(r,e,s,i)}return super.parseExprOp(t,e,s,i)}checkReservedWord(t,e,s,i){}checkDuplicateExports(){}parseImport(t){if(this.match(l.name)||this.match(l.star)||this.match(l.braceL)){const e=this.lookahead();if(this.match(l.name)&&e.type===l.eq)return this.tsParseImportEqualsDeclaration(t);!this.isContextual(\"type\")||e.type===l.comma||e.type===l.name&&\"from\"===e.value||(t.importKind=\"type\",this.next())}t.importKind||(t.importKind=\"value\");const e=super.parseImport(t);return\"type\"===e.importKind&&e.specifiers.length>1&&\"ImportDefaultSpecifier\"===e.specifiers[0].type&&this.raise(e.start,\"A type-only import can specify a default import or named bindings, but not both.\"),e}parseExport(t){if(this.match(l._import))return this.expect(l._import),this.tsParseImportEqualsDeclaration(t,!0);if(this.eat(l.eq)){const e=t;return e.expression=this.parseExpression(),this.semicolon(),this.finishNode(e,\"TSExportAssignment\")}if(this.eatContextual(\"as\")){const e=t;return this.expectContextual(\"namespace\"),e.id=this.parseIdentifier(),this.semicolon(),this.finishNode(e,\"TSNamespaceExportDeclaration\")}return this.isContextual(\"type\")&&this.lookahead().type===l.braceL?(this.next(),t.exportKind=\"type\"):t.exportKind=\"value\",super.parseExport(t)}isAbstractClass(){return this.isContextual(\"abstract\")&&this.lookahead().type===l._class}parseExportDefaultExpression(){if(this.isAbstractClass()){const t=this.startNode();return this.next(),this.parseClass(t,!0,!0),t.abstract=!0,t}if(\"interface\"===this.state.value){const t=this.tsParseDeclaration(this.startNode(),this.state.value,!0);if(t)return t}return super.parseExportDefaultExpression()}parseStatementContent(t,e){if(this.state.type===l._const){const t=this.lookahead();if(t.type===l.name&&\"enum\"===t.value){const t=this.startNode();return this.expect(l._const),this.expectContextual(\"enum\"),this.tsParseEnumDeclaration(t,!0)}}return super.parseStatementContent(t,e)}parseAccessModifier(){return this.tsParseModifier([\"public\",\"protected\",\"private\"])}parseClassMember(t,e,s){this.tsParseModifiers(e,[\"declare\"]);const i=this.parseAccessModifier();i&&(e.accessibility=i),this.tsParseModifiers(e,[\"declare\"]);const r=()=>{super.parseClassMember(t,e,s)};e.declare?this.tsInDeclareContext(r):r()}parseClassMemberWithIsStatic(t,e,s,i){this.tsParseModifiers(e,[\"abstract\",\"readonly\",\"declare\"]);const r=this.tsTryParseIndexSignature(e);if(r)return t.body.push(r),e.abstract&&this.raise(e.start,ut.IndexSignatureHasAbstract),i&&this.raise(e.start,ut.IndexSignatureHasStatic),e.accessibility&&this.raise(e.start,ut.IndexSignatureHasAccessibility,e.accessibility),void(e.declare&&this.raise(e.start,ut.IndexSignatureHasDeclare));super.parseClassMemberWithIsStatic(t,e,s,i)}parsePostMemberNameModifiers(t){this.eat(l.question)&&(t.optional=!0),t.readonly&&this.match(l.parenL)&&this.raise(t.start,ut.ClassMethodHasReadonly),t.declare&&this.match(l.parenL)&&this.raise(t.start,ut.ClassMethodHasDeclare)}parseExpressionStatement(t,e){return(\"Identifier\"===e.type?this.tsParseExpressionStatement(t,e):void 0)||super.parseExpressionStatement(t,e)}shouldParseExportDeclaration(){return!!this.tsIsDeclarationStart()||super.shouldParseExportDeclaration()}parseConditional(t,e,s,i){if(!i||!this.match(l.question))return super.parseConditional(t,e,s,i);const r=this.tryParse((()=>super.parseConditional(t,e,s)));return r.node?(r.error&&(this.state=r.failState),r.node):(i.start=r.error.pos||this.state.start,t)}parseParenItem(t,e,s){if(t=super.parseParenItem(t,e,s),this.eat(l.question)&&(t.optional=!0,this.resetEndLocation(t)),this.match(l.colon)){const i=this.startNodeAt(e,s);return i.expression=t,i.typeAnnotation=this.tsParseTypeAnnotation(),this.finishNode(i,\"TSTypeCastExpression\")}return t}parseExportDeclaration(t){const e=this.state.start,s=this.state.startLoc,i=this.eatContextual(\"declare\");let r;return this.match(l.name)&&(r=this.tsTryParseExportDeclaration()),r||(r=super.parseExportDeclaration(t)),r&&(\"TSInterfaceDeclaration\"===r.type||\"TSTypeAliasDeclaration\"===r.type||i)&&(t.exportKind=\"type\"),r&&i&&(this.resetStartLocation(r,e,s),r.declare=!0),r}parseClassId(t,e,s){if((!e||s)&&this.isContextual(\"implements\"))return;super.parseClassId(t,e,s,t.declare?1024:139);const i=this.tsTryParseTypeParameters();i&&(t.typeParameters=i)}parseClassPropertyAnnotation(t){!t.optional&&this.eat(l.bang)&&(t.definite=!0);const e=this.tsTryParseTypeAnnotation();e&&(t.typeAnnotation=e)}parseClassProperty(t){return this.parseClassPropertyAnnotation(t),this.state.isDeclareContext&&this.match(l.eq)&&this.raise(this.state.start,ut.DeclareClassFieldHasInitializer),super.parseClassProperty(t)}parseClassPrivateProperty(t){return t.abstract&&this.raise(t.start,ut.PrivateElementHasAbstract),t.accessibility&&this.raise(t.start,ut.PrivateElementHasAccessibility,t.accessibility),this.parseClassPropertyAnnotation(t),super.parseClassPrivateProperty(t)}pushClassMethod(t,e,s,i,r,a){const n=this.tsTryParseTypeParameters();n&&r&&this.raise(n.start,ut.ConstructorHasTypeParameters),n&&(e.typeParameters=n),super.pushClassMethod(t,e,s,i,r,a)}pushClassPrivateMethod(t,e,s,i){const r=this.tsTryParseTypeParameters();r&&(e.typeParameters=r),super.pushClassPrivateMethod(t,e,s,i)}parseClassSuper(t){super.parseClassSuper(t),t.superClass&&this.isRelational(\"<\")&&(t.superTypeParameters=this.tsParseTypeArguments()),this.eatContextual(\"implements\")&&(t.implements=this.tsParseHeritageClause(\"implements\"))}parseObjPropValue(t,...e){const s=this.tsTryParseTypeParameters();s&&(t.typeParameters=s),super.parseObjPropValue(t,...e)}parseFunctionParams(t,e){const s=this.tsTryParseTypeParameters();s&&(t.typeParameters=s),super.parseFunctionParams(t,e)}parseVarId(t,e){super.parseVarId(t,e),\"Identifier\"===t.id.type&&this.eat(l.bang)&&(t.definite=!0);const s=this.tsTryParseTypeAnnotation();s&&(t.id.typeAnnotation=s,this.resetEndLocation(t.id))}parseAsyncArrowFromCallExpression(t,e){return this.match(l.colon)&&(t.returnType=this.tsParseTypeAnnotation()),super.parseAsyncArrowFromCallExpression(t,e)}parseMaybeAssign(...t){var e,s,i,r,a,n,o;let h,p,c,u;if(this.match(l.jsxTagStart)){if(h=this.state.clone(),p=this.tryParse((()=>super.parseMaybeAssign(...t)),h),!p.error)return p.node;const{context:e}=this.state;e[e.length-1]===A.j_oTag?e.length-=2:e[e.length-1]===A.j_expr&&(e.length-=1)}if(!(null==(e=p)?void 0:e.error)&&!this.isRelational(\"<\"))return super.parseMaybeAssign(...t);h=h||this.state.clone();const d=this.tryParse((e=>{var s;u=this.tsParseTypeParameters();const i=super.parseMaybeAssign(...t);return(\"ArrowFunctionExpression\"!==i.type||i.extra&&i.extra.parenthesized)&&e(),0!==(null==(s=u)?void 0:s.params.length)&&this.resetStartLocationFromNode(i,u),i.typeParameters=u,i}),h);if(!d.error&&!d.aborted)return d.node;if(!p&&(lt(!this.hasPlugin(\"jsx\")),c=this.tryParse((()=>super.parseMaybeAssign(...t)),h),!c.error))return c.node;if(null==(s=p)?void 0:s.node)return this.state=p.failState,p.node;if(d.node)return this.state=d.failState,d.node;if(null==(i=c)?void 0:i.node)return this.state=c.failState,c.node;if(null==(r=p)?void 0:r.thrown)throw p.error;if(d.thrown)throw d.error;if(null==(a=c)?void 0:a.thrown)throw c.error;throw(null==(n=p)?void 0:n.error)||d.error||(null==(o=c)?void 0:o.error)}parseMaybeUnary(t){return!this.hasPlugin(\"jsx\")&&this.isRelational(\"<\")?this.tsParseTypeAssertion():super.parseMaybeUnary(t)}parseArrow(t){if(this.match(l.colon)){const e=this.tryParse((t=>{const e=this.tsParseTypeOrTypePredicateAnnotation(l.colon);return!this.canInsertSemicolon()&&this.match(l.arrow)||t(),e}));if(e.aborted)return;e.thrown||(e.error&&(this.state=e.failState),t.returnType=e.node)}return super.parseArrow(t)}parseAssignableListItemTypes(t){this.eat(l.question)&&(\"Identifier\"===t.type||this.state.isDeclareContext||this.state.inType||this.raise(t.start,ut.PatternIsOptional),t.optional=!0);const e=this.tsTryParseTypeAnnotation();return e&&(t.typeAnnotation=e),this.resetEndLocation(t),t}toAssignable(t,e=!1){switch(t.type){case\"TSTypeCastExpression\":return super.toAssignable(this.typeCastToParameter(t),e);case\"TSParameterProperty\":return super.toAssignable(t,e);case\"TSAsExpression\":case\"TSNonNullExpression\":case\"TSTypeAssertion\":return t.expression=this.toAssignable(t.expression,e),t;default:return super.toAssignable(t,e)}}checkLVal(t,e,...s){switch(t.type){case\"TSTypeCastExpression\":return;case\"TSParameterProperty\":return void this.checkLVal(t.parameter,\"parameter property\",...s);case\"TSAsExpression\":case\"TSNonNullExpression\":case\"TSTypeAssertion\":return void this.checkLVal(t.expression,e,...s);default:return void super.checkLVal(t,e,...s)}}parseBindingAtom(){switch(this.state.type){case l._this:return this.parseIdentifier(!0);default:return super.parseBindingAtom()}}parseMaybeDecoratorArguments(t){if(this.isRelational(\"<\")){const e=this.tsParseTypeArguments();if(this.match(l.parenL)){const s=super.parseMaybeDecoratorArguments(t);return s.typeParameters=e,s}this.unexpected(this.state.start,l.parenL)}return super.parseMaybeDecoratorArguments(t)}isClassMethod(){return this.isRelational(\"<\")||super.isClassMethod()}isClassProperty(){return this.match(l.bang)||this.match(l.colon)||super.isClassProperty()}parseMaybeDefault(...t){const e=super.parseMaybeDefault(...t);return\"AssignmentPattern\"===e.type&&e.typeAnnotation&&e.right.start<e.typeAnnotation.start&&this.raise(e.typeAnnotation.start,ut.TypeAnnotationAfterAssign),e}getTokenFromCode(t){return!this.state.inType||62!==t&&60!==t?super.getTokenFromCode(t):this.finishOp(l.relational,1)}reScan_lt_gt(){if(this.match(l.relational)){const t=this.input.charCodeAt(this.state.start);60!==t&&62!==t||(this.state.pos-=1,this.readToken_lt_gt(t))}}toAssignableList(t){for(let e=0;e<t.length;e++){const s=t[e];if(s)switch(s.type){case\"TSTypeCastExpression\":t[e]=this.typeCastToParameter(s);break;case\"TSAsExpression\":case\"TSTypeAssertion\":this.state.maybeInArrowParameters?this.raise(s.start,ut.UnexpectedTypeCastInParameter):t[e]=this.typeCastToParameter(s)}}return super.toAssignableList(...arguments)}typeCastToParameter(t){return t.expression.typeAnnotation=t.typeAnnotation,this.resetEndLocation(t.expression,t.typeAnnotation.end,t.typeAnnotation.loc.end),t.expression}shouldParseArrow(){return this.match(l.colon)||super.shouldParseArrow()}shouldParseAsyncArrow(){return this.match(l.colon)||super.shouldParseAsyncArrow()}canHaveLeadingDecorator(){return super.canHaveLeadingDecorator()||this.isAbstractClass()}jsxParseOpeningElementAfterName(t){if(this.isRelational(\"<\")){const e=this.tsTryParseAndCatch((()=>this.tsParseTypeArguments()));e&&(t.typeParameters=e)}return super.jsxParseOpeningElementAfterName(t)}getGetterSetterExpectedParamCount(t){const e=super.getGetterSetterExpectedParamCount(t),s=this.getObjectOrClassMethodParams(t)[0];return s&&\"Identifier\"===s.type&&\"this\"===s.name?e+1:e}parseCatchClauseParam(){const t=super.parseCatchClauseParam(),e=this.tsTryParseTypeAnnotation();return e&&(t.typeAnnotation=e,this.resetEndLocation(t)),t}tsInDeclareContext(t){const e=this.state.isDeclareContext;this.state.isDeclareContext=!0;try{return t()}finally{this.state.isDeclareContext=e}}},v8intrinsic:t=>class extends t{parseV8Intrinsic(){if(this.match(l.modulo)){const t=this.state.start,e=this.startNode();if(this.eat(l.modulo),this.match(l.name)){const t=this.parseIdentifierName(this.state.start),s=this.createIdentifier(e,t);if(s.type=\"V8IntrinsicIdentifier\",this.match(l.parenL))return s}this.unexpected(t)}}parseExprAtom(){return this.parseV8Intrinsic()||super.parseExprAtom(...arguments)}},placeholders:t=>class extends t{parsePlaceholder(t){if(this.match(l.placeholder)){const e=this.startNode();return this.next(),this.assertNoSpace(\"Unexpected space in placeholder.\"),e.name=super.parseIdentifier(!0),this.assertNoSpace(\"Unexpected space in placeholder.\"),this.expect(l.placeholder),this.finishPlaceholder(e,t)}}finishPlaceholder(t,e){const s=!(!t.expectedNode||\"Placeholder\"!==t.type);return t.expectedNode=e,s?t:this.finishNode(t,\"Placeholder\")}getTokenFromCode(t){return 37===t&&37===this.input.charCodeAt(this.state.pos+1)?this.finishOp(l.placeholder,2):super.getTokenFromCode(...arguments)}parseExprAtom(){return this.parsePlaceholder(\"Expression\")||super.parseExprAtom(...arguments)}parseIdentifier(){return this.parsePlaceholder(\"Identifier\")||super.parseIdentifier(...arguments)}checkReservedWord(t){void 0!==t&&super.checkReservedWord(...arguments)}parseBindingAtom(){return this.parsePlaceholder(\"Pattern\")||super.parseBindingAtom(...arguments)}checkLVal(t){\"Placeholder\"!==t.type&&super.checkLVal(...arguments)}toAssignable(t){return t&&\"Placeholder\"===t.type&&\"Expression\"===t.expectedNode?(t.expectedNode=\"Pattern\",t):super.toAssignable(...arguments)}verifyBreakContinue(t){t.label&&\"Placeholder\"===t.label.type||super.verifyBreakContinue(...arguments)}parseExpressionStatement(t,e){if(\"Placeholder\"!==e.type||e.extra&&e.extra.parenthesized)return super.parseExpressionStatement(...arguments);if(this.match(l.colon)){const s=t;return s.label=this.finishPlaceholder(e,\"Identifier\"),this.next(),s.body=this.parseStatement(\"label\"),this.finishNode(s,\"LabeledStatement\")}return this.semicolon(),t.name=e.name,this.finishPlaceholder(t,\"Statement\")}parseBlock(){return this.parsePlaceholder(\"BlockStatement\")||super.parseBlock(...arguments)}parseFunctionId(){return this.parsePlaceholder(\"Identifier\")||super.parseFunctionId(...arguments)}parseClass(t,e,s){const i=e?\"ClassDeclaration\":\"ClassExpression\";this.next(),this.takeDecorators(t);const r=this.state.strict,a=this.parsePlaceholder(\"Identifier\");if(a)if(this.match(l._extends)||this.match(l.placeholder)||this.match(l.braceL))t.id=a;else{if(s||!e)return t.id=null,t.body=this.finishPlaceholder(a,\"ClassBody\"),this.finishNode(t,i);this.unexpected(null,\"A class name is required\")}else this.parseClassId(t,e,s);return this.parseClassSuper(t),t.body=this.parsePlaceholder(\"ClassBody\")||this.parseClassBody(!!t.superClass,r),this.finishNode(t,i)}parseExport(t){const e=this.parsePlaceholder(\"Identifier\");if(!e)return super.parseExport(...arguments);if(!this.isContextual(\"from\")&&!this.match(l.comma))return t.specifiers=[],t.source=null,t.declaration=this.finishPlaceholder(e,\"Declaration\"),this.finishNode(t,\"ExportNamedDeclaration\");this.expectPlugin(\"exportDefaultFrom\");const s=this.startNode();return s.exported=e,t.specifiers=[this.finishNode(s,\"ExportDefaultSpecifier\")],super.parseExport(t)}isExportDefaultSpecifier(){if(this.match(l._default)){const t=this.nextTokenStart();if(this.isUnparsedContextual(t,\"from\")&&this.input.startsWith(l.placeholder.label,this.nextTokenStartSince(t+4)))return!0}return super.isExportDefaultSpecifier()}maybeParseExportDefaultSpecifier(t){return!!(t.specifiers&&t.specifiers.length>0)||super.maybeParseExportDefaultSpecifier(...arguments)}checkExport(t){const{specifiers:e}=t;(null==e?void 0:e.length)&&(t.specifiers=e.filter((t=>\"Placeholder\"===t.exported.type))),super.checkExport(t),t.specifiers=e}parseImport(t){const e=this.parsePlaceholder(\"Identifier\");if(!e)return super.parseImport(...arguments);if(t.specifiers=[],!this.isContextual(\"from\")&&!this.match(l.comma))return t.source=this.finishPlaceholder(e,\"StringLiteral\"),this.semicolon(),this.finishNode(t,\"ImportDeclaration\");const s=this.startNodeAtNode(e);if(s.local=e,this.finishNode(s,\"ImportDefaultSpecifier\"),t.specifiers.push(s),this.eat(l.comma)){this.maybeParseStarImportSpecifier(t)||this.parseNamedImportSpecifiers(t)}return this.expectContextual(\"from\"),t.source=this.parseImportSource(),this.semicolon(),this.finishNode(t,\"ImportDeclaration\")}parseImportSource(){return this.parsePlaceholder(\"StringLiteral\")||super.parseImportSource(...arguments)}}},Pt=Object.keys(xt),gt={sourceType:\"script\",sourceFilename:void 0,startLine:1,allowAwaitOutsideFunction:!1,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowSuperOutsideMethod:!1,allowUndeclaredExports:!1,plugins:[],strictMode:null,ranges:!1,tokens:!1,createParenthesizedExpressions:!1,errorRecovery:!1};class bt{constructor(){this.strict=void 0,this.curLine=void 0,this.startLoc=void 0,this.endLoc=void 0,this.errors=[],this.potentialArrowAt=-1,this.noArrowAt=[],this.noArrowParamsConversionAt=[],this.maybeInArrowParameters=!1,this.inPipeline=!1,this.inType=!1,this.noAnonFunctionType=!1,this.inPropertyName=!1,this.hasFlowComment=!1,this.isIterator=!1,this.isDeclareContext=!1,this.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null},this.soloAwait=!1,this.inFSharpPipelineDirectBody=!1,this.labels=[],this.decoratorStack=[[]],this.comments=[],this.trailingComments=[],this.leadingComments=[],this.commentStack=[],this.commentPreviousNode=null,this.pos=0,this.lineStart=0,this.type=l.eof,this.value=null,this.start=0,this.end=0,this.lastTokEndLoc=null,this.lastTokStartLoc=null,this.lastTokStart=0,this.lastTokEnd=0,this.context=[A.braceStatement],this.exprAllowed=!0,this.containsEsc=!1,this.strictErrors=new Map,this.exportedIdentifiers=[],this.tokensLength=0}init(t){this.strict=!1!==t.strictMode&&\"module\"===t.sourceType,this.curLine=t.startLine,this.startLoc=this.endLoc=this.curPosition()}curPosition(){return new x(this.curLine,this.pos-this.lineStart)}clone(t){const e=new bt,s=Object.keys(this);for(let i=0,r=s.length;i<r;i++){const r=s[i];let a=this[r];!t&&Array.isArray(a)&&(a=a.slice()),e[r]=a}return e}}var Tt=function(t){return t>=48&&t<=57};const At=new Set([\"g\",\"m\",\"s\",\"i\",\"y\",\"u\"]),wt={decBinOct:[46,66,69,79,95,98,101,111],hex:[46,88,95,120]},Et={bin:[48,49]};Et.oct=[...Et.bin,50,51,52,53,54,55],Et.dec=[...Et.oct,56,57],Et.hex=[...Et.dec,65,66,67,68,69,70,97,98,99,100,101,102];class St{constructor(t){this.type=t.type,this.value=t.value,this.start=t.start,this.end=t.end,this.loc=new P(t.startLoc,t.endLoc)}}class Ct{constructor(){this.shorthandAssign=-1,this.doubleProto=-1}}class Nt{constructor(t,e,s){this.type=void 0,this.start=void 0,this.end=void 0,this.loc=void 0,this.range=void 0,this.leadingComments=void 0,this.trailingComments=void 0,this.innerComments=void 0,this.extra=void 0,this.type=\"\",this.start=e,this.end=0,this.loc=new P(s),(null==t?void 0:t.options.ranges)&&(this.range=[e,0]),(null==t?void 0:t.filename)&&(this.loc.filename=t.filename)}__clone(){const t=new Nt,e=Object.keys(this);for(let s=0,i=e.length;s<i;s++){const i=e[s];\"leadingComments\"!==i&&\"trailingComments\"!==i&&\"innerComments\"!==i&&(t[i]=this[i])}return t}}const kt=t=>\"ParenthesizedExpression\"===t.type?kt(t.expression):t;class It{constructor(t=0){this.type=void 0,this.type=t}canBeArrowParameterDeclaration(){return 2===this.type||1===this.type}isCertainlyParameterDeclaration(){return 3===this.type}}class vt extends It{constructor(t){super(t),this.errors=new Map}recordDeclarationError(t,e){this.errors.set(t,e)}clearDeclarationError(t){this.errors.delete(t)}iterateErrors(t){this.errors.forEach(t)}}class Lt{constructor(t){this.stack=[new It],this.raise=t}enter(t){this.stack.push(t)}exit(){this.stack.pop()}recordParameterInitializerError(t,e){const{stack:s}=this;let i=s.length-1,r=s[i];for(;!r.isCertainlyParameterDeclaration();){if(!r.canBeArrowParameterDeclaration())return;r.recordDeclarationError(t,e),r=s[--i]}this.raise(t,e)}recordParenthesizedIdentifierError(t,e){const{stack:s}=this,i=s[s.length-1];if(i.isCertainlyParameterDeclaration())this.raise(t,e);else{if(!i.canBeArrowParameterDeclaration())return;i.recordDeclarationError(t,e)}}recordAsyncArrowParametersError(t,e){const{stack:s}=this;let i=s.length-1,r=s[i];for(;r.canBeArrowParameterDeclaration();)2===r.type&&r.recordDeclarationError(t,e),r=s[--i]}validateAsPattern(){const{stack:t}=this,e=t[t.length-1];e.canBeArrowParameterDeclaration()&&e.iterateErrors(((e,s)=>{this.raise(s,e);let i=t.length-2,r=t[i];for(;r.canBeArrowParameterDeclaration();)r.clearDeclarationError(s),r=t[--i]}))}}function Dt(){return new It}const Mt={kind:\"loop\"},Rt={kind:\"switch\"},Ot=/[\\uD800-\\uDFFF]/u;class Ft{constructor(){this.privateNames=new Set,this.loneAccessors=new Map,this.undefinedPrivateNames=new Map}}class Bt{constructor(t){this.stack=[],this.undefinedPrivateNames=new Map,this.raise=t}current(){return this.stack[this.stack.length-1]}enter(){this.stack.push(new Ft)}exit(){const t=this.stack.pop(),e=this.current();for(let s=0,i=Array.from(t.undefinedPrivateNames);s<i.length;s++){const[t,r]=i[s];e?e.undefinedPrivateNames.has(t)||e.undefinedPrivateNames.set(t,r):this.raise(r,b.InvalidPrivateFieldResolution,t)}}declarePrivateName(t,e,s){const i=this.current();let r=i.privateNames.has(t);if(3&e){const s=r&&i.loneAccessors.get(t);if(s){const a=4&s,n=4&e;r=(3&s)===(3&e)||a!==n,r||i.loneAccessors.delete(t)}else r||i.loneAccessors.set(t,e)}r&&this.raise(s,b.PrivateNameRedeclaration,t),i.privateNames.add(t),i.undefinedPrivateNames.delete(t)}usePrivateName(t,e){let s;for(let i=0,r=this.stack;i<r.length;i++)if(s=r[i],s.privateNames.has(t))return;s?s.undefinedPrivateNames.set(t,e):this.raise(e,b.InvalidPrivateFieldResolution,t)}}class _t extends class extends class extends class extends class extends class extends class extends class extends class extends class{constructor(){this.sawUnambiguousESM=!1,this.ambiguousScriptDifferentAst=!1}hasPlugin(t){return this.plugins.has(t)}getPluginOption(t,e){if(this.hasPlugin(t))return this.plugins.get(t)[e]}}{addComment(t){this.filename&&(t.loc.filename=this.filename),this.state.trailingComments.push(t),this.state.leadingComments.push(t)}adjustCommentsAfterTrailingComma(t,e,s){if(0===this.state.leadingComments.length)return;let i=null,r=e.length;for(;null===i&&r>0;)i=e[--r];if(null===i)return;for(let n=0;n<this.state.leadingComments.length;n++)this.state.leadingComments[n].end<this.state.commentPreviousNode.end&&(this.state.leadingComments.splice(n,1),n--);const a=[];for(let n=0;n<this.state.leadingComments.length;n++){const e=this.state.leadingComments[n];e.end<t.end?(a.push(e),s||(this.state.leadingComments.splice(n,1),n--)):(void 0===t.trailingComments&&(t.trailingComments=[]),t.trailingComments.push(e))}s&&(this.state.leadingComments=[]),a.length>0?i.trailingComments=a:void 0!==i.trailingComments&&(i.trailingComments=[])}processComment(t){if(\"Program\"===t.type&&t.body.length>0)return;const e=this.state.commentStack;let s,i,r,a,n;if(this.state.trailingComments.length>0)this.state.trailingComments[0].start>=t.end?(r=this.state.trailingComments,this.state.trailingComments=[]):this.state.trailingComments.length=0;else if(e.length>0){const s=g(e);s.trailingComments&&s.trailingComments[0].start>=t.end&&(r=s.trailingComments,delete s.trailingComments)}for(e.length>0&&g(e).start>=t.start&&(s=e.pop());e.length>0&&g(e).start>=t.start;)i=e.pop();if(!i&&s&&(i=s),s)switch(t.type){case\"ObjectExpression\":this.adjustCommentsAfterTrailingComma(t,t.properties);break;case\"ObjectPattern\":this.adjustCommentsAfterTrailingComma(t,t.properties,!0);break;case\"CallExpression\":this.adjustCommentsAfterTrailingComma(t,t.arguments);break;case\"ArrayExpression\":this.adjustCommentsAfterTrailingComma(t,t.elements);break;case\"ArrayPattern\":this.adjustCommentsAfterTrailingComma(t,t.elements,!0)}else this.state.commentPreviousNode&&(\"ImportSpecifier\"===this.state.commentPreviousNode.type&&\"ImportSpecifier\"!==t.type||\"ExportSpecifier\"===this.state.commentPreviousNode.type&&\"ExportSpecifier\"!==t.type)&&this.adjustCommentsAfterTrailingComma(t,[this.state.commentPreviousNode]);if(i){if(i.leadingComments)if(i!==t&&i.leadingComments.length>0&&g(i.leadingComments).end<=t.start)t.leadingComments=i.leadingComments,delete i.leadingComments;else for(a=i.leadingComments.length-2;a>=0;--a)if(i.leadingComments[a].end<=t.start){t.leadingComments=i.leadingComments.splice(0,a+1);break}}else if(this.state.leadingComments.length>0)if(g(this.state.leadingComments).end<=t.start){if(this.state.commentPreviousNode)for(n=0;n<this.state.leadingComments.length;n++)this.state.leadingComments[n].end<this.state.commentPreviousNode.end&&(this.state.leadingComments.splice(n,1),n--);this.state.leadingComments.length>0&&(t.leadingComments=this.state.leadingComments,this.state.leadingComments=[])}else{for(a=0;a<this.state.leadingComments.length&&!(this.state.leadingComments[a].end>t.start);a++);const e=this.state.leadingComments.slice(0,a);e.length&&(t.leadingComments=e),r=this.state.leadingComments.slice(a),0===r.length&&(r=null)}if(this.state.commentPreviousNode=t,r)if(r.length&&r[0].start>=t.start&&g(r).end<=t.end)t.innerComments=r;else{const e=r.findIndex((e=>e.end>=t.end));e>0?(t.innerComments=r.slice(0,e),t.trailingComments=r.slice(e)):t.trailingComments=r}e.push(t)}}{getLocationForPosition(t){let e;return e=t===this.state.start?this.state.startLoc:t===this.state.lastTokStart?this.state.lastTokStartLoc:t===this.state.end?this.state.endLoc:t===this.state.lastTokEnd?this.state.lastTokEndLoc:function(t,e){let s,i=1,r=0;for(d.lastIndex=0;(s=d.exec(t))&&s.index<e;)i++,r=d.lastIndex;return new x(i,e-r)}(this.input,t),e}raise(t,e,...s){return this.raiseWithData(t,void 0,e,...s)}raiseWithData(t,e,s,...i){const r=this.getLocationForPosition(t),a=s.replace(/%(\\d+)/g,((t,e)=>i[e]))+` (${r.line}:${r.column})`;return this._raise(Object.assign({loc:r,pos:t},e),a)}_raise(t,e){const s=new SyntaxError(e);if(Object.assign(s,t),this.options.errorRecovery)return this.isLookahead||this.state.errors.push(s),s;throw s}}{constructor(t,e){super(),this.isLookahead=void 0,this.tokens=[],this.state=new bt,this.state.init(t),this.input=e,this.length=e.length,this.isLookahead=!1}pushToken(t){this.tokens.length=this.state.tokensLength,this.tokens.push(t),++this.state.tokensLength}next(){this.isLookahead||(this.checkKeywordEscapes(),this.options.tokens&&this.pushToken(new St(this.state))),this.state.lastTokEnd=this.state.end,this.state.lastTokStart=this.state.start,this.state.lastTokEndLoc=this.state.endLoc,this.state.lastTokStartLoc=this.state.startLoc,this.nextToken()}eat(t){return!!this.match(t)&&(this.next(),!0)}match(t){return this.state.type===t}lookahead(){const t=this.state;this.state=t.clone(!0),this.isLookahead=!0,this.next(),this.isLookahead=!1;const e=this.state;return this.state=t,e}nextTokenStart(){return this.nextTokenStartSince(this.state.pos)}nextTokenStartSince(t){f.lastIndex=t;return t+f.exec(this.input)[0].length}lookaheadCharCode(){return this.input.charCodeAt(this.nextTokenStart())}setStrict(t){this.state.strict=t,t&&(this.state.strictErrors.forEach(((t,e)=>this.raise(e,t))),this.state.strictErrors.clear())}curContext(){return this.state.context[this.state.context.length-1]}nextToken(){const t=this.curContext();if((null==t?void 0:t.preserveSpace)||this.skipSpace(),this.state.start=this.state.pos,this.state.startLoc=this.state.curPosition(),this.state.pos>=this.length)return void this.finishToken(l.eof);const e=null==t?void 0:t.override;e?e(this):this.getTokenFromCode(this.input.codePointAt(this.state.pos))}pushComment(t,e,s,i,r,a){const n={type:t?\"CommentBlock\":\"CommentLine\",value:e,start:s,end:i,loc:new P(r,a)};this.options.tokens&&this.pushToken(n),this.state.comments.push(n),this.addComment(n)}skipBlockComment(){const t=this.state.curPosition(),e=this.state.pos,s=this.input.indexOf(\"*/\",this.state.pos+2);if(-1===s)throw this.raise(e,b.UnterminatedComment);let i;for(this.state.pos=s+2,d.lastIndex=e;(i=d.exec(this.input))&&i.index<this.state.pos;)++this.state.curLine,this.state.lineStart=i.index+i[0].length;this.isLookahead||this.pushComment(!0,this.input.slice(e+2,s),e,this.state.pos,t,this.state.curPosition())}skipLineComment(t){const e=this.state.pos,s=this.state.curPosition();let i=this.input.charCodeAt(this.state.pos+=t);if(this.state.pos<this.length)for(;!m(i)&&++this.state.pos<this.length;)i=this.input.charCodeAt(this.state.pos);this.isLookahead||this.pushComment(!1,this.input.slice(e+t,this.state.pos),e,this.state.pos,s,this.state.curPosition())}skipSpace(){t:for(;this.state.pos<this.length;){const t=this.input.charCodeAt(this.state.pos);switch(t){case 32:case 160:case 9:++this.state.pos;break;case 13:10===this.input.charCodeAt(this.state.pos+1)&&++this.state.pos;case 10:case 8232:case 8233:++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;break;case 47:switch(this.input.charCodeAt(this.state.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break t}break;default:if(!y(t))break t;++this.state.pos}}}finishToken(t,e){this.state.end=this.state.pos,this.state.endLoc=this.state.curPosition();const s=this.state.type;this.state.type=t,this.state.value=e,this.isLookahead||this.updateContext(s)}readToken_numberSign(){if(0===this.state.pos&&this.readToken_interpreter())return;const t=this.state.pos+1,e=this.input.charCodeAt(t);if(e>=48&&e<=57)throw this.raise(this.state.pos,b.UnexpectedDigitAfterHash);if(123===e||91===e&&this.hasPlugin(\"recordAndTuple\")){if(this.expectPlugin(\"recordAndTuple\"),\"hash\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,123===e?b.RecordExpressionHashIncorrectStartSyntaxType:b.TupleExpressionHashIncorrectStartSyntaxType);123===e?this.finishToken(l.braceHashL):this.finishToken(l.bracketHashL),this.state.pos+=2}else this.finishOp(l.hash,1)}readToken_dot(){const t=this.input.charCodeAt(this.state.pos+1);t>=48&&t<=57?this.readNumber(!0):46===t&&46===this.input.charCodeAt(this.state.pos+2)?(this.state.pos+=3,this.finishToken(l.ellipsis)):(++this.state.pos,this.finishToken(l.dot))}readToken_slash(){if(this.state.exprAllowed&&!this.state.inType)return++this.state.pos,void this.readRegexp();61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(l.assign,2):this.finishOp(l.slash,1)}readToken_interpreter(){if(0!==this.state.pos||this.length<2)return!1;let t=this.input.charCodeAt(this.state.pos+1);if(33!==t)return!1;const e=this.state.pos;for(this.state.pos+=1;!m(t)&&++this.state.pos<this.length;)t=this.input.charCodeAt(this.state.pos);const s=this.input.slice(e+2,this.state.pos);return this.finishToken(l.interpreterDirective,s),!0}readToken_mult_modulo(t){let e=42===t?l.star:l.modulo,s=1,i=this.input.charCodeAt(this.state.pos+1);const r=this.state.exprAllowed;42===t&&42===i&&(s++,i=this.input.charCodeAt(this.state.pos+2),e=l.exponent),61!==i||r||(s++,e=l.assign),this.finishOp(e,s)}readToken_pipe_amp(t){const e=this.input.charCodeAt(this.state.pos+1);if(e!==t){if(124===t){if(62===e)return void this.finishOp(l.pipeline,2);if(this.hasPlugin(\"recordAndTuple\")&&125===e){if(\"bar\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,b.RecordExpressionBarIncorrectEndSyntaxType);return void this.finishOp(l.braceBarR,2)}if(this.hasPlugin(\"recordAndTuple\")&&93===e){if(\"bar\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,b.TupleExpressionBarIncorrectEndSyntaxType);return void this.finishOp(l.bracketBarR,2)}}61!==e?this.finishOp(124===t?l.bitwiseOR:l.bitwiseAND,1):this.finishOp(l.assign,2)}else 61===this.input.charCodeAt(this.state.pos+2)?this.finishOp(l.assign,3):this.finishOp(124===t?l.logicalOR:l.logicalAND,2)}readToken_caret(){61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(l.assign,2):this.finishOp(l.bitwiseXOR,1)}readToken_plus_min(t){const e=this.input.charCodeAt(this.state.pos+1);if(e===t)return 45!==e||this.inModule||62!==this.input.charCodeAt(this.state.pos+2)||0!==this.state.lastTokEnd&&!this.hasPrecedingLineBreak()?void this.finishOp(l.incDec,2):(this.skipLineComment(3),this.skipSpace(),void this.nextToken());61===e?this.finishOp(l.assign,2):this.finishOp(l.plusMin,1)}readToken_lt_gt(t){const e=this.input.charCodeAt(this.state.pos+1);let s=1;return e===t?(s=62===t&&62===this.input.charCodeAt(this.state.pos+2)?3:2,61===this.input.charCodeAt(this.state.pos+s)?void this.finishOp(l.assign,s+1):void this.finishOp(l.bitShift,s)):33!==e||60!==t||this.inModule||45!==this.input.charCodeAt(this.state.pos+2)||45!==this.input.charCodeAt(this.state.pos+3)?(61===e&&(s=2),void this.finishOp(l.relational,s)):(this.skipLineComment(4),this.skipSpace(),void this.nextToken())}readToken_eq_excl(t){const e=this.input.charCodeAt(this.state.pos+1);if(61!==e)return 61===t&&62===e?(this.state.pos+=2,void this.finishToken(l.arrow)):void this.finishOp(61===t?l.eq:l.bang,1);this.finishOp(l.equality,61===this.input.charCodeAt(this.state.pos+2)?3:2)}readToken_question(){const t=this.input.charCodeAt(this.state.pos+1),e=this.input.charCodeAt(this.state.pos+2);63===t?61===e?this.finishOp(l.assign,3):this.finishOp(l.nullishCoalescing,2):46!==t||e>=48&&e<=57?(++this.state.pos,this.finishToken(l.question)):(this.state.pos+=2,this.finishToken(l.questionDot))}getTokenFromCode(t){switch(t){case 46:return void this.readToken_dot();case 40:return++this.state.pos,void this.finishToken(l.parenL);case 41:return++this.state.pos,void this.finishToken(l.parenR);case 59:return++this.state.pos,void this.finishToken(l.semi);case 44:return++this.state.pos,void this.finishToken(l.comma);case 91:if(this.hasPlugin(\"recordAndTuple\")&&124===this.input.charCodeAt(this.state.pos+1)){if(\"bar\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,b.TupleExpressionBarIncorrectStartSyntaxType);this.finishToken(l.bracketBarL),this.state.pos+=2}else++this.state.pos,this.finishToken(l.bracketL);return;case 93:return++this.state.pos,void this.finishToken(l.bracketR);case 123:if(this.hasPlugin(\"recordAndTuple\")&&124===this.input.charCodeAt(this.state.pos+1)){if(\"bar\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,b.RecordExpressionBarIncorrectStartSyntaxType);this.finishToken(l.braceBarL),this.state.pos+=2}else++this.state.pos,this.finishToken(l.braceL);return;case 125:return++this.state.pos,void this.finishToken(l.braceR);case 58:return void(this.hasPlugin(\"functionBind\")&&58===this.input.charCodeAt(this.state.pos+1)?this.finishOp(l.doubleColon,2):(++this.state.pos,this.finishToken(l.colon)));case 63:return void this.readToken_question();case 96:return++this.state.pos,void this.finishToken(l.backQuote);case 48:{const t=this.input.charCodeAt(this.state.pos+1);if(120===t||88===t)return void this.readRadixNumber(16);if(111===t||79===t)return void this.readRadixNumber(8);if(98===t||66===t)return void this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return void this.readNumber(!1);case 34:case 39:return void this.readString(t);case 47:return void this.readToken_slash();case 37:case 42:return void this.readToken_mult_modulo(t);case 124:case 38:return void this.readToken_pipe_amp(t);case 94:return void this.readToken_caret();case 43:case 45:return void this.readToken_plus_min(t);case 60:case 62:return void this.readToken_lt_gt(t);case 61:case 33:return void this.readToken_eq_excl(t);case 126:return void this.finishOp(l.tilde,1);case 64:return++this.state.pos,void this.finishToken(l.at);case 35:return void this.readToken_numberSign();case 92:return void this.readWord();default:if(v(t))return void this.readWord()}throw this.raise(this.state.pos,b.InvalidOrUnexpectedToken,String.fromCodePoint(t))}finishOp(t,e){const s=this.input.slice(this.state.pos,this.state.pos+e);this.state.pos+=e,this.finishToken(t,s)}readRegexp(){const t=this.state.pos;let e,s;for(;;){if(this.state.pos>=this.length)throw this.raise(t,b.UnterminatedRegExp);const i=this.input.charAt(this.state.pos);if(u.test(i))throw this.raise(t,b.UnterminatedRegExp);if(e)e=!1;else{if(\"[\"===i)s=!0;else if(\"]\"===i&&s)s=!1;else if(\"/\"===i&&!s)break;e=\"\\\\\"===i}++this.state.pos}const i=this.input.slice(t,this.state.pos);++this.state.pos;let r=\"\";for(;this.state.pos<this.length;){const t=this.input[this.state.pos],e=this.input.codePointAt(this.state.pos);if(At.has(t))r.indexOf(t)>-1&&this.raise(this.state.pos+1,b.DuplicateRegExpFlags);else{if(!L(e)&&92!==e)break;this.raise(this.state.pos+1,b.MalformedRegExpFlags)}++this.state.pos,r+=t}this.finishToken(l.regexp,{pattern:i,flags:r})}readInt(t,e,s,i=!0){const r=this.state.pos,a=16===t?wt.hex:wt.decBinOct,n=16===t?Et.hex:10===t?Et.dec:8===t?Et.oct:Et.bin;let o=!1,h=0;for(let p=0,c=null==e?1/0:e;p<c;++p){const e=this.input.charCodeAt(this.state.pos);let r;if(95!==e){if(r=e>=97?e-97+10:e>=65?e-65+10:Tt(e)?e-48:1/0,r>=t)if(this.options.errorRecovery&&r<=9)r=0,this.raise(this.state.start+p+2,b.InvalidDigit,t);else{if(!s)break;r=0,o=!0}++this.state.pos,h=h*t+r}else{const t=this.input.charCodeAt(this.state.pos-1),e=this.input.charCodeAt(this.state.pos+1);(-1===n.indexOf(e)||a.indexOf(t)>-1||a.indexOf(e)>-1||Number.isNaN(e))&&this.raise(this.state.pos,b.UnexpectedNumericSeparator),i||this.raise(this.state.pos,b.NumericSeparatorInEscapeSequence),++this.state.pos}}return this.state.pos===r||null!=e&&this.state.pos-r!==e||o?null:h}readRadixNumber(t){const e=this.state.pos;let s=!1;this.state.pos+=2;const i=this.readInt(t);null==i&&this.raise(this.state.start+2,b.InvalidDigit,t);const r=this.input.charCodeAt(this.state.pos);if(110===r)++this.state.pos,s=!0;else if(109===r)throw this.raise(e,b.InvalidDecimal);if(v(this.input.codePointAt(this.state.pos)))throw this.raise(this.state.pos,b.NumberIdentifier);if(s){const t=this.input.slice(e,this.state.pos).replace(/[_n]/g,\"\");this.finishToken(l.bigint,t)}else this.finishToken(l.num,i)}readNumber(t){const e=this.state.pos;let s=!1,i=!1,r=!1,a=!1,n=!1;t||null!==this.readInt(10)||this.raise(e,b.InvalidNumber);const o=this.state.pos-e>=2&&48===this.input.charCodeAt(e);if(o){const t=this.input.slice(e,this.state.pos);if(this.recordStrictModeErrors(e,b.StrictOctalLiteral),!this.state.strict){const s=t.indexOf(\"_\");s>0&&this.raise(s+e,b.ZeroDigitNumericSeparator)}n=o&&!/[89]/.test(t)}let h=this.input.charCodeAt(this.state.pos);if(46!==h||n||(++this.state.pos,this.readInt(10),s=!0,h=this.input.charCodeAt(this.state.pos)),69!==h&&101!==h||n||(h=this.input.charCodeAt(++this.state.pos),43!==h&&45!==h||++this.state.pos,null===this.readInt(10)&&this.raise(e,b.InvalidOrMissingExponent),s=!0,a=!0,h=this.input.charCodeAt(this.state.pos)),110===h&&((s||o)&&this.raise(e,b.InvalidBigIntLiteral),++this.state.pos,i=!0),109===h&&(this.expectPlugin(\"decimal\",this.state.pos),(a||o)&&this.raise(e,b.InvalidDecimal),++this.state.pos,r=!0),v(this.input.codePointAt(this.state.pos)))throw this.raise(this.state.pos,b.NumberIdentifier);const p=this.input.slice(e,this.state.pos).replace(/[_mn]/g,\"\");if(i)return void this.finishToken(l.bigint,p);if(r)return void this.finishToken(l.decimal,p);const c=n?parseInt(p,8):parseFloat(p);this.finishToken(l.num,c)}readCodePoint(t){let e;if(123===this.input.charCodeAt(this.state.pos)){const s=++this.state.pos;if(e=this.readHexChar(this.input.indexOf(\"}\",this.state.pos)-this.state.pos,!0,t),++this.state.pos,null!==e&&e>1114111){if(!t)return null;this.raise(s,b.InvalidCodePoint)}}else e=this.readHexChar(4,!1,t);return e}readString(t){let e=\"\",s=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,b.UnterminatedString);const i=this.input.charCodeAt(this.state.pos);if(i===t)break;if(92===i)e+=this.input.slice(s,this.state.pos),e+=this.readEscapedChar(!1),s=this.state.pos;else if(8232===i||8233===i)++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;else{if(m(i))throw this.raise(this.state.start,b.UnterminatedString);++this.state.pos}}e+=this.input.slice(s,this.state.pos++),this.finishToken(l.string,e)}readTmplToken(){let t=\"\",e=this.state.pos,s=!1;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,b.UnterminatedTemplate);const i=this.input.charCodeAt(this.state.pos);if(96===i||36===i&&123===this.input.charCodeAt(this.state.pos+1))return this.state.pos===this.state.start&&this.match(l.template)?36===i?(this.state.pos+=2,void this.finishToken(l.dollarBraceL)):(++this.state.pos,void this.finishToken(l.backQuote)):(t+=this.input.slice(e,this.state.pos),void this.finishToken(l.template,s?null:t));if(92===i){t+=this.input.slice(e,this.state.pos);const i=this.readEscapedChar(!0);null===i?s=!0:t+=i,e=this.state.pos}else if(m(i)){switch(t+=this.input.slice(e,this.state.pos),++this.state.pos,i){case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:t+=\"\\n\";break;default:t+=String.fromCharCode(i)}++this.state.curLine,this.state.lineStart=this.state.pos,e=this.state.pos}else++this.state.pos}}recordStrictModeErrors(t,e){this.state.strict&&!this.state.strictErrors.has(t)?this.raise(t,e):this.state.strictErrors.set(t,e)}readEscapedChar(t){const e=!t,s=this.input.charCodeAt(++this.state.pos);switch(++this.state.pos,s){case 110:return\"\\n\";case 114:return\"\\r\";case 120:{const t=this.readHexChar(2,!1,e);return null===t?null:String.fromCharCode(t)}case 117:{const t=this.readCodePoint(e);return null===t?null:String.fromCodePoint(t)}case 116:return\"\\t\";case 98:return\"\\b\";case 118:return\"\\v\";case 102:return\"\\f\";case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:this.state.lineStart=this.state.pos,++this.state.curLine;case 8232:case 8233:return\"\";case 56:case 57:if(t)return null;this.recordStrictModeErrors(this.state.pos-1,b.StrictNumericEscape);default:if(s>=48&&s<=55){const e=this.state.pos-1;let s=this.input.substr(this.state.pos-1,3).match(/^[0-7]+/)[0],i=parseInt(s,8);i>255&&(s=s.slice(0,-1),i=parseInt(s,8)),this.state.pos+=s.length-1;const r=this.input.charCodeAt(this.state.pos);if(\"0\"!==s||56===r||57===r){if(t)return null;this.recordStrictModeErrors(e,b.StrictNumericEscape)}return String.fromCharCode(i)}return String.fromCharCode(s)}}readHexChar(t,e,s){const i=this.state.pos,r=this.readInt(16,t,e,!1);return null===r&&(s?this.raise(i,b.InvalidEscapeSequence):this.state.pos=i-1),r}readWord1(){let t=\"\";this.state.containsEsc=!1;const e=this.state.pos;let s=this.state.pos;for(;this.state.pos<this.length;){const i=this.input.codePointAt(this.state.pos);if(L(i))this.state.pos+=i<=65535?1:2;else if(this.state.isIterator&&64===i)++this.state.pos;else{if(92!==i)break;{this.state.containsEsc=!0,t+=this.input.slice(s,this.state.pos);const i=this.state.pos,r=this.state.pos===e?v:L;if(117!==this.input.charCodeAt(++this.state.pos)){this.raise(this.state.pos,b.MissingUnicodeEscape);continue}++this.state.pos;const a=this.readCodePoint(!0);null!==a&&(r(a)||this.raise(i,b.EscapedCharNotAnIdentifier),t+=String.fromCodePoint(a)),s=this.state.pos}}}return t+this.input.slice(s,this.state.pos)}isIterator(t){return\"@@iterator\"===t||\"@@asyncIterator\"===t}readWord(){const t=this.readWord1(),e=h.get(t)||l.name;!this.state.isIterator||this.isIterator(t)&&this.state.inType||this.raise(this.state.pos,b.InvalidIdentifier,t),this.finishToken(e,t)}checkKeywordEscapes(){const t=this.state.type.keyword;t&&this.state.containsEsc&&this.raise(this.state.start,b.InvalidEscapedReservedWord,t)}braceIsBlock(t){const e=this.curContext();return e===A.functionExpression||e===A.functionStatement||(t!==l.colon||e!==A.braceStatement&&e!==A.braceExpression?t===l._return||t===l.name&&this.state.exprAllowed?this.hasPrecedingLineBreak():t===l._else||t===l.semi||t===l.eof||t===l.parenR||t===l.arrow||(t===l.braceL?e===A.braceStatement:t!==l._var&&t!==l._const&&t!==l.name&&(t===l.relational||!this.state.exprAllowed)):!e.isExpr)}updateContext(t){const e=this.state.type;let s;!e.keyword||t!==l.dot&&t!==l.questionDot?(s=e.updateContext)?s.call(this,t):this.state.exprAllowed=e.beforeExpr:this.state.exprAllowed=!1}}{addExtra(t,e,s){if(!t)return;(t.extra=t.extra||{})[e]=s}isRelational(t){return this.match(l.relational)&&this.state.value===t}expectRelational(t){this.isRelational(t)?this.next():this.unexpected(null,l.relational)}isContextual(t){return this.match(l.name)&&this.state.value===t&&!this.state.containsEsc}isUnparsedContextual(t,e){const s=t+e.length;return this.input.slice(t,s)===e&&(s===this.input.length||!L(this.input.charCodeAt(s)))}isLookaheadContextual(t){const e=this.nextTokenStart();return this.isUnparsedContextual(e,t)}eatContextual(t){return this.isContextual(t)&&this.eat(l.name)}expectContextual(t,e){this.eatContextual(t)||this.unexpected(null,e)}canInsertSemicolon(){return this.match(l.eof)||this.match(l.braceR)||this.hasPrecedingLineBreak()}hasPrecedingLineBreak(){return u.test(this.input.slice(this.state.lastTokEnd,this.state.start))}isLineTerminator(){return this.eat(l.semi)||this.canInsertSemicolon()}semicolon(){this.isLineTerminator()||this.unexpected(null,l.semi)}expect(t,e){this.eat(t)||this.unexpected(e,t)}assertNoSpace(t=\"Unexpected space.\"){this.state.start>this.state.lastTokEnd&&this.raise(this.state.lastTokEnd,t)}unexpected(t,e=\"Unexpected token\"){throw\"string\"!==typeof e&&(e=`Unexpected token, expected \"${e.label}\"`),this.raise(null!=t?t:this.state.start,e)}expectPlugin(t,e){if(!this.hasPlugin(t))throw this.raiseWithData(null!=e?e:this.state.start,{missingPlugin:[t]},`This experimental syntax requires enabling the parser plugin: '${t}'`);return!0}expectOnePlugin(t,e){if(!t.some((t=>this.hasPlugin(t))))throw this.raiseWithData(null!=e?e:this.state.start,{missingPlugin:t},`This experimental syntax requires enabling one of the following parser plugin(s): '${t.join(\", \")}'`)}tryParse(t,e=this.state.clone()){const s={node:null};try{const i=t(((t=null)=>{throw s.node=t,s}));if(this.state.errors.length>e.errors.length){const t=this.state;return this.state=e,{node:i,error:t.errors[e.errors.length],thrown:!1,aborted:!1,failState:t}}return{node:i,error:null,thrown:!1,aborted:!1,failState:null}}catch(i){const t=this.state;if(this.state=e,i instanceof SyntaxError)return{node:null,error:i,thrown:!0,aborted:!1,failState:t};if(i===s)return{node:s.node,error:null,thrown:!1,aborted:!0,failState:t};throw i}}checkExpressionErrors(t,e){if(!t)return!1;const{shorthandAssign:s,doubleProto:i}=t;if(!e)return s>=0||i>=0;s>=0&&this.unexpected(s),i>=0&&this.raise(i,b.DuplicateProto)}isLiteralPropertyName(){return this.match(l.name)||!!this.state.type.keyword||this.match(l.string)||this.match(l.num)||this.match(l.bigint)||this.match(l.decimal)}isPrivateName(t){return\"PrivateName\"===t.type}getPrivateNameSV(t){return t.id.name}hasPropertyAsPrivateName(t){return(\"MemberExpression\"===t.type||\"OptionalMemberExpression\"===t.type)&&this.isPrivateName(t.property)}isOptionalChain(t){return\"OptionalMemberExpression\"===t.type||\"OptionalCallExpression\"===t.type}isObjectProperty(t){return\"ObjectProperty\"===t.type}isObjectMethod(t){return\"ObjectMethod\"===t.type}}{startNode(){return new Nt(this,this.state.start,this.state.startLoc)}startNodeAt(t,e){return new Nt(this,t,e)}startNodeAtNode(t){return this.startNodeAt(t.start,t.loc.start)}finishNode(t,e){return this.finishNodeAt(t,e,this.state.lastTokEnd,this.state.lastTokEndLoc)}finishNodeAt(t,e,s,i){return t.type=e,t.end=s,t.loc.end=i,this.options.ranges&&(t.range[1]=s),this.processComment(t),t}resetStartLocation(t,e,s){t.start=e,t.loc.start=s,this.options.ranges&&(t.range[0]=e)}resetEndLocation(t,e=this.state.lastTokEnd,s=this.state.lastTokEndLoc){t.end=e,t.loc.end=s,this.options.ranges&&(t.range[1]=e)}resetStartLocationFromNode(t,e){this.resetStartLocation(t,e.start,e.loc.start)}}{toAssignable(t,e=!1){var s,i;let r;switch((\"ParenthesizedExpression\"===t.type||(null==(s=t.extra)?void 0:s.parenthesized))&&(r=kt(t),e?\"Identifier\"===r.type?this.expressionScope.recordParenthesizedIdentifierError(t.start,b.InvalidParenthesizedAssignment):\"MemberExpression\"!==r.type&&this.raise(t.start,b.InvalidParenthesizedAssignment):this.raise(t.start,b.InvalidParenthesizedAssignment)),t.type){case\"Identifier\":case\"ObjectPattern\":case\"ArrayPattern\":case\"AssignmentPattern\":break;case\"ObjectExpression\":t.type=\"ObjectPattern\";for(let s=0,i=t.properties.length,r=i-1;s<i;s++){var a;const i=t.properties[s],n=s===r;this.toAssignableObjectExpressionProp(i,n,e),n&&\"RestElement\"===i.type&&(null==(a=t.extra)?void 0:a.trailingComma)&&this.raiseRestNotLast(t.extra.trailingComma)}break;case\"ObjectProperty\":this.toAssignable(t.value,e);break;case\"SpreadElement\":{this.checkToRestConversion(t),t.type=\"RestElement\";const s=t.argument;this.toAssignable(s,e);break}case\"ArrayExpression\":t.type=\"ArrayPattern\",this.toAssignableList(t.elements,null==(i=t.extra)?void 0:i.trailingComma,e);break;case\"AssignmentExpression\":\"=\"!==t.operator&&this.raise(t.left.end,b.MissingEqInAssignment),t.type=\"AssignmentPattern\",delete t.operator,this.toAssignable(t.left,e);break;case\"ParenthesizedExpression\":this.toAssignable(r,e)}return t}toAssignableObjectExpressionProp(t,e,s){if(\"ObjectMethod\"===t.type){const e=\"get\"===t.kind||\"set\"===t.kind?b.PatternHasAccessor:b.PatternHasMethod;this.raise(t.key.start,e)}else\"SpreadElement\"!==t.type||e?this.toAssignable(t,s):this.raiseRestNotLast(t.start)}toAssignableList(t,e,s){let i=t.length;if(i){const r=t[i-1];if(\"RestElement\"===(null==r?void 0:r.type))--i;else if(\"SpreadElement\"===(null==r?void 0:r.type)){r.type=\"RestElement\";let t=r.argument;this.toAssignable(t,s),t=kt(t),\"Identifier\"!==t.type&&\"MemberExpression\"!==t.type&&\"ArrayPattern\"!==t.type&&\"ObjectPattern\"!==t.type&&this.unexpected(t.start),e&&this.raiseTrailingCommaAfterRest(e),--i}}for(let r=0;r<i;r++){const e=t[r];e&&(this.toAssignable(e,s),\"RestElement\"===e.type&&this.raiseRestNotLast(e.start))}return t}toReferencedList(t,e){return t}toReferencedListDeep(t,e){this.toReferencedList(t,e);for(let s=0;s<t.length;s++){const e=t[s];\"ArrayExpression\"===(null==e?void 0:e.type)&&this.toReferencedListDeep(e.elements)}}parseSpread(t,e){const s=this.startNode();return this.next(),s.argument=this.parseMaybeAssignAllowIn(t,void 0,e),this.finishNode(s,\"SpreadElement\")}parseRestBinding(){const t=this.startNode();return this.next(),t.argument=this.parseBindingAtom(),this.finishNode(t,\"RestElement\")}parseBindingAtom(){switch(this.state.type){case l.bracketL:{const t=this.startNode();return this.next(),t.elements=this.parseBindingList(l.bracketR,93,!0),this.finishNode(t,\"ArrayPattern\")}case l.braceL:return this.parseObjectLike(l.braceR,!0)}return this.parseIdentifier()}parseBindingList(t,e,s,i){const r=[];let a=!0;for(;!this.eat(t);)if(a?a=!1:this.expect(l.comma),s&&this.match(l.comma))r.push(null);else{if(this.eat(t))break;if(this.match(l.ellipsis)){r.push(this.parseAssignableListItemTypes(this.parseRestBinding())),this.checkCommaAfterRest(e),this.expect(t);break}{const t=[];for(this.match(l.at)&&this.hasPlugin(\"decorators\")&&this.raise(this.state.start,b.UnsupportedParameterDecorator);this.match(l.at);)t.push(this.parseDecorator());r.push(this.parseAssignableListItem(i,t))}}return r}parseAssignableListItem(t,e){const s=this.parseMaybeDefault();this.parseAssignableListItemTypes(s);const i=this.parseMaybeDefault(s.start,s.loc.start,s);return e.length&&(s.decorators=e),i}parseAssignableListItemTypes(t){return t}parseMaybeDefault(t,e,s){var i,r,a;if(e=null!=(i=e)?i:this.state.startLoc,t=null!=(r=t)?r:this.state.start,s=null!=(a=s)?a:this.parseBindingAtom(),!this.eat(l.eq))return s;const n=this.startNodeAt(t,e);return n.left=s,n.right=this.parseMaybeAssignAllowIn(),this.finishNode(n,\"AssignmentPattern\")}checkLVal(t,e,s=64,i,r,a=!1){switch(t.type){case\"Identifier\":{const{name:e}=t;this.state.strict&&(a?U(e,this.inModule):j(e))&&this.raise(t.start,64===s?b.StrictEvalArguments:b.StrictEvalArgumentsBinding,e),i&&(i.has(e)?this.raise(t.start,b.ParamDupe):i.add(e)),r&&\"let\"===e&&this.raise(t.start,b.LetInLexicalBinding),64&s||this.scope.declareName(e,s,t.start);break}case\"MemberExpression\":64!==s&&this.raise(t.start,b.InvalidPropertyBindingPattern);break;case\"ObjectPattern\":for(let e=0,a=t.properties;e<a.length;e++){let t=a[e];if(this.isObjectProperty(t))t=t.value;else if(this.isObjectMethod(t))continue;this.checkLVal(t,\"object destructuring pattern\",s,i,r)}break;case\"ArrayPattern\":for(let e=0,a=t.elements;e<a.length;e++){const t=a[e];t&&this.checkLVal(t,\"array destructuring pattern\",s,i,r)}break;case\"AssignmentPattern\":this.checkLVal(t.left,\"assignment pattern\",s,i);break;case\"RestElement\":this.checkLVal(t.argument,\"rest element\",s,i);break;case\"ParenthesizedExpression\":this.checkLVal(t.expression,\"parenthesized expression\",s,i);break;default:this.raise(t.start,64===s?b.InvalidLhs:b.InvalidLhsBinding,e)}}checkToRestConversion(t){\"Identifier\"!==t.argument.type&&\"MemberExpression\"!==t.argument.type&&this.raise(t.argument.start,b.InvalidRestAssignmentPattern)}checkCommaAfterRest(t){this.match(l.comma)&&(this.lookaheadCharCode()===t?this.raiseTrailingCommaAfterRest(this.state.start):this.raiseRestNotLast(this.state.start))}raiseRestNotLast(t){throw this.raise(t,b.ElementAfterRest)}raiseTrailingCommaAfterRest(t){this.raise(t,b.RestTrailingComma)}}{checkProto(t,e,s,i){if(\"SpreadElement\"===t.type||this.isObjectMethod(t)||t.computed||t.shorthand)return;const r=t.key;if(\"__proto__\"===(\"Identifier\"===r.type?r.name:r.value)){if(e)return void this.raise(r.start,b.RecordNoProto);s.used&&(i?-1===i.doubleProto&&(i.doubleProto=r.start):this.raise(r.start,b.DuplicateProto)),s.used=!0}}shouldExitDescending(t,e){return\"ArrowFunctionExpression\"===t.type&&t.start===e}getExpression(){let t=0;this.hasPlugin(\"topLevelAwait\")&&this.inModule&&(t|=2),this.scope.enter(1),this.prodParam.enter(t),this.nextToken();const e=this.parseExpression();return this.match(l.eof)||this.unexpected(),e.comments=this.state.comments,e.errors=this.state.errors,e}parseExpression(t,e){return t?this.disallowInAnd((()=>this.parseExpressionBase(e))):this.allowInAnd((()=>this.parseExpressionBase(e)))}parseExpressionBase(t){const e=this.state.start,s=this.state.startLoc,i=this.parseMaybeAssign(t);if(this.match(l.comma)){const r=this.startNodeAt(e,s);for(r.expressions=[i];this.eat(l.comma);)r.expressions.push(this.parseMaybeAssign(t));return this.toReferencedList(r.expressions),this.finishNode(r,\"SequenceExpression\")}return i}parseMaybeAssignDisallowIn(t,e,s){return this.disallowInAnd((()=>this.parseMaybeAssign(t,e,s)))}parseMaybeAssignAllowIn(t,e,s){return this.allowInAnd((()=>this.parseMaybeAssign(t,e,s)))}parseMaybeAssign(t,e,s){const i=this.state.start,r=this.state.startLoc;if(this.isContextual(\"yield\")&&this.prodParam.hasYield){this.state.exprAllowed=!0;let t=this.parseYield();return e&&(t=e.call(this,t,i,r)),t}let a;t?a=!1:(t=new Ct,a=!0),(this.match(l.parenL)||this.match(l.name))&&(this.state.potentialArrowAt=this.state.start);let n=this.parseMaybeConditional(t,s);if(e&&(n=e.call(this,n,i,r)),this.state.type.isAssign){const e=this.startNodeAt(i,r),s=this.state.value;return e.operator=s,this.match(l.eq)?(e.left=this.toAssignable(n,!0),t.doubleProto=-1):e.left=n,t.shorthandAssign>=e.left.start&&(t.shorthandAssign=-1),this.checkLVal(n,\"assignment expression\"),this.next(),e.right=this.parseMaybeAssign(),this.finishNode(e,\"AssignmentExpression\")}return a&&this.checkExpressionErrors(t,!0),n}parseMaybeConditional(t,e){const s=this.state.start,i=this.state.startLoc,r=this.state.potentialArrowAt,a=this.parseExprOps(t);return this.shouldExitDescending(a,r)?a:this.parseConditional(a,s,i,e)}parseConditional(t,e,s,i){if(this.eat(l.question)){const i=this.startNodeAt(e,s);return i.test=t,i.consequent=this.parseMaybeAssignAllowIn(),this.expect(l.colon),i.alternate=this.parseMaybeAssign(),this.finishNode(i,\"ConditionalExpression\")}return t}parseExprOps(t){const e=this.state.start,s=this.state.startLoc,i=this.state.potentialArrowAt,r=this.parseMaybeUnary(t);return this.shouldExitDescending(r,i)?r:this.parseExprOp(r,e,s,-1)}parseExprOp(t,e,s,i){let r=this.state.type.binop;if(null!=r&&(this.prodParam.hasIn||!this.match(l._in))&&r>i){const a=this.state.type;if(a===l.pipeline){if(this.expectPlugin(\"pipelineOperator\"),this.state.inFSharpPipelineDirectBody)return t;this.state.inPipeline=!0,this.checkPipelineAtInfixOperator(t,e)}const n=this.startNodeAt(e,s);n.left=t,n.operator=this.state.value,a!==l.exponent||\"UnaryExpression\"!==t.type||!this.options.createParenthesizedExpressions&&t.extra&&t.extra.parenthesized||this.raise(t.argument.start,b.UnexpectedTokenUnaryExponentiation);const o=a===l.logicalOR||a===l.logicalAND,h=a===l.nullishCoalescing;if(h&&(r=l.logicalAND.binop),this.next(),a===l.pipeline&&\"minimal\"===this.getPluginOption(\"pipelineOperator\",\"proposal\")&&this.match(l.name)&&\"await\"===this.state.value&&this.prodParam.hasAwait)throw this.raise(this.state.start,b.UnexpectedAwaitAfterPipelineBody);n.right=this.parseExprOpRightExpr(a,r),this.finishNode(n,o||h?\"LogicalExpression\":\"BinaryExpression\");const p=this.state.type;if(h&&(p===l.logicalOR||p===l.logicalAND)||o&&p===l.nullishCoalescing)throw this.raise(this.state.start,b.MixingCoalesceWithLogical);return this.parseExprOp(n,e,s,i)}return t}parseExprOpRightExpr(t,e){const s=this.state.start,i=this.state.startLoc;switch(t){case l.pipeline:switch(this.getPluginOption(\"pipelineOperator\",\"proposal\")){case\"smart\":return this.withTopicPermittingContext((()=>this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(t,e),s,i)));case\"fsharp\":return this.withSoloAwaitPermittingContext((()=>this.parseFSharpPipelineBody(e)))}default:return this.parseExprOpBaseRightExpr(t,e)}}parseExprOpBaseRightExpr(t,e){const s=this.state.start,i=this.state.startLoc;return this.parseExprOp(this.parseMaybeUnary(),s,i,t.rightAssociative?e-1:e)}parseMaybeUnary(t){if(this.isContextual(\"await\")&&this.isAwaitAllowed())return this.parseAwait();const e=this.match(l.incDec),s=this.startNode();if(this.state.type.prefix){s.operator=this.state.value,s.prefix=!0,this.match(l._throw)&&this.expectPlugin(\"throwExpressions\");const i=this.match(l._delete);if(this.next(),s.argument=this.parseMaybeUnary(),this.checkExpressionErrors(t,!0),this.state.strict&&i){const t=s.argument;\"Identifier\"===t.type?this.raise(s.start,b.StrictDelete):this.hasPropertyAsPrivateName(t)&&this.raise(s.start,b.DeletePrivateField)}if(!e)return this.finishNode(s,\"UnaryExpression\")}return this.parseUpdate(s,e,t)}parseUpdate(t,e,s){if(e)return this.checkLVal(t.argument,\"prefix operation\"),this.finishNode(t,\"UpdateExpression\");const i=this.state.start,r=this.state.startLoc;let a=this.parseExprSubscripts(s);if(this.checkExpressionErrors(s,!1))return a;for(;this.state.type.postfix&&!this.canInsertSemicolon();){const t=this.startNodeAt(i,r);t.operator=this.state.value,t.prefix=!1,t.argument=a,this.checkLVal(a,\"postfix operation\"),this.next(),a=this.finishNode(t,\"UpdateExpression\")}return a}parseExprSubscripts(t){const e=this.state.start,s=this.state.startLoc,i=this.state.potentialArrowAt,r=this.parseExprAtom(t);return this.shouldExitDescending(r,i)?r:this.parseSubscripts(r,e,s)}parseSubscripts(t,e,s,i){const r={optionalChainMember:!1,maybeAsyncArrow:this.atPossibleAsyncArrow(t),stop:!1};do{t=this.parseSubscript(t,e,s,i,r),r.maybeAsyncArrow=!1}while(!r.stop);return t}parseSubscript(t,e,s,i,r){if(!i&&this.eat(l.doubleColon))return this.parseBind(t,e,s,i,r);if(this.match(l.backQuote))return this.parseTaggedTemplateExpression(t,e,s,r);let a=!1;if(this.match(l.questionDot)){if(i&&40===this.lookaheadCharCode())return r.stop=!0,t;r.optionalChainMember=a=!0,this.next()}return!i&&this.match(l.parenL)?this.parseCoverCallAndAsyncArrowHead(t,e,s,r,a):a||this.match(l.bracketL)||this.eat(l.dot)?this.parseMember(t,e,s,r,a):(r.stop=!0,t)}parseMember(t,e,s,i,r){const a=this.startNodeAt(e,s),n=this.eat(l.bracketL);a.object=t,a.computed=n;const o=n?this.parseExpression():this.parseMaybePrivateName(!0);return this.isPrivateName(o)&&(\"Super\"===a.object.type&&this.raise(e,b.SuperPrivateField),this.classScope.usePrivateName(this.getPrivateNameSV(o),o.start)),a.property=o,n&&this.expect(l.bracketR),i.optionalChainMember?(a.optional=r,this.finishNode(a,\"OptionalMemberExpression\")):this.finishNode(a,\"MemberExpression\")}parseBind(t,e,s,i,r){const a=this.startNodeAt(e,s);return a.object=t,a.callee=this.parseNoCallExpr(),r.stop=!0,this.parseSubscripts(this.finishNode(a,\"BindExpression\"),e,s,i)}parseCoverCallAndAsyncArrowHead(t,e,s,i,r){const a=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=!0,this.next();let n=this.startNodeAt(e,s);return n.callee=t,i.maybeAsyncArrow&&this.expressionScope.enter(new vt(2)),i.optionalChainMember&&(n.optional=r),n.arguments=r?this.parseCallExpressionArguments(l.parenR,!1):this.parseCallExpressionArguments(l.parenR,i.maybeAsyncArrow,\"Import\"===t.type,\"Super\"!==t.type,n),this.finishCallExpression(n,i.optionalChainMember),i.maybeAsyncArrow&&this.shouldParseAsyncArrow()&&!r?(i.stop=!0,this.expressionScope.validateAsPattern(),this.expressionScope.exit(),n=this.parseAsyncArrowFromCallExpression(this.startNodeAt(e,s),n)):(i.maybeAsyncArrow&&this.expressionScope.exit(),this.toReferencedArguments(n)),this.state.maybeInArrowParameters=a,n}toReferencedArguments(t,e){this.toReferencedListDeep(t.arguments,e)}parseTaggedTemplateExpression(t,e,s,i){const r=this.startNodeAt(e,s);return r.tag=t,r.quasi=this.parseTemplate(!0),i.optionalChainMember&&this.raise(e,b.OptionalChainingNoTemplate),this.finishNode(r,\"TaggedTemplateExpression\")}atPossibleAsyncArrow(t){return\"Identifier\"===t.type&&\"async\"===t.name&&this.state.lastTokEnd===t.end&&!this.canInsertSemicolon()&&t.end-t.start===5&&t.start===this.state.potentialArrowAt}finishCallExpression(t,e){if(\"Import\"===t.callee.type)if(2===t.arguments.length&&(this.hasPlugin(\"moduleAttributes\")||this.expectPlugin(\"importAssertions\")),0===t.arguments.length||t.arguments.length>2)this.raise(t.start,b.ImportCallArity,this.hasPlugin(\"importAssertions\")||this.hasPlugin(\"moduleAttributes\")?\"one or two arguments\":\"one argument\");else for(let s=0,i=t.arguments;s<i.length;s++){const t=i[s];\"SpreadElement\"===t.type&&this.raise(t.start,b.ImportCallSpreadArgument)}return this.finishNode(t,e?\"OptionalCallExpression\":\"CallExpression\")}parseCallExpressionArguments(t,e,s,i,r){const a=[];let n=!0;const o=this.state.inFSharpPipelineDirectBody;for(this.state.inFSharpPipelineDirectBody=!1;!this.eat(t);){if(n)n=!1;else if(this.expect(l.comma),this.match(t)){!s||this.hasPlugin(\"importAssertions\")||this.hasPlugin(\"moduleAttributes\")||this.raise(this.state.lastTokStart,b.ImportCallArgumentTrailingComma),r&&this.addExtra(r,\"trailingComma\",this.state.lastTokStart),this.next();break}a.push(this.parseExprListItem(!1,e?new Ct:void 0,e?{start:0}:void 0,i))}return this.state.inFSharpPipelineDirectBody=o,a}shouldParseAsyncArrow(){return this.match(l.arrow)&&!this.canInsertSemicolon()}parseAsyncArrowFromCallExpression(t,e){var s;return this.expect(l.arrow),this.parseArrowExpression(t,e.arguments,!0,null==(s=e.extra)?void 0:s.trailingComma),t}parseNoCallExpr(){const t=this.state.start,e=this.state.startLoc;return this.parseSubscripts(this.parseExprAtom(),t,e,!0)}parseExprAtom(t){this.state.type===l.slash&&this.readRegexp();const e=this.state.potentialArrowAt===this.state.start;let s;switch(this.state.type){case l._super:return this.parseSuper();case l._import:return s=this.startNode(),this.next(),this.match(l.dot)?this.parseImportMetaProperty(s):(this.match(l.parenL)||this.raise(this.state.lastTokStart,b.UnsupportedImport),this.finishNode(s,\"Import\"));case l._this:return s=this.startNode(),this.next(),this.finishNode(s,\"ThisExpression\");case l.name:{const t=this.state.containsEsc,s=this.parseIdentifier();if(!t&&\"async\"===s.name&&!this.canInsertSemicolon()){if(this.match(l._function)){const t=this.state.context.length-1;if(this.state.context[t]!==A.functionStatement)throw new Error(\"Internal error\");return this.state.context[t]=A.functionExpression,this.next(),this.parseFunction(this.startNodeAtNode(s),void 0,!0)}if(this.match(l.name))return this.parseAsyncArrowUnaryFunction(s)}return e&&this.match(l.arrow)&&!this.canInsertSemicolon()?(this.next(),this.parseArrowExpression(this.startNodeAtNode(s),[s],!1)):s}case l._do:return this.parseDo();case l.regexp:{const t=this.state.value;return s=this.parseLiteral(t.value,\"RegExpLiteral\"),s.pattern=t.pattern,s.flags=t.flags,s}case l.num:return this.parseLiteral(this.state.value,\"NumericLiteral\");case l.bigint:return this.parseLiteral(this.state.value,\"BigIntLiteral\");case l.decimal:return this.parseLiteral(this.state.value,\"DecimalLiteral\");case l.string:return this.parseLiteral(this.state.value,\"StringLiteral\");case l._null:return s=this.startNode(),this.next(),this.finishNode(s,\"NullLiteral\");case l._true:case l._false:return this.parseBooleanLiteral();case l.parenL:return this.parseParenAndDistinguishExpression(e);case l.bracketBarL:case l.bracketHashL:return this.parseArrayLike(this.state.type===l.bracketBarL?l.bracketBarR:l.bracketR,!1,!0,t);case l.bracketL:return this.parseArrayLike(l.bracketR,!0,!1,t);case l.braceBarL:case l.braceHashL:return this.parseObjectLike(this.state.type===l.braceBarL?l.braceBarR:l.braceR,!1,!0,t);case l.braceL:return this.parseObjectLike(l.braceR,!1,!1,t);case l._function:return this.parseFunctionOrFunctionSent();case l.at:this.parseDecorators();case l._class:return s=this.startNode(),this.takeDecorators(s),this.parseClass(s,!1);case l._new:return this.parseNewOrNewTarget();case l.backQuote:return this.parseTemplate(!1);case l.doubleColon:{s=this.startNode(),this.next(),s.object=null;const t=s.callee=this.parseNoCallExpr();if(\"MemberExpression\"===t.type)return this.finishNode(s,\"BindExpression\");throw this.raise(t.start,b.UnsupportedBind)}case l.hash:{if(this.state.inPipeline)return s=this.startNode(),\"smart\"!==this.getPluginOption(\"pipelineOperator\",\"proposal\")&&this.raise(s.start,b.PrimaryTopicRequiresSmartPipeline),this.next(),this.primaryTopicReferenceIsAllowedInCurrentTopicContext()||this.raise(s.start,b.PrimaryTopicNotAllowed),this.registerTopicReference(),this.finishNode(s,\"PipelinePrimaryTopicReference\");const t=this.input.codePointAt(this.state.end);if(v(t)||92===t){const t=this.state.start;if(s=this.parseMaybePrivateName(!0),this.match(l._in))this.expectPlugin(\"privateIn\"),this.classScope.usePrivateName(s.id.name,s.start);else{if(!this.hasPlugin(\"privateIn\"))throw this.unexpected(t);this.raise(this.state.start,b.PrivateInExpectedIn,s.id.name)}return s}}case l.relational:if(\"<\"===this.state.value){const t=this.input.codePointAt(this.nextTokenStart());(v(t)||62===t)&&this.expectOnePlugin([\"jsx\",\"flow\",\"typescript\"])}default:throw this.unexpected()}}parseAsyncArrowUnaryFunction(t){const e=this.startNodeAtNode(t);this.prodParam.enter(pt(!0,this.prodParam.hasYield));const s=[this.parseIdentifier()];return this.prodParam.exit(),this.hasPrecedingLineBreak()&&this.raise(this.state.pos,b.LineTerminatorBeforeArrow),this.expect(l.arrow),this.parseArrowExpression(e,s,!0),e}parseDo(){this.expectPlugin(\"doExpressions\");const t=this.startNode();this.next();const e=this.state.labels;return this.state.labels=[],t.body=this.parseBlock(),this.state.labels=e,this.finishNode(t,\"DoExpression\")}parseSuper(){const t=this.startNode();return this.next(),!this.match(l.parenL)||this.scope.allowDirectSuper||this.options.allowSuperOutsideMethod?this.scope.allowSuper||this.options.allowSuperOutsideMethod||this.raise(t.start,b.UnexpectedSuper):this.raise(t.start,b.SuperNotAllowed),this.match(l.parenL)||this.match(l.bracketL)||this.match(l.dot)||this.raise(t.start,b.UnsupportedSuper),this.finishNode(t,\"Super\")}parseBooleanLiteral(){const t=this.startNode();return t.value=this.match(l._true),this.next(),this.finishNode(t,\"BooleanLiteral\")}parseMaybePrivateName(t){if(this.match(l.hash)){this.expectOnePlugin([\"classPrivateProperties\",\"classPrivateMethods\"]),t||this.raise(this.state.pos,b.UnexpectedPrivateField);const e=this.startNode();return this.next(),this.assertNoSpace(\"Unexpected space between # and identifier\"),e.id=this.parseIdentifier(!0),this.finishNode(e,\"PrivateName\")}return this.parseIdentifier(!0)}parseFunctionOrFunctionSent(){const t=this.startNode();if(this.next(),this.prodParam.hasYield&&this.match(l.dot)){const e=this.createIdentifier(this.startNodeAtNode(t),\"function\");return this.next(),this.parseMetaProperty(t,e,\"sent\")}return this.parseFunction(t)}parseMetaProperty(t,e,s){t.meta=e,\"function\"===e.name&&\"sent\"===s&&(this.isContextual(s)?this.expectPlugin(\"functionSent\"):this.hasPlugin(\"functionSent\")||this.unexpected());const i=this.state.containsEsc;return t.property=this.parseIdentifier(!0),(t.property.name!==s||i)&&this.raise(t.property.start,b.UnsupportedMetaProperty,e.name,s),this.finishNode(t,\"MetaProperty\")}parseImportMetaProperty(t){const e=this.createIdentifier(this.startNodeAtNode(t),\"import\");return this.next(),this.isContextual(\"meta\")&&(this.inModule||this.raiseWithData(e.start,{code:\"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"},b.ImportMetaOutsideModule),this.sawUnambiguousESM=!0),this.parseMetaProperty(t,e,\"meta\")}parseLiteral(t,e,s,i){s=s||this.state.start,i=i||this.state.startLoc;const r=this.startNodeAt(s,i);return this.addExtra(r,\"rawValue\",t),this.addExtra(r,\"raw\",this.input.slice(s,this.state.end)),r.value=t,this.next(),this.finishNode(r,e)}parseParenAndDistinguishExpression(t){const e=this.state.start,s=this.state.startLoc;let i;this.next(),this.expressionScope.enter(new vt(1));const r=this.state.maybeInArrowParameters,a=this.state.inFSharpPipelineDirectBody;this.state.maybeInArrowParameters=!0,this.state.inFSharpPipelineDirectBody=!1;const n=this.state.start,o=this.state.startLoc,h=[],p=new Ct,c={start:0};let u,d,m=!0;for(;!this.match(l.parenR);){if(m)m=!1;else if(this.expect(l.comma,c.start||null),this.match(l.parenR)){d=this.state.start;break}if(this.match(l.ellipsis)){const t=this.state.start,e=this.state.startLoc;u=this.state.start,h.push(this.parseParenItem(this.parseRestBinding(),t,e)),this.checkCommaAfterRest(41);break}h.push(this.parseMaybeAssignAllowIn(p,this.parseParenItem,c))}const f=this.state.lastTokEnd,y=this.state.lastTokEndLoc;this.expect(l.parenR),this.state.maybeInArrowParameters=r,this.state.inFSharpPipelineDirectBody=a;let x=this.startNodeAt(e,s);if(t&&this.shouldParseArrow()&&(x=this.parseArrow(x)))return this.expressionScope.validateAsPattern(),this.expressionScope.exit(),this.parseArrowExpression(x,h,!1),x;if(this.expressionScope.exit(),h.length||this.unexpected(this.state.lastTokStart),d&&this.unexpected(d),u&&this.unexpected(u),this.checkExpressionErrors(p,!0),c.start&&this.unexpected(c.start),this.toReferencedListDeep(h,!0),h.length>1?(i=this.startNodeAt(n,o),i.expressions=h,this.finishNodeAt(i,\"SequenceExpression\",f,y)):i=h[0],!this.options.createParenthesizedExpressions)return this.addExtra(i,\"parenthesized\",!0),this.addExtra(i,\"parenStart\",e),i;const P=this.startNodeAt(e,s);return P.expression=i,this.finishNode(P,\"ParenthesizedExpression\"),P}shouldParseArrow(){return!this.canInsertSemicolon()}parseArrow(t){if(this.eat(l.arrow))return t}parseParenItem(t,e,s){return t}parseNewOrNewTarget(){const t=this.startNode();if(this.next(),this.match(l.dot)){const e=this.createIdentifier(this.startNodeAtNode(t),\"new\");this.next();const s=this.parseMetaProperty(t,e,\"target\");if(!this.scope.inNonArrowFunction&&!this.scope.inClass){let t=b.UnexpectedNewTarget;this.hasPlugin(\"classProperties\")&&(t+=\" or class properties\"),this.raise(s.start,t)}return s}return this.parseNew(t)}parseNew(t){return t.callee=this.parseNoCallExpr(),\"Import\"===t.callee.type?this.raise(t.callee.start,b.ImportCallNotNewExpression):this.isOptionalChain(t.callee)?this.raise(this.state.lastTokEnd,b.OptionalChainingNoNew):this.eat(l.questionDot)&&this.raise(this.state.start,b.OptionalChainingNoNew),this.parseNewArguments(t),this.finishNode(t,\"NewExpression\")}parseNewArguments(t){if(this.eat(l.parenL)){const e=this.parseExprList(l.parenR);this.toReferencedList(e),t.arguments=e}else t.arguments=[]}parseTemplateElement(t){const e=this.startNode();return null===this.state.value&&(t||this.raise(this.state.start+1,b.InvalidEscapeSequenceTemplate)),e.value={raw:this.input.slice(this.state.start,this.state.end).replace(/\\r\\n?/g,\"\\n\"),cooked:this.state.value},this.next(),e.tail=this.match(l.backQuote),this.finishNode(e,\"TemplateElement\")}parseTemplate(t){const e=this.startNode();this.next(),e.expressions=[];let s=this.parseTemplateElement(t);for(e.quasis=[s];!s.tail;)this.expect(l.dollarBraceL),e.expressions.push(this.parseTemplateSubstitution()),this.expect(l.braceR),e.quasis.push(s=this.parseTemplateElement(t));return this.next(),this.finishNode(e,\"TemplateLiteral\")}parseTemplateSubstitution(){return this.parseExpression()}parseObjectLike(t,e,s,i){s&&this.expectPlugin(\"recordAndTuple\");const r=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!1;const a=Object.create(null);let n=!0;const o=this.startNode();for(o.properties=[],this.next();!this.match(t);){if(n)n=!1;else if(this.expect(l.comma),this.match(t)){this.addExtra(o,\"trailingComma\",this.state.lastTokStart);break}const r=this.parsePropertyDefinition(e,i);e||this.checkProto(r,s,a,i),s&&!this.isObjectProperty(r)&&\"SpreadElement\"!==r.type&&this.raise(r.start,b.InvalidRecordProperty),r.shorthand&&this.addExtra(r,\"shorthand\",!0),o.properties.push(r)}this.state.exprAllowed=!1,this.next(),this.state.inFSharpPipelineDirectBody=r;let h=\"ObjectExpression\";return e?h=\"ObjectPattern\":s&&(h=\"RecordExpression\"),this.finishNode(o,h)}maybeAsyncOrAccessorProp(t){return!t.computed&&\"Identifier\"===t.key.type&&(this.isLiteralPropertyName()||this.match(l.bracketL)||this.match(l.star))}parsePropertyDefinition(t,e){let s=[];if(this.match(l.at))for(this.hasPlugin(\"decorators\")&&this.raise(this.state.start,b.UnsupportedPropertyDecorator);this.match(l.at);)s.push(this.parseDecorator());const i=this.startNode();let r,a,n=!1,o=!1,h=!1;if(this.match(l.ellipsis))return s.length&&this.unexpected(),t?(this.next(),i.argument=this.parseIdentifier(),this.checkCommaAfterRest(125),this.finishNode(i,\"RestElement\")):this.parseSpread();s.length&&(i.decorators=s,s=[]),i.method=!1,(t||e)&&(r=this.state.start,a=this.state.startLoc),t||(n=this.eat(l.star));const p=this.state.containsEsc,c=this.parsePropertyName(i,!1);if(!t&&!n&&!p&&this.maybeAsyncOrAccessorProp(i)){const t=c.name;\"async\"!==t||this.hasPrecedingLineBreak()||(o=!0,n=this.eat(l.star),this.parsePropertyName(i,!1)),\"get\"!==t&&\"set\"!==t||(h=!0,i.kind=t,this.match(l.star)&&(n=!0,this.raise(this.state.pos,b.AccessorIsGenerator,t),this.next()),this.parsePropertyName(i,!1))}return this.parseObjPropValue(i,r,a,n,o,t,h,e),i}getGetterSetterExpectedParamCount(t){return\"get\"===t.kind?0:1}getObjectOrClassMethodParams(t){return t.params}checkGetterSetterParams(t){var e;const s=this.getGetterSetterExpectedParamCount(t),i=this.getObjectOrClassMethodParams(t),r=t.start;i.length!==s&&(\"get\"===t.kind?this.raise(r,b.BadGetterArity):this.raise(r,b.BadSetterArity)),\"set\"===t.kind&&\"RestElement\"===(null==(e=i[i.length-1])?void 0:e.type)&&this.raise(r,b.BadSetterRestParameter)}parseObjectMethod(t,e,s,i,r){return r?(this.parseMethod(t,e,!1,!1,!1,\"ObjectMethod\"),this.checkGetterSetterParams(t),t):s||e||this.match(l.parenL)?(i&&this.unexpected(),t.kind=\"method\",t.method=!0,this.parseMethod(t,e,s,!1,!1,\"ObjectMethod\")):void 0}parseObjectProperty(t,e,s,i,r){return t.shorthand=!1,this.eat(l.colon)?(t.value=i?this.parseMaybeDefault(this.state.start,this.state.startLoc):this.parseMaybeAssignAllowIn(r),this.finishNode(t,\"ObjectProperty\")):t.computed||\"Identifier\"!==t.key.type?void 0:(this.checkReservedWord(t.key.name,t.key.start,!0,!1),i?t.value=this.parseMaybeDefault(e,s,t.key.__clone()):this.match(l.eq)&&r?(-1===r.shorthandAssign&&(r.shorthandAssign=this.state.start),t.value=this.parseMaybeDefault(e,s,t.key.__clone())):t.value=t.key.__clone(),t.shorthand=!0,this.finishNode(t,\"ObjectProperty\"))}parseObjPropValue(t,e,s,i,r,a,n,o){const h=this.parseObjectMethod(t,i,r,a,n)||this.parseObjectProperty(t,e,s,a,o);return h||this.unexpected(),h}parsePropertyName(t,e){if(this.eat(l.bracketL))t.computed=!0,t.key=this.parseMaybeAssignAllowIn(),this.expect(l.bracketR);else{const s=this.state.inPropertyName;this.state.inPropertyName=!0,t.key=this.match(l.num)||this.match(l.string)||this.match(l.bigint)||this.match(l.decimal)?this.parseExprAtom():this.parseMaybePrivateName(e),this.isPrivateName(t.key)||(t.computed=!1),this.state.inPropertyName=s}return t.key}initFunction(t,e){t.id=null,t.generator=!1,t.async=!!e}parseMethod(t,e,s,i,r,a,n=!1){this.initFunction(t,s),t.generator=!!e;const o=i;return this.scope.enter(18|(n?64:0)|(r?32:0)),this.prodParam.enter(pt(s,t.generator)),this.parseFunctionParams(t,o),this.parseFunctionBodyAndFinish(t,a,!0),this.prodParam.exit(),this.scope.exit(),t}parseArrayLike(t,e,s,i){s&&this.expectPlugin(\"recordAndTuple\");const r=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!1;const a=this.startNode();return this.next(),a.elements=this.parseExprList(t,!s,i,a),this.state.inFSharpPipelineDirectBody=r,this.finishNode(a,s?\"TupleExpression\":\"ArrayExpression\")}parseArrowExpression(t,e,s,i){this.scope.enter(6);let r=pt(s,!1);!this.match(l.bracketL)&&this.prodParam.hasIn&&(r|=8),this.prodParam.enter(r),this.initFunction(t,s);const a=this.state.maybeInArrowParameters;return e&&(this.state.maybeInArrowParameters=!0,this.setArrowFunctionParameters(t,e,i)),this.state.maybeInArrowParameters=!1,this.parseFunctionBody(t,!0),this.prodParam.exit(),this.scope.exit(),this.state.maybeInArrowParameters=a,this.finishNode(t,\"ArrowFunctionExpression\")}setArrowFunctionParameters(t,e,s){t.params=this.toAssignableList(e,s,!1)}parseFunctionBodyAndFinish(t,e,s=!1){this.parseFunctionBody(t,!1,s),this.finishNode(t,e)}parseFunctionBody(t,e,s=!1){const i=e&&!this.match(l.braceL);if(this.expressionScope.enter(Dt()),i)t.body=this.parseMaybeAssign(),this.checkParams(t,!1,e,!1);else{const i=this.state.strict,r=this.state.labels;this.state.labels=[],this.prodParam.enter(4|this.prodParam.currentFlags()),t.body=this.parseBlock(!0,!1,(r=>{const a=!this.isSimpleParamList(t.params);if(r&&a){const e=\"method\"!==t.kind&&\"constructor\"!==t.kind||!t.key?t.start:t.key.end;this.raise(e,b.IllegalLanguageModeDirective)}const n=!i&&this.state.strict;this.checkParams(t,!this.state.strict&&!e&&!s&&!a,e,n),this.state.strict&&t.id&&this.checkLVal(t.id,\"function name\",65,void 0,void 0,n)})),this.prodParam.exit(),this.expressionScope.exit(),this.state.labels=r}}isSimpleParamList(t){for(let e=0,s=t.length;e<s;e++)if(\"Identifier\"!==t[e].type)return!1;return!0}checkParams(t,e,s,i=!0){const r=new Set;for(let a=0,n=t.params;a<n.length;a++){const t=n[a];this.checkLVal(t,\"function parameter list\",5,e?null:r,void 0,i)}}parseExprList(t,e,s,i){const r=[];let a=!0;for(;!this.eat(t);){if(a)a=!1;else if(this.expect(l.comma),this.match(t)){i&&this.addExtra(i,\"trailingComma\",this.state.lastTokStart),this.next();break}r.push(this.parseExprListItem(e,s))}return r}parseExprListItem(t,e,s,i){let r;if(this.match(l.comma))t||this.raise(this.state.pos,b.UnexpectedToken,\",\"),r=null;else if(this.match(l.ellipsis)){const t=this.state.start,i=this.state.startLoc;r=this.parseParenItem(this.parseSpread(e,s),t,i)}else if(this.match(l.question)){this.expectPlugin(\"partialApplication\"),i||this.raise(this.state.start,b.UnexpectedArgumentPlaceholder);const t=this.startNode();this.next(),r=this.finishNode(t,\"ArgumentPlaceholder\")}else r=this.parseMaybeAssignAllowIn(e,this.parseParenItem,s);return r}parseIdentifier(t){const e=this.startNode(),s=this.parseIdentifierName(e.start,t);return this.createIdentifier(e,s)}createIdentifier(t,e){return t.name=e,t.loc.identifierName=e,this.finishNode(t,\"Identifier\")}parseIdentifierName(t,e){let s;const{start:i,type:r}=this.state;if(r===l.name)s=this.state.value;else{if(!r.keyword)throw this.unexpected();{s=r.keyword;const t=this.curContext();r!==l._class&&r!==l._function||t!==A.functionStatement&&t!==A.functionExpression||this.state.context.pop()}}return e?this.state.type=l.name:this.checkReservedWord(s,i,!!r.keyword,!1),this.next(),s}checkReservedWord(t,e,s,i){if(this.prodParam.hasYield&&\"yield\"===t)return void this.raise(e,b.YieldBindingIdentifier);if(\"await\"===t){if(this.prodParam.hasAwait)return void this.raise(e,b.AwaitBindingIdentifier);this.expressionScope.recordAsyncArrowParametersError(e,b.AwaitBindingIdentifier)}if(this.scope.inClass&&!this.scope.inNonArrowFunction&&\"arguments\"===t)return void this.raise(e,b.ArgumentsInClass);if(s&&q(t))return void this.raise(e,b.UnexpectedKeyword,t);(this.state.strict?i?U:_:B)(t,this.inModule)&&(this.prodParam.hasAwait||\"await\"!==t?this.raise(e,b.UnexpectedReservedWord,t):this.raise(e,this.hasPlugin(\"topLevelAwait\")?b.AwaitNotInAsyncContext:b.AwaitNotInAsyncFunction))}isAwaitAllowed(){return!!this.prodParam.hasAwait||!(!this.options.allowAwaitOutsideFunction||this.scope.inFunction)}parseAwait(){const t=this.startNode();return this.next(),this.expressionScope.recordParameterInitializerError(t.start,b.AwaitExpressionFormalParameter),this.eat(l.star)&&this.raise(t.start,b.ObsoleteAwaitStar),this.scope.inFunction||this.options.allowAwaitOutsideFunction||(this.hasPrecedingLineBreak()||this.match(l.plusMin)||this.match(l.parenL)||this.match(l.bracketL)||this.match(l.backQuote)||this.match(l.regexp)||this.match(l.slash)||this.hasPlugin(\"v8intrinsic\")&&this.match(l.modulo)?this.ambiguousScriptDifferentAst=!0:this.sawUnambiguousESM=!0),this.state.soloAwait||(t.argument=this.parseMaybeUnary()),this.finishNode(t,\"AwaitExpression\")}parseYield(){const t=this.startNode();return this.expressionScope.recordParameterInitializerError(t.start,b.YieldInParameter),this.next(),this.match(l.semi)||!this.match(l.star)&&!this.state.type.startsExpr||this.hasPrecedingLineBreak()?(t.delegate=!1,t.argument=null):(t.delegate=this.eat(l.star),t.argument=this.parseMaybeAssign()),this.finishNode(t,\"YieldExpression\")}checkPipelineAtInfixOperator(t,e){\"smart\"===this.getPluginOption(\"pipelineOperator\",\"proposal\")&&\"SequenceExpression\"===t.type&&this.raise(e,b.PipelineHeadSequenceExpression)}parseSmartPipelineBody(t,e,s){return this.checkSmartPipelineBodyEarlyErrors(t,e),this.parseSmartPipelineBodyInStyle(t,e,s)}checkSmartPipelineBodyEarlyErrors(t,e){if(this.match(l.arrow))throw this.raise(this.state.start,b.PipelineBodyNoArrow);\"SequenceExpression\"===t.type&&this.raise(e,b.PipelineBodySequenceExpression)}parseSmartPipelineBodyInStyle(t,e,s){const i=this.startNodeAt(e,s),r=this.isSimpleReference(t);return r?i.callee=t:(this.topicReferenceWasUsedInCurrentTopicContext()||this.raise(e,b.PipelineTopicUnused),i.expression=t),this.finishNode(i,r?\"PipelineBareFunction\":\"PipelineTopicExpression\")}isSimpleReference(t){switch(t.type){case\"MemberExpression\":return!t.computed&&this.isSimpleReference(t.object);case\"Identifier\":return!0;default:return!1}}withTopicPermittingContext(t){const e=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:1,maxTopicIndex:null};try{return t()}finally{this.state.topicContext=e}}withTopicForbiddingContext(t){const e=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null};try{return t()}finally{this.state.topicContext=e}}withSoloAwaitPermittingContext(t){const e=this.state.soloAwait;this.state.soloAwait=!0;try{return t()}finally{this.state.soloAwait=e}}allowInAnd(t){const e=this.prodParam.currentFlags();if(8&~e){this.prodParam.enter(8|e);try{return t()}finally{this.prodParam.exit()}}return t()}disallowInAnd(t){const e=this.prodParam.currentFlags();if(8&e){this.prodParam.enter(-9&e);try{return t()}finally{this.prodParam.exit()}}return t()}registerTopicReference(){this.state.topicContext.maxTopicIndex=0}primaryTopicReferenceIsAllowedInCurrentTopicContext(){return this.state.topicContext.maxNumOfResolvableTopics>=1}topicReferenceWasUsedInCurrentTopicContext(){return null!=this.state.topicContext.maxTopicIndex&&this.state.topicContext.maxTopicIndex>=0}parseFSharpPipelineBody(t){const e=this.state.start,s=this.state.startLoc;this.state.potentialArrowAt=this.state.start;const i=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!0;const r=this.parseExprOp(this.parseMaybeUnary(),e,s,t);return this.state.inFSharpPipelineDirectBody=i,r}}{parseTopLevel(t,e){if(e.sourceType=this.options.sourceType,e.interpreter=this.parseInterpreterDirective(),this.parseBlockBody(e,!0,!0,l.eof),this.inModule&&!this.options.allowUndeclaredExports&&this.scope.undefinedExports.size>0)for(let s=0,i=Array.from(this.scope.undefinedExports);s<i.length;s++){const[t]=i[s],e=this.scope.undefinedExports.get(t);this.raise(e,b.ModuleExportUndefined,t)}return t.program=this.finishNode(e,\"Program\"),t.comments=this.state.comments,this.options.tokens&&(t.tokens=this.tokens),this.finishNode(t,\"File\")}stmtToDirective(t){const e=t.expression,s=this.startNodeAt(e.start,e.loc.start),i=this.startNodeAt(t.start,t.loc.start),r=this.input.slice(e.start,e.end),a=s.value=r.slice(1,-1);return this.addExtra(s,\"raw\",r),this.addExtra(s,\"rawValue\",a),i.value=this.finishNodeAt(s,\"DirectiveLiteral\",e.end,e.loc.end),this.finishNodeAt(i,\"Directive\",t.end,t.loc.end)}parseInterpreterDirective(){if(!this.match(l.interpreterDirective))return null;const t=this.startNode();return t.value=this.state.value,this.next(),this.finishNode(t,\"InterpreterDirective\")}isLet(t){if(!this.isContextual(\"let\"))return!1;const e=this.nextTokenStart(),s=this.input.charCodeAt(e);if(91===s)return!0;if(t)return!1;if(123===s)return!0;if(v(s)){let t=e+1;for(;L(this.input.charCodeAt(t));)++t;const s=this.input.slice(e,t);if(!V.test(s))return!0}return!1}parseStatement(t,e){return this.match(l.at)&&this.parseDecorators(!0),this.parseStatementContent(t,e)}parseStatementContent(t,e){let s=this.state.type;const i=this.startNode();let r;switch(this.isLet(t)&&(s=l._var,r=\"let\"),s){case l._break:case l._continue:return this.parseBreakContinueStatement(i,s.keyword);case l._debugger:return this.parseDebuggerStatement(i);case l._do:return this.parseDoStatement(i);case l._for:return this.parseForStatement(i);case l._function:if(46===this.lookaheadCharCode())break;return t&&(this.state.strict?this.raise(this.state.start,b.StrictFunction):\"if\"!==t&&\"label\"!==t&&this.raise(this.state.start,b.SloppyFunction)),this.parseFunctionStatement(i,!1,!t);case l._class:return t&&this.unexpected(),this.parseClass(i,!0);case l._if:return this.parseIfStatement(i);case l._return:return this.parseReturnStatement(i);case l._switch:return this.parseSwitchStatement(i);case l._throw:return this.parseThrowStatement(i);case l._try:return this.parseTryStatement(i);case l._const:case l._var:return r=r||this.state.value,t&&\"var\"!==r&&this.raise(this.state.start,b.UnexpectedLexicalDeclaration),this.parseVarStatement(i,r);case l._while:return this.parseWhileStatement(i);case l._with:return this.parseWithStatement(i);case l.braceL:return this.parseBlock();case l.semi:return this.parseEmptyStatement(i);case l._import:{const t=this.lookaheadCharCode();if(40===t||46===t)break}case l._export:{let t;return this.options.allowImportExportEverywhere||e||this.raise(this.state.start,b.UnexpectedImportExport),this.next(),s===l._import?(t=this.parseImport(i),\"ImportDeclaration\"!==t.type||t.importKind&&\"value\"!==t.importKind||(this.sawUnambiguousESM=!0)):(t=this.parseExport(i),(\"ExportNamedDeclaration\"!==t.type||t.exportKind&&\"value\"!==t.exportKind)&&(\"ExportAllDeclaration\"!==t.type||t.exportKind&&\"value\"!==t.exportKind)&&\"ExportDefaultDeclaration\"!==t.type||(this.sawUnambiguousESM=!0)),this.assertModuleNodeAllowed(i),t}default:if(this.isAsyncFunction())return t&&this.raise(this.state.start,b.AsyncFunctionInSingleStatementContext),this.next(),this.parseFunctionStatement(i,!0,!t)}const a=this.state.value,n=this.parseExpression();return s===l.name&&\"Identifier\"===n.type&&this.eat(l.colon)?this.parseLabeledStatement(i,a,n,t):this.parseExpressionStatement(i,n)}assertModuleNodeAllowed(t){this.options.allowImportExportEverywhere||this.inModule||this.raiseWithData(t.start,{code:\"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"},b.ImportOutsideModule)}takeDecorators(t){const e=this.state.decoratorStack[this.state.decoratorStack.length-1];e.length&&(t.decorators=e,this.resetStartLocationFromNode(t,e[0]),this.state.decoratorStack[this.state.decoratorStack.length-1]=[])}canHaveLeadingDecorator(){return this.match(l._class)}parseDecorators(t){const e=this.state.decoratorStack[this.state.decoratorStack.length-1];for(;this.match(l.at);){const t=this.parseDecorator();e.push(t)}if(this.match(l._export))t||this.unexpected(),this.hasPlugin(\"decorators\")&&!this.getPluginOption(\"decorators\",\"decoratorsBeforeExport\")&&this.raise(this.state.start,b.DecoratorExportClass);else if(!this.canHaveLeadingDecorator())throw this.raise(this.state.start,b.UnexpectedLeadingDecorator)}parseDecorator(){this.expectOnePlugin([\"decorators-legacy\",\"decorators\"]);const t=this.startNode();if(this.next(),this.hasPlugin(\"decorators\")){this.state.decoratorStack.push([]);const e=this.state.start,s=this.state.startLoc;let i;if(this.eat(l.parenL))i=this.parseExpression(),this.expect(l.parenR);else for(i=this.parseIdentifier(!1);this.eat(l.dot);){const t=this.startNodeAt(e,s);t.object=i,t.property=this.parseIdentifier(!0),t.computed=!1,i=this.finishNode(t,\"MemberExpression\")}t.expression=this.parseMaybeDecoratorArguments(i),this.state.decoratorStack.pop()}else t.expression=this.parseExprSubscripts();return this.finishNode(t,\"Decorator\")}parseMaybeDecoratorArguments(t){if(this.eat(l.parenL)){const e=this.startNodeAtNode(t);return e.callee=t,e.arguments=this.parseCallExpressionArguments(l.parenR,!1),this.toReferencedList(e.arguments),this.finishNode(e,\"CallExpression\")}return t}parseBreakContinueStatement(t,e){const s=\"break\"===e;return this.next(),this.isLineTerminator()?t.label=null:(t.label=this.parseIdentifier(),this.semicolon()),this.verifyBreakContinue(t,e),this.finishNode(t,s?\"BreakStatement\":\"ContinueStatement\")}verifyBreakContinue(t,e){const s=\"break\"===e;let i;for(i=0;i<this.state.labels.length;++i){const e=this.state.labels[i];if(null==t.label||e.name===t.label.name){if(null!=e.kind&&(s||\"loop\"===e.kind))break;if(t.label&&s)break}}i===this.state.labels.length&&this.raise(t.start,b.IllegalBreakContinue,e)}parseDebuggerStatement(t){return this.next(),this.semicolon(),this.finishNode(t,\"DebuggerStatement\")}parseHeaderExpression(){this.expect(l.parenL);const t=this.parseExpression();return this.expect(l.parenR),t}parseDoStatement(t){return this.next(),this.state.labels.push(Mt),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"do\"))),this.state.labels.pop(),this.expect(l._while),t.test=this.parseHeaderExpression(),this.eat(l.semi),this.finishNode(t,\"DoWhileStatement\")}parseForStatement(t){this.next(),this.state.labels.push(Mt);let e=-1;if(this.isAwaitAllowed()&&this.eatContextual(\"await\")&&(e=this.state.lastTokStart),this.scope.enter(0),this.expect(l.parenL),this.match(l.semi))return e>-1&&this.unexpected(e),this.parseFor(t,null);const s=this.isLet();if(this.match(l._var)||this.match(l._const)||s){const i=this.startNode(),r=s?\"let\":this.state.value;return this.next(),this.parseVar(i,!0,r),this.finishNode(i,\"VariableDeclaration\"),(this.match(l._in)||this.isContextual(\"of\"))&&1===i.declarations.length?this.parseForIn(t,i,e):(e>-1&&this.unexpected(e),this.parseFor(t,i))}const i=new Ct,r=this.parseExpression(!0,i);if(this.match(l._in)||this.isContextual(\"of\")){this.toAssignable(r,!0);const s=this.isContextual(\"of\")?\"for-of statement\":\"for-in statement\";return this.checkLVal(r,s),this.parseForIn(t,r,e)}return this.checkExpressionErrors(i,!0),e>-1&&this.unexpected(e),this.parseFor(t,r)}parseFunctionStatement(t,e,s){return this.next(),this.parseFunction(t,1|(s?0:2),e)}parseIfStatement(t){return this.next(),t.test=this.parseHeaderExpression(),t.consequent=this.parseStatement(\"if\"),t.alternate=this.eat(l._else)?this.parseStatement(\"if\"):null,this.finishNode(t,\"IfStatement\")}parseReturnStatement(t){return this.prodParam.hasReturn||this.options.allowReturnOutsideFunction||this.raise(this.state.start,b.IllegalReturn),this.next(),this.isLineTerminator()?t.argument=null:(t.argument=this.parseExpression(),this.semicolon()),this.finishNode(t,\"ReturnStatement\")}parseSwitchStatement(t){this.next(),t.discriminant=this.parseHeaderExpression();const e=t.cases=[];let s,i;for(this.expect(l.braceL),this.state.labels.push(Rt),this.scope.enter(0);!this.match(l.braceR);)if(this.match(l._case)||this.match(l._default)){const t=this.match(l._case);s&&this.finishNode(s,\"SwitchCase\"),e.push(s=this.startNode()),s.consequent=[],this.next(),t?s.test=this.parseExpression():(i&&this.raise(this.state.lastTokStart,b.MultipleDefaultsInSwitch),i=!0,s.test=null),this.expect(l.colon)}else s?s.consequent.push(this.parseStatement(null)):this.unexpected();return this.scope.exit(),s&&this.finishNode(s,\"SwitchCase\"),this.next(),this.state.labels.pop(),this.finishNode(t,\"SwitchStatement\")}parseThrowStatement(t){return this.next(),this.hasPrecedingLineBreak()&&this.raise(this.state.lastTokEnd,b.NewlineAfterThrow),t.argument=this.parseExpression(),this.semicolon(),this.finishNode(t,\"ThrowStatement\")}parseCatchClauseParam(){const t=this.parseBindingAtom(),e=\"Identifier\"===t.type;return this.scope.enter(e?8:0),this.checkLVal(t,\"catch clause\",9),t}parseTryStatement(t){if(this.next(),t.block=this.parseBlock(),t.handler=null,this.match(l._catch)){const e=this.startNode();this.next(),this.match(l.parenL)?(this.expect(l.parenL),e.param=this.parseCatchClauseParam(),this.expect(l.parenR)):(e.param=null,this.scope.enter(0)),e.body=this.withTopicForbiddingContext((()=>this.parseBlock(!1,!1))),this.scope.exit(),t.handler=this.finishNode(e,\"CatchClause\")}return t.finalizer=this.eat(l._finally)?this.parseBlock():null,t.handler||t.finalizer||this.raise(t.start,b.NoCatchOrFinally),this.finishNode(t,\"TryStatement\")}parseVarStatement(t,e){return this.next(),this.parseVar(t,!1,e),this.semicolon(),this.finishNode(t,\"VariableDeclaration\")}parseWhileStatement(t){return this.next(),t.test=this.parseHeaderExpression(),this.state.labels.push(Mt),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"while\"))),this.state.labels.pop(),this.finishNode(t,\"WhileStatement\")}parseWithStatement(t){return this.state.strict&&this.raise(this.state.start,b.StrictWith),this.next(),t.object=this.parseHeaderExpression(),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"with\"))),this.finishNode(t,\"WithStatement\")}parseEmptyStatement(t){return this.next(),this.finishNode(t,\"EmptyStatement\")}parseLabeledStatement(t,e,s,i){for(let a=0,n=this.state.labels;a<n.length;a++){n[a].name===e&&this.raise(s.start,b.LabelRedeclaration,e)}const r=this.state.type.isLoop?\"loop\":this.match(l._switch)?\"switch\":null;for(let a=this.state.labels.length-1;a>=0;a--){const e=this.state.labels[a];if(e.statementStart!==t.start)break;e.statementStart=this.state.start,e.kind=r}return this.state.labels.push({name:e,kind:r,statementStart:this.state.start}),t.body=this.parseStatement(i?-1===i.indexOf(\"label\")?i+\"label\":i:\"label\"),this.state.labels.pop(),t.label=s,this.finishNode(t,\"LabeledStatement\")}parseExpressionStatement(t,e){return t.expression=e,this.semicolon(),this.finishNode(t,\"ExpressionStatement\")}parseBlock(t=!1,e=!0,s){const i=this.startNode();return t&&this.state.strictErrors.clear(),this.expect(l.braceL),e&&this.scope.enter(0),this.parseBlockBody(i,t,!1,l.braceR,s),e&&this.scope.exit(),this.finishNode(i,\"BlockStatement\")}isValidDirective(t){return\"ExpressionStatement\"===t.type&&\"StringLiteral\"===t.expression.type&&!t.expression.extra.parenthesized}parseBlockBody(t,e,s,i,r){const a=t.body=[],n=t.directives=[];this.parseBlockOrModuleBlockBody(a,e?n:void 0,s,i,r)}parseBlockOrModuleBlockBody(t,e,s,i,r){const a=this.state.strict;let n=!1,o=!1;for(;!this.match(i);){const i=this.parseStatement(null,s);if(e&&!o){if(this.isValidDirective(i)){const t=this.stmtToDirective(i);e.push(t),n||\"use strict\"!==t.value.value||(n=!0,this.setStrict(!0));continue}o=!0,this.state.strictErrors.clear()}t.push(i)}r&&r.call(this,n),a||this.setStrict(!1),this.next()}parseFor(t,e){return t.init=e,this.expect(l.semi),t.test=this.match(l.semi)?null:this.parseExpression(),this.expect(l.semi),t.update=this.match(l.parenR)?null:this.parseExpression(),this.expect(l.parenR),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"for\"))),this.scope.exit(),this.state.labels.pop(),this.finishNode(t,\"ForStatement\")}parseForIn(t,e,s){const i=this.match(l._in);return this.next(),i?s>-1&&this.unexpected(s):t.await=s>-1,\"VariableDeclaration\"!==e.type||null==e.declarations[0].init||i&&!this.state.strict&&\"var\"===e.kind&&\"Identifier\"===e.declarations[0].id.type?\"AssignmentPattern\"===e.type&&this.raise(e.start,b.InvalidLhs,\"for-loop\"):this.raise(e.start,b.ForInOfLoopInitializer,i?\"for-in\":\"for-of\"),t.left=e,t.right=i?this.parseExpression():this.parseMaybeAssignAllowIn(),this.expect(l.parenR),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"for\"))),this.scope.exit(),this.state.labels.pop(),this.finishNode(t,i?\"ForInStatement\":\"ForOfStatement\")}parseVar(t,e,s){const i=t.declarations=[],r=this.hasPlugin(\"typescript\");for(t.kind=s;;){const t=this.startNode();if(this.parseVarId(t,s),this.eat(l.eq)?t.init=e?this.parseMaybeAssignDisallowIn():this.parseMaybeAssignAllowIn():(\"const\"!==s||this.match(l._in)||this.isContextual(\"of\")?\"Identifier\"===t.id.type||e&&(this.match(l._in)||this.isContextual(\"of\"))||this.raise(this.state.lastTokEnd,b.DeclarationMissingInitializer,\"Complex binding patterns\"):r||this.raise(this.state.lastTokEnd,b.DeclarationMissingInitializer,\"Const declarations\"),t.init=null),i.push(this.finishNode(t,\"VariableDeclarator\")),!this.eat(l.comma))break}return t}parseVarId(t,e){t.id=this.parseBindingAtom(),this.checkLVal(t.id,\"variable declaration\",\"var\"===e?5:9,void 0,\"var\"!==e)}parseFunction(t,e=0,s=!1){const i=1&e,r=2&e,a=!!i&&!(4&e);this.initFunction(t,s),this.match(l.star)&&r&&this.raise(this.state.start,b.GeneratorInSingleStatementContext),t.generator=this.eat(l.star),i&&(t.id=this.parseFunctionId(a));const n=this.state.maybeInArrowParameters;return this.state.maybeInArrowParameters=!1,this.scope.enter(2),this.prodParam.enter(pt(s,t.generator)),i||(t.id=this.parseFunctionId()),this.parseFunctionParams(t,!1),this.withTopicForbiddingContext((()=>{this.parseFunctionBodyAndFinish(t,i?\"FunctionDeclaration\":\"FunctionExpression\")})),this.prodParam.exit(),this.scope.exit(),i&&!r&&this.registerFunctionStatementId(t),this.state.maybeInArrowParameters=n,t}parseFunctionId(t){return t||this.match(l.name)?this.parseIdentifier():null}parseFunctionParams(t,e){this.expect(l.parenL),this.expressionScope.enter(new It(3)),t.params=this.parseBindingList(l.parenR,41,!1,e),this.expressionScope.exit()}registerFunctionStatementId(t){t.id&&this.scope.declareName(t.id.name,this.state.strict||t.generator||t.async?this.scope.treatFunctionsAsVar?5:9:17,t.id.start)}parseClass(t,e,s){this.next(),this.takeDecorators(t);const i=this.state.strict;return this.state.strict=!0,this.parseClassId(t,e,s),this.parseClassSuper(t),t.body=this.parseClassBody(!!t.superClass,i),this.finishNode(t,e?\"ClassDeclaration\":\"ClassExpression\")}isClassProperty(){return this.match(l.eq)||this.match(l.semi)||this.match(l.braceR)}isClassMethod(){return this.match(l.parenL)}isNonstaticConstructor(t){return!t.computed&&!t.static&&(\"constructor\"===t.key.name||\"constructor\"===t.key.value)}parseClassBody(t,e){this.classScope.enter();const s={constructorAllowsSuper:t,hadConstructor:!1,hadStaticBlock:!1};let i=[];const r=this.startNode();if(r.body=[],this.expect(l.braceL),this.withTopicForbiddingContext((()=>{for(;!this.match(l.braceR);){if(this.eat(l.semi)){if(i.length>0)throw this.raise(this.state.lastTokEnd,b.DecoratorSemicolon);continue}if(this.match(l.at)){i.push(this.parseDecorator());continue}const t=this.startNode();i.length&&(t.decorators=i,this.resetStartLocationFromNode(t,i[0]),i=[]),this.parseClassMember(r,t,s),\"constructor\"===t.kind&&t.decorators&&t.decorators.length>0&&this.raise(t.start,b.DecoratorConstructor)}})),this.state.strict=e,this.next(),i.length)throw this.raise(this.state.start,b.TrailingDecorator);return this.classScope.exit(),this.finishNode(r,\"ClassBody\")}parseClassMemberFromModifier(t,e){const s=this.parseIdentifier(!0);if(this.isClassMethod()){const i=e;return i.kind=\"method\",i.computed=!1,i.key=s,i.static=!1,this.pushClassMethod(t,i,!1,!1,!1,!1),!0}if(this.isClassProperty()){const i=e;return i.computed=!1,i.key=s,i.static=!1,t.body.push(this.parseClassProperty(i)),!0}return!1}parseClassMember(t,e,s){const i=this.isContextual(\"static\");if(i){if(this.parseClassMemberFromModifier(t,e))return;if(this.eat(l.braceL))return void this.parseClassStaticBlock(t,e,s)}this.parseClassMemberWithIsStatic(t,e,s,i)}parseClassMemberWithIsStatic(t,e,s,i){const r=e,a=e,n=e,o=e,h=r,p=r;if(e.static=i,this.eat(l.star))return h.kind=\"method\",this.parseClassElementName(h),this.isPrivateName(h.key)?void this.pushClassPrivateMethod(t,a,!0,!1):(this.isNonstaticConstructor(r)&&this.raise(r.key.start,b.ConstructorIsGenerator),void this.pushClassMethod(t,r,!0,!1,!1,!1));const c=this.state.containsEsc,u=this.parseClassElementName(e),d=this.isPrivateName(u),m=\"Identifier\"===u.type,f=this.state.start;if(this.parsePostMemberNameModifiers(p),this.isClassMethod()){if(h.kind=\"method\",d)return void this.pushClassPrivateMethod(t,a,!1,!1);const e=this.isNonstaticConstructor(r);let i=!1;e&&(r.kind=\"constructor\",s.hadConstructor&&!this.hasPlugin(\"typescript\")&&this.raise(u.start,b.DuplicateConstructor),s.hadConstructor=!0,i=s.constructorAllowsSuper),this.pushClassMethod(t,r,!1,!1,e,i)}else if(this.isClassProperty())d?this.pushClassPrivateProperty(t,o):this.pushClassProperty(t,n);else if(!m||\"async\"!==u.name||c||this.isLineTerminator())!m||\"get\"!==u.name&&\"set\"!==u.name||c||this.match(l.star)&&this.isLineTerminator()?this.isLineTerminator()?d?this.pushClassPrivateProperty(t,o):this.pushClassProperty(t,n):this.unexpected():(h.kind=u.name,this.parseClassElementName(r),this.isPrivateName(h.key)?this.pushClassPrivateMethod(t,a,!1,!1):(this.isNonstaticConstructor(r)&&this.raise(r.key.start,b.ConstructorIsAccessor),this.pushClassMethod(t,r,!1,!1,!1,!1)),this.checkGetterSetterParams(r));else{const e=this.eat(l.star);p.optional&&this.unexpected(f),h.kind=\"method\",this.parseClassElementName(h),this.parsePostMemberNameModifiers(p),this.isPrivateName(h.key)?this.pushClassPrivateMethod(t,a,e,!0):(this.isNonstaticConstructor(r)&&this.raise(r.key.start,b.ConstructorIsAsync),this.pushClassMethod(t,r,e,!0,!1,!1))}}parseClassElementName(t){const e=this.parsePropertyName(t,!0);return t.computed||!t.static||\"prototype\"!==e.name&&\"prototype\"!==e.value||this.raise(e.start,b.StaticPrototype),this.isPrivateName(e)&&\"constructor\"===this.getPrivateNameSV(e)&&this.raise(e.start,b.ConstructorClassPrivateField),e}parseClassStaticBlock(t,e,s){var i;this.expectPlugin(\"classStaticBlock\",e.start),this.scope.enter(80),this.expressionScope.enter(Dt());const r=this.state.labels;this.state.labels=[],this.prodParam.enter(0);const a=e.body=[];this.parseBlockOrModuleBlockBody(a,void 0,!1,l.braceR),this.prodParam.exit(),this.expressionScope.exit(),this.scope.exit(),this.state.labels=r,t.body.push(this.finishNode(e,\"StaticBlock\")),s.hadStaticBlock&&this.raise(e.start,b.DuplicateStaticBlock),(null==(i=e.decorators)?void 0:i.length)&&this.raise(e.start,b.DecoratorStaticBlock),s.hadStaticBlock=!0}pushClassProperty(t,e){e.computed||\"constructor\"!==e.key.name&&\"constructor\"!==e.key.value||this.raise(e.key.start,b.ConstructorClassField),t.body.push(this.parseClassProperty(e))}pushClassPrivateProperty(t,e){this.expectPlugin(\"classPrivateProperties\",e.key.start);const s=this.parseClassPrivateProperty(e);t.body.push(s),this.classScope.declarePrivateName(this.getPrivateNameSV(s.key),0,s.key.start)}pushClassMethod(t,e,s,i,r,a){t.body.push(this.parseMethod(e,s,i,r,a,\"ClassMethod\",!0))}pushClassPrivateMethod(t,e,s,i){this.expectPlugin(\"classPrivateMethods\",e.key.start);const r=this.parseMethod(e,s,i,!1,!1,\"ClassPrivateMethod\",!0);t.body.push(r);const a=\"get\"===r.kind?r.static?6:2:\"set\"===r.kind?r.static?5:1:0;this.classScope.declarePrivateName(this.getPrivateNameSV(r.key),a,r.key.start)}parsePostMemberNameModifiers(t){}parseClassPrivateProperty(t){return this.parseInitializer(t),this.semicolon(),this.finishNode(t,\"ClassPrivateProperty\")}parseClassProperty(t){return t.typeAnnotation&&!this.match(l.eq)||this.expectPlugin(\"classProperties\"),this.parseInitializer(t),this.semicolon(),this.finishNode(t,\"ClassProperty\")}parseInitializer(t){this.scope.enter(80),this.expressionScope.enter(Dt()),this.prodParam.enter(0),t.value=this.eat(l.eq)?this.parseMaybeAssignAllowIn():null,this.expressionScope.exit(),this.prodParam.exit(),this.scope.exit()}parseClassId(t,e,s,i=139){this.match(l.name)?(t.id=this.parseIdentifier(),e&&this.checkLVal(t.id,\"class name\",i)):s||!e?t.id=null:this.unexpected(null,b.MissingClassName)}parseClassSuper(t){t.superClass=this.eat(l._extends)?this.parseExprSubscripts():null}parseExport(t){const e=this.maybeParseExportDefaultSpecifier(t),s=!e||this.eat(l.comma),i=s&&this.eatExportStar(t),r=i&&this.maybeParseExportNamespaceSpecifier(t),a=s&&(!r||this.eat(l.comma)),n=e||i;if(i&&!r)return e&&this.unexpected(),this.parseExportFrom(t,!0),this.finishNode(t,\"ExportAllDeclaration\");const o=this.maybeParseExportNamedSpecifiers(t);if(e&&s&&!i&&!o||r&&a&&!o)throw this.unexpected(null,l.braceL);let h;if(n||o?(h=!1,this.parseExportFrom(t,n)):h=this.maybeParseExportDeclaration(t),n||o||h)return this.checkExport(t,!0,!1,!!t.source),this.finishNode(t,\"ExportNamedDeclaration\");if(this.eat(l._default))return t.declaration=this.parseExportDefaultExpression(),this.checkExport(t,!0,!0),this.finishNode(t,\"ExportDefaultDeclaration\");throw this.unexpected(null,l.braceL)}eatExportStar(t){return this.eat(l.star)}maybeParseExportDefaultSpecifier(t){if(this.isExportDefaultSpecifier()){this.expectPlugin(\"exportDefaultFrom\");const e=this.startNode();return e.exported=this.parseIdentifier(!0),t.specifiers=[this.finishNode(e,\"ExportDefaultSpecifier\")],!0}return!1}maybeParseExportNamespaceSpecifier(t){if(this.isContextual(\"as\")){t.specifiers||(t.specifiers=[]);const e=this.startNodeAt(this.state.lastTokStart,this.state.lastTokStartLoc);return this.next(),e.exported=this.parseModuleExportName(),t.specifiers.push(this.finishNode(e,\"ExportNamespaceSpecifier\")),!0}return!1}maybeParseExportNamedSpecifiers(t){return!!this.match(l.braceL)&&(t.specifiers||(t.specifiers=[]),t.specifiers.push(...this.parseExportSpecifiers()),t.source=null,t.declaration=null,!0)}maybeParseExportDeclaration(t){return!!this.shouldParseExportDeclaration()&&(t.specifiers=[],t.source=null,t.declaration=this.parseExportDeclaration(t),!0)}isAsyncFunction(){if(!this.isContextual(\"async\"))return!1;const t=this.nextTokenStart();return!u.test(this.input.slice(this.state.pos,t))&&this.isUnparsedContextual(t,\"function\")}parseExportDefaultExpression(){const t=this.startNode(),e=this.isAsyncFunction();if(this.match(l._function)||e)return this.next(),e&&this.next(),this.parseFunction(t,5,e);if(this.match(l._class))return this.parseClass(t,!0,!0);if(this.match(l.at))return this.hasPlugin(\"decorators\")&&this.getPluginOption(\"decorators\",\"decoratorsBeforeExport\")&&this.raise(this.state.start,b.DecoratorBeforeExport),this.parseDecorators(!1),this.parseClass(t,!0,!0);if(this.match(l._const)||this.match(l._var)||this.isLet())throw this.raise(this.state.start,b.UnsupportedDefaultExport);{const t=this.parseMaybeAssignAllowIn();return this.semicolon(),t}}parseExportDeclaration(t){return this.parseStatement(null)}isExportDefaultSpecifier(){if(this.match(l.name)){const t=this.state.value;if(\"async\"===t&&!this.state.containsEsc||\"let\"===t)return!1;if((\"type\"===t||\"interface\"===t)&&!this.state.containsEsc){const t=this.lookahead();if(t.type===l.name&&\"from\"!==t.value||t.type===l.braceL)return this.expectOnePlugin([\"flow\",\"typescript\"]),!1}}else if(!this.match(l._default))return!1;const t=this.nextTokenStart(),e=this.isUnparsedContextual(t,\"from\");if(44===this.input.charCodeAt(t)||this.match(l.name)&&e)return!0;if(this.match(l._default)&&e){const e=this.input.charCodeAt(this.nextTokenStartSince(t+4));return 34===e||39===e}return!1}parseExportFrom(t,e){if(this.eatContextual(\"from\")){t.source=this.parseImportSource(),this.checkExport(t);const e=this.maybeParseImportAssertions();e&&(t.assertions=e)}else e?this.unexpected():t.source=null;this.semicolon()}shouldParseExportDeclaration(){if(this.match(l.at)&&(this.expectOnePlugin([\"decorators\",\"decorators-legacy\"]),this.hasPlugin(\"decorators\"))){if(!this.getPluginOption(\"decorators\",\"decoratorsBeforeExport\"))return!0;this.unexpected(this.state.start,b.DecoratorBeforeExport)}return\"var\"===this.state.type.keyword||\"const\"===this.state.type.keyword||\"function\"===this.state.type.keyword||\"class\"===this.state.type.keyword||this.isLet()||this.isAsyncFunction()}checkExport(t,e,s,i){if(e)if(s){if(this.checkDuplicateExports(t,\"default\"),this.hasPlugin(\"exportDefaultFrom\")){var r;const e=t.declaration;\"Identifier\"!==e.type||\"from\"!==e.name||e.end-e.start!==4||(null==(r=e.extra)?void 0:r.parenthesized)||this.raise(e.start,b.ExportDefaultFromAsIdentifier)}}else if(t.specifiers&&t.specifiers.length)for(let a=0,n=t.specifiers;a<n.length;a++){const t=n[a],{exported:e}=t,s=\"Identifier\"===e.type?e.name:e.value;if(this.checkDuplicateExports(t,s),!i&&t.local){const{local:e}=t;\"StringLiteral\"===e.type?this.raise(t.start,b.ExportBindingIsString,e.value,s):(this.checkReservedWord(e.name,e.start,!0,!1),this.scope.checkLocalExport(e))}}else if(t.declaration)if(\"FunctionDeclaration\"===t.declaration.type||\"ClassDeclaration\"===t.declaration.type){const e=t.declaration.id;if(!e)throw new Error(\"Assertion failure\");this.checkDuplicateExports(t,e.name)}else if(\"VariableDeclaration\"===t.declaration.type)for(let a=0,n=t.declaration.declarations;a<n.length;a++){const t=n[a];this.checkDeclaration(t.id)}if(this.state.decoratorStack[this.state.decoratorStack.length-1].length)throw this.raise(t.start,b.UnsupportedDecoratorExport)}checkDeclaration(t){if(\"Identifier\"===t.type)this.checkDuplicateExports(t,t.name);else if(\"ObjectPattern\"===t.type)for(let e=0,s=t.properties;e<s.length;e++){const t=s[e];this.checkDeclaration(t)}else if(\"ArrayPattern\"===t.type)for(let e=0,s=t.elements;e<s.length;e++){const t=s[e];t&&this.checkDeclaration(t)}else\"ObjectProperty\"===t.type?this.checkDeclaration(t.value):\"RestElement\"===t.type?this.checkDeclaration(t.argument):\"AssignmentPattern\"===t.type&&this.checkDeclaration(t.left)}checkDuplicateExports(t,e){this.state.exportedIdentifiers.indexOf(e)>-1&&this.raise(t.start,\"default\"===e?b.DuplicateDefaultExport:b.DuplicateExport,e),this.state.exportedIdentifiers.push(e)}parseExportSpecifiers(){const t=[];let e=!0;for(this.expect(l.braceL);!this.eat(l.braceR);){if(e)e=!1;else if(this.expect(l.comma),this.eat(l.braceR))break;const s=this.startNode();s.local=this.parseModuleExportName(),s.exported=this.eatContextual(\"as\")?this.parseModuleExportName():s.local.__clone(),t.push(this.finishNode(s,\"ExportSpecifier\"))}return t}parseModuleExportName(){if(this.match(l.string)){this.expectPlugin(\"moduleStringNames\");const t=this.parseLiteral(this.state.value,\"StringLiteral\"),e=t.value.match(Ot);return e&&this.raise(t.start,b.ModuleExportNameHasLoneSurrogate,e[0].charCodeAt(0).toString(16)),t}return this.parseIdentifier(!0)}parseImport(t){if(t.specifiers=[],!this.match(l.string)){const e=!this.maybeParseDefaultImportSpecifier(t)||this.eat(l.comma),s=e&&this.maybeParseStarImportSpecifier(t);e&&!s&&this.parseNamedImportSpecifiers(t),this.expectContextual(\"from\")}t.source=this.parseImportSource();const e=this.maybeParseImportAssertions();if(e)t.assertions=e;else{const e=this.maybeParseModuleAttributes();e&&(t.attributes=e)}return this.semicolon(),this.finishNode(t,\"ImportDeclaration\")}parseImportSource(){return this.match(l.string)||this.unexpected(),this.parseExprAtom()}shouldParseDefaultImport(t){return this.match(l.name)}parseImportSpecifierLocal(t,e,s,i){e.local=this.parseIdentifier(),this.checkLVal(e.local,i,9),t.specifiers.push(this.finishNode(e,s))}parseAssertEntries(){const t=[],e=new Set;do{if(this.match(l.braceR))break;const s=this.startNode(),i=this.state.value;if(this.match(l.string)?s.key=this.parseLiteral(i,\"StringLiteral\"):s.key=this.parseIdentifier(!0),this.expect(l.colon),\"type\"!==i&&this.raise(s.key.start,b.ModuleAttributeDifferentFromType,i),e.has(i)&&this.raise(s.key.start,b.ModuleAttributesWithDuplicateKeys,i),e.add(i),!this.match(l.string))throw this.unexpected(this.state.start,b.ModuleAttributeInvalidValue);s.value=this.parseLiteral(this.state.value,\"StringLiteral\"),this.finishNode(s,\"ImportAttribute\"),t.push(s)}while(this.eat(l.comma));return t}maybeParseModuleAttributes(){if(!this.match(l._with)||this.hasPrecedingLineBreak())return this.hasPlugin(\"moduleAttributes\")?[]:null;this.expectPlugin(\"moduleAttributes\"),this.next();const t=[],e=new Set;do{const s=this.startNode();if(s.key=this.parseIdentifier(!0),\"type\"!==s.key.name&&this.raise(s.key.start,b.ModuleAttributeDifferentFromType,s.key.name),e.has(s.key.name)&&this.raise(s.key.start,b.ModuleAttributesWithDuplicateKeys,s.key.name),e.add(s.key.name),this.expect(l.colon),!this.match(l.string))throw this.unexpected(this.state.start,b.ModuleAttributeInvalidValue);s.value=this.parseLiteral(this.state.value,\"StringLiteral\"),this.finishNode(s,\"ImportAttribute\"),t.push(s)}while(this.eat(l.comma));return t}maybeParseImportAssertions(){if(!this.isContextual(\"assert\")||this.hasPrecedingLineBreak())return this.hasPlugin(\"importAssertions\")?[]:null;this.expectPlugin(\"importAssertions\"),this.next(),this.eat(l.braceL);const t=this.parseAssertEntries();return this.eat(l.braceR),t}maybeParseDefaultImportSpecifier(t){return!!this.shouldParseDefaultImport(t)&&(this.parseImportSpecifierLocal(t,this.startNode(),\"ImportDefaultSpecifier\",\"default import specifier\"),!0)}maybeParseStarImportSpecifier(t){if(this.match(l.star)){const e=this.startNode();return this.next(),this.expectContextual(\"as\"),this.parseImportSpecifierLocal(t,e,\"ImportNamespaceSpecifier\",\"import namespace specifier\"),!0}return!1}parseNamedImportSpecifiers(t){let e=!0;for(this.expect(l.braceL);!this.eat(l.braceR);){if(e)e=!1;else{if(this.eat(l.colon))throw this.raise(this.state.start,b.DestructureNamedImport);if(this.expect(l.comma),this.eat(l.braceR))break}this.parseImportSpecifier(t)}}parseImportSpecifier(t){const e=this.startNode();if(e.imported=this.parseModuleExportName(),this.eatContextual(\"as\"))e.local=this.parseIdentifier();else{const{imported:t}=e;if(\"StringLiteral\"===t.type)throw this.raise(e.start,b.ImportBindingIsString,t.value);this.checkReservedWord(t.name,e.start,!0,!0),e.local=t.__clone()}this.checkLVal(e.local,\"import specifier\",9),t.specifiers.push(this.finishNode(e,\"ImportSpecifier\"))}}{constructor(t,e){super(t=function(t){const e={};for(let s=0,i=Object.keys(gt);s<i.length;s++){const r=i[s];e[r]=t&&null!=t[r]?t[r]:gt[r]}return e}(t),e);const s=this.getScopeHandler();this.options=t,this.inModule=\"module\"===this.options.sourceType,this.scope=new s(this.raise.bind(this),this.inModule),this.prodParam=new ht,this.classScope=new Bt(this.raise.bind(this)),this.expressionScope=new Lt(this.raise.bind(this)),this.plugins=function(t){const e=new Map;for(let s=0;s<t.length;s++){const i=t[s],[r,a]=Array.isArray(i)?i:[i,{}];e.has(r)||e.set(r,a||{})}return e}(this.options.plugins),this.filename=t.sourceFilename}getScopeHandler(){return at}parse(){let t=0;this.hasPlugin(\"topLevelAwait\")&&this.inModule&&(t|=2),this.scope.enter(1),this.prodParam.enter(t);const e=this.startNode(),s=this.startNode();return this.nextToken(),e.errors=null,this.parseTopLevel(e,s),e.errors=this.state.errors,e}}function jt(t,e){let s=_t;return(null==t?void 0:t.plugins)&&(!function(t){if(dt(t,\"decorators\")){if(dt(t,\"decorators-legacy\"))throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");const e=mt(t,\"decorators\",\"decoratorsBeforeExport\");if(null==e)throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.\");if(\"boolean\"!==typeof e)throw new Error(\"'decoratorsBeforeExport' must be a boolean.\")}if(dt(t,\"flow\")&&dt(t,\"typescript\"))throw new Error(\"Cannot combine flow and typescript plugins.\");if(dt(t,\"placeholders\")&&dt(t,\"v8intrinsic\"))throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");if(dt(t,\"pipelineOperator\")&&!ft.includes(mt(t,\"pipelineOperator\",\"proposal\")))throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \"+ft.map((t=>`'${t}'`)).join(\", \"));if(dt(t,\"moduleAttributes\")){if(dt(t,\"importAssertions\"))throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");if(\"may-2020\"!==mt(t,\"moduleAttributes\",\"version\"))throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.\")}if(dt(t,\"recordAndTuple\")&&!yt.includes(mt(t,\"recordAndTuple\",\"syntaxType\")))throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \"+yt.map((t=>`'${t}'`)).join(\", \"))}(t.plugins),s=function(t){const e=Pt.filter((e=>dt(t,e))),s=e.join(\"/\");let i=Ut[s];if(!i){i=_t;for(let t=0;t<e.length;t++){const s=e[t];i=xt[s](i)}Ut[s]=i}return i}(t.plugins)),new s(t,e)}const Ut={};e.parse=function(t,e){var s;if(\"unambiguous\"!==(null==(s=e)?void 0:s.sourceType))return jt(e,t).parse();e=Object.assign({},e);try{e.sourceType=\"module\";const s=jt(e,t),r=s.parse();if(s.sawUnambiguousESM)return r;if(s.ambiguousScriptDifferentAst)try{return e.sourceType=\"script\",jt(e,t).parse()}catch(i){}else r.program.sourceType=\"script\";return r}catch(r){try{return e.sourceType=\"script\",jt(e,t).parse()}catch(a){}throw r}},e.parseExpression=function(t,e){const s=jt(e,t);return s.options.strictMode&&(s.state.strict=!0),s.getExpression()},e.tokTypes=l}}]);","map":{"version":3,"sources":["static/chunks/18012ef3.e7338780f50214fc57f1.js"],"names":["window","push","oGoC","module","exports","__webpack_require__","Object","defineProperty","value","beforeExpr","startsExpr","isLoop","prefix","TokenType","[object Object]","label","conf","this","keyword","rightAssociative","isAssign","postfix","binop","updateContext","keywords","Map","createKeyword","name","options","token","set","createBinop","types","num","bigint","decimal","regexp","string","eof","bracketL","bracketHashL","bracketBarL","bracketR","bracketBarR","braceL","braceBarL","braceHashL","braceR","braceBarR","parenL","parenR","comma","semi","colon","doubleColon","dot","question","questionDot","arrow","template","ellipsis","backQuote","dollarBraceL","at","hash","interpreterDirective","eq","assign","incDec","bang","tilde","pipeline","nullishCoalescing","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","exponent","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","RegExp","source","isNewLine","code","skipWhiteSpace","isWhitespace","Position","line","col","column","SourceLocation","start","end","filename","identifierName","last","stack","length","ErrorMessages","freeze","AccessorIsGenerator","ArgumentsInClass","AsyncFunctionInSingleStatementContext","AwaitBindingIdentifier","AwaitExpressionFormalParameter","AwaitNotInAsyncContext","AwaitNotInAsyncFunction","BadGetterArity","BadSetterArity","BadSetterRestParameter","ConstructorClassField","ConstructorClassPrivateField","ConstructorIsAccessor","ConstructorIsAsync","ConstructorIsGenerator","DeclarationMissingInitializer","DecoratorBeforeExport","DecoratorConstructor","DecoratorExportClass","DecoratorSemicolon","DecoratorStaticBlock","DeletePrivateField","DestructureNamedImport","DuplicateConstructor","DuplicateDefaultExport","DuplicateExport","DuplicateProto","DuplicateRegExpFlags","DuplicateStaticBlock","ElementAfterRest","EscapedCharNotAnIdentifier","ExportBindingIsString","ExportDefaultFromAsIdentifier","ForInOfLoopInitializer","GeneratorInSingleStatementContext","IllegalBreakContinue","IllegalLanguageModeDirective","IllegalReturn","ImportBindingIsString","ImportCallArgumentTrailingComma","ImportCallArity","ImportCallNotNewExpression","ImportCallSpreadArgument","ImportMetaOutsideModule","ImportOutsideModule","InvalidBigIntLiteral","InvalidCodePoint","InvalidDecimal","InvalidDigit","InvalidEscapeSequence","InvalidEscapeSequenceTemplate","InvalidEscapedReservedWord","InvalidIdentifier","InvalidLhs","InvalidLhsBinding","InvalidNumber","InvalidOrMissingExponent","InvalidOrUnexpectedToken","InvalidParenthesizedAssignment","InvalidPrivateFieldResolution","InvalidPropertyBindingPattern","InvalidRecordProperty","InvalidRestAssignmentPattern","LabelRedeclaration","LetInLexicalBinding","LineTerminatorBeforeArrow","MalformedRegExpFlags","MissingClassName","MissingEqInAssignment","MissingUnicodeEscape","MixingCoalesceWithLogical","ModuleAttributeDifferentFromType","ModuleAttributeInvalidValue","ModuleAttributesWithDuplicateKeys","ModuleExportNameHasLoneSurrogate","ModuleExportUndefined","MultipleDefaultsInSwitch","NewlineAfterThrow","NoCatchOrFinally","NumberIdentifier","NumericSeparatorInEscapeSequence","ObsoleteAwaitStar","OptionalChainingNoNew","OptionalChainingNoTemplate","ParamDupe","PatternHasAccessor","PatternHasMethod","PipelineBodyNoArrow","PipelineBodySequenceExpression","PipelineHeadSequenceExpression","PipelineTopicUnused","PrimaryTopicNotAllowed","PrimaryTopicRequiresSmartPipeline","PrivateInExpectedIn","PrivateNameRedeclaration","RecordExpressionBarIncorrectEndSyntaxType","RecordExpressionBarIncorrectStartSyntaxType","RecordExpressionHashIncorrectStartSyntaxType","RecordNoProto","RestTrailingComma","SloppyFunction","StaticPrototype","StrictDelete","StrictEvalArguments","StrictEvalArgumentsBinding","StrictFunction","StrictNumericEscape","StrictOctalLiteral","StrictWith","SuperNotAllowed","SuperPrivateField","TrailingDecorator","TupleExpressionBarIncorrectEndSyntaxType","TupleExpressionBarIncorrectStartSyntaxType","TupleExpressionHashIncorrectStartSyntaxType","UnexpectedArgumentPlaceholder","UnexpectedAwaitAfterPipelineBody","UnexpectedDigitAfterHash","UnexpectedImportExport","UnexpectedKeyword","UnexpectedLeadingDecorator","UnexpectedLexicalDeclaration","UnexpectedNewTarget","UnexpectedNumericSeparator","UnexpectedPrivateField","UnexpectedReservedWord","UnexpectedSuper","UnexpectedToken","UnexpectedTokenUnaryExponentiation","UnsupportedBind","UnsupportedDecoratorExport","UnsupportedDefaultExport","UnsupportedImport","UnsupportedMetaProperty","UnsupportedParameterDecorator","UnsupportedPropertyDecorator","UnsupportedSuper","UnterminatedComment","UnterminatedRegExp","UnterminatedString","UnterminatedTemplate","VarRedeclaration","YieldBindingIdentifier","YieldInParameter","ZeroDigitNumericSeparator","TokContext","isExpr","preserveSpace","override","types$1","braceStatement","braceExpression","recordExpression","templateQuasi","parenStatement","parenExpression","p","readTmplToken","functionExpression","functionStatement","state","context","exprAllowed","out","pop","curContext","prevType","allowed","isIterator","braceIsBlock","statementParens","hasPrecedingLineBreak","b_stat","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","pos","i","isIdentifierStart","test","String","fromCharCode","isIdentifierChar","reservedWords","keywords$1","Set","reservedWordsStrictSet","reservedWordsStrictBindSet","isReservedWord","word","inModule","isStrictReservedWord","has","isStrictBindOnlyReservedWord","isStrictBindReservedWord","isKeyword","keywordRelationalOperator","SCOPE_TS_MODULE","BIND_FLAGS_CLASS","BIND_FLAGS_TS_EXPORT_ONLY","reservedTypes","FlowErrors","AmbiguousConditionalArrow","AmbiguousDeclareModuleKind","AssignReservedType","DeclareClassElement","DeclareClassFieldInitializer","DuplicateDeclareModuleExports","EnumBooleanMemberNotInitialized","EnumDuplicateMemberName","EnumInconsistentMemberValues","EnumInvalidExplicitType","EnumInvalidExplicitTypeUnknownSupplied","EnumInvalidMemberInitializerPrimaryType","EnumInvalidMemberInitializerSymbolType","EnumInvalidMemberInitializerUnknownType","EnumInvalidMemberName","EnumNumberMemberNotInitialized","EnumStringMemberInconsistentlyInitailized","ImportTypeShorthandOnlyInPureImport","InexactInsideExact","InexactInsideNonObject","InexactVariance","InvalidNonTypeImportInDeclareModule","MissingTypeParamDefault","NestedDeclareModule","NestedFlowComment","OptionalBindingPattern","SpreadVariance","TypeBeforeInitializer","TypeCastInPattern","UnexpectedExplicitInexactInObject","UnexpectedReservedType","UnexpectedReservedUnderscore","UnexpectedSpaceBetweenModuloChecks","UnexpectedSpreadType","UnexpectedSubtractionOperand","UnexpectedTokenAfterTypeParameter","UnexpectedTypeParameterBeforeAsyncArrowFunction","UnsupportedDeclareExportKind","UnsupportedStatementInDeclareModule","UnterminatedFlowComment","hasTypeImportKind","node","importKind","isMaybeDefaultImport","type","exportSuggestions","const","let","interface","FLOW_PRAGMA_REGEX","entities","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","HEX_NUMBER","DECIMAL_NUMBER","JsxErrors","AttributeIsEmpty","MissingClosingTagFragment","MissingClosingTagElement","UnexpectedSequenceExpression","UnsupportedJsxValue","UnterminatedJsxContent","UnwrappedAdjacentJSXElements","isFragment","object","getQualifiedJSXName","namespace","property","Error","j_oTag","j_cTag","j_expr","jsxName","jsxText","jsxTagStart","jsxTagEnd","Scope","flags","var","lexical","functions","ScopeHandler","raise","scopeStack","undefinedExports","undefinedPrivateNames","inFunction","currentVarScope","allowSuper","currentThisScope","allowDirectSuper","inClass","inNonArrowFunction","treatFunctionsAsVar","treatFunctionsAsVarInScope","currentScope","createScope","scope","bindingType","checkRedeclarationInScope","maybeExportDefined","SCOPE_PROGRAM","delete","isRedeclaredInScope","indexOf","id","TypeScriptScope","args","super","enums","constEnums","classes","exportOnlyBindings","TypeScriptScopeHandler","declareName","arguments","checkLocalExport","ProductionParameterHandler","stacks","hasAwait","currentFlags","hasYield","hasReturn","hasIn","functionFlags","isAsync","isGenerator","nonNull","x","assert","TSErrors","ClassMethodHasDeclare","ClassMethodHasReadonly","ConstructorHasTypeParameters","DeclareClassFieldHasInitializer","DeclareFunctionHasImplementation","DuplicateModifier","EmptyHeritageClauseType","EmptyTypeArguments","EmptyTypeParameters","IndexSignatureHasAbstract","IndexSignatureHasAccessibility","IndexSignatureHasStatic","IndexSignatureHasDeclare","InvalidTupleMemberLabel","MixedLabeledAndUnlabeledElements","OptionalTypeBeforeRequired","PatternIsOptional","PrivateElementHasAbstract","PrivateElementHasAccessibility","TypeAnnotationAfterAssign","UnexpectedParameterModifier","UnexpectedReadonly","UnexpectedTypeAnnotation","UnexpectedTypeCastInParameter","UnsupportedImportTypeArgument","UnsupportedParameterPropertyKind","UnsupportedSignatureParameterKind","placeholder","hasPlugin","plugins","some","plugin","Array","isArray","getPluginOption","option","find","PIPELINE_PROPOSALS","RECORD_AND_TUPLE_SYNTAX_TYPES","mixinPlugins","estree","superClass","pattern","regex","e","estreeParseLiteral","bigInt","BigInt","_unused","parseLiteral","directive","directiveLiteral","stmt","startNodeAt","loc","expression","extra","expressionValue","raw","finishNodeAt","slice","initFunction","isObjectProperty","checkDeclaration","method","params","_stmt$expression$extr","parenthesized","stmtToDirective","addExtra","parseBlockBody","directiveStatements","directives","map","d","directiveToStmt","body","concat","classBody","isConstructor","allowsDirectSuper","parseMethod","typeParameters","refExpressionErrors","estreeParseRegExpLiteral","estreeParseBigIntLiteral","estreeParseDecimalLiteral","parseExprAtom","startPos","startLoc","allowExpression","isMethod","parseFunctionBody","inClassScope","funcNode","startNode","kind","finishNode","isPattern","isAccessor","parseObjectMethod","shorthand","parseObjectProperty","isLHS","toAssignable","key","toAssignableObjectExpressionProp","optional","finishCallExpression","callee","toReferencedArguments","parseExport","exported","specifiers","base","noCalls","parseSubscript","optionalChainMember","substring","stop","chain","startNodeAtNode","hasPropertyAsPrivateName","jsx","chunkStart","ch","input","charCodeAt","finishToken","getTokenFromCode","jsxReadEntity","jsxReadNewLine","normalizeCRLF","curLine","lineStart","quote","entity","str","count","substr","fromCodePoint","parseInt","match","unexpected","next","jsxParseIdentifier","eat","jsxParseNamespacedName","newNode","jsxParseExpressionContainer","lastTokEnd","lastTokEndLoc","parseExpression","expect","jsxParseEmptyExpression","argument","parseMaybeAssignAllowIn","jsxParseAttributeValue","jsxParseElementName","jsxParseOpeningElementAfterName","attributes","jsxParseAttribute","selfClosing","children","openingElement","jsxParseOpeningElementAt","closingElement","contents","jsxParseClosingElementAt","jsxParseElementAt","jsxParseSpreadChild","openingFragment","closingFragment","isRelational","jsxParseElement","inPropertyName","jsxReadToken","jsxReadWord","jsxReadString","flow","flowPragma","undefined","val","comment","matches","exec","addComment","tok","oldInType","inType","flowParseType","moduloLoc","moduloPos","checksLoc","expectContextual","predicate","flowParsePredicate","flowParseInterfaceish","parseIdentifier","typeNode","typeContainer","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","rest","returnType","flowParseTypeAndPredicateInitialiser","typeAnnotation","resetEndLocation","semicolon","insideModule","flowParseDeclareClass","flowParseDeclareFunction","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","lastTokStart","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","flowParseTypeAnnotatableIdentifier","BIND_KIND_VALUE","enter","bodyNode","parseImport","flowParseDeclare","exit","hasModuleExport","forEach","bodyElement","declaration","isEsModuleType","default","isLet","suggestion","exportKind","flowParseTypeAnnotation","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","extends","implements","mixins","flowParseInterfaceExtends","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","liberal","checkReservedType","right","flowParseTypeInitialiser","declare","supertype","impltype","requireDefault","nodeStart","variance","flowParseVariance","ident","bound","defaultRequired","typeParameter","flowParseTypeParameter","expectRelational","oldNoAnonFunctionType","noAnonFunctionType","flowParseTypeOrImplicitInstantiation","isStatic","static","lookahead","flowParseObjectPropertyKey","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","valueNode","endDelim","exact","callProperties","properties","indexers","internalSlots","inexact","protoStart","inexactStart","flowParseObjectTypeInternalSlot","flowParseObjectTypeIndexer","flowParseObjectTypeCallProperty","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","proto","flowCheckGetterSetterParams","paramCount","node2","qualification","flowParsePrimaryType","lh","checkNotUnderscore","flowParseGenericType","isGroupedType","flowParseInterfaceType","flowIdentToTypeAnnotation","flowParseTupleType","reinterpretTypeAsFunctionTypeParam","flowParseTypeofType","createIdentifier","canInsertSemicolon","elementType","flowParsePrefixType","flowParsePostfixType","param","flowParseAnonFunctionWithoutParens","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","allowExpressionBody","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","topLevel","strict","flowParseInterface","shouldParseEnums","flowParseEnumDeclaration","parseStatement","isValidDirective","expr","parseExpressionStatement","shouldParseExportDeclaration","isExportDefaultSpecifier","parseExportDefaultExpression","refNeedsArrowPos","result","tryParse","parseConditional","error","failState","clone","originalNoArrowAt","noArrowAt","consequent","failed","tryParseConditionalConsequent","valid","invalid","getArrowLikeExpressions","alternate","parseMaybeAssign","noArrowParamsConversionAt","disallowInvalid","arrows","finishArrowValidation","list","list1","list2","partition","every","isAssignable","_node$extra","toAssignableList","trailingComma","SCOPE_FUNCTION","checkParams","parse","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","declarationNode","parseExportSpecifiers","parseExportFrom","parseExportDeclaration","eatExportStar","hasNamespace","maybeParseExportNamespaceSpecifier","isStatement","optionalId","parseClassId","member","parseClassMemberFromModifier","parseClassMember","finishOp","current","isIteratorStart","readWord","isBinding","elements","element","operator","typeCastToParameter","exprList","trailingCommaPos","isParenthesizedExpr","_expr$extra","close","canBePattern","isTuple","parseArrayLike","maybeInArrowParameters","toReferencedList","checkLVal","parseClassProperty","parseClassPrivateProperty","isClassMethod","isClassProperty","isNonstaticConstructor","pushClassMethod","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","isPrivateNameAllowed","parsePropertyName","parseObjPropValue","left","parseMaybeDefault","shouldParseDefaultImport","specifier","contextDescription","local","maybeParseDefaultImportSpecifier","firstIdentLoc","firstIdent","parseModuleExportName","specifierTypeKind","isLookaheadContextual","as_ident","imported","__clone","nodeIsTypeImport","specifierIsTypeImport","checkReservedWord","allowModifiers","parseFunctionParams","parseVarId","call","parseAsyncArrowFromCallExpression","shouldParseAsyncArrow","afterLeftParse","_jsx","_jsx2","_jsx3","abort","_arrowExpression$extr","arrowExpression","resetStartLocationFromNode","maybeUnwrapTypeCastExpression","aborted","async","thrown","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","canBeArrow","parseParenAndDistinguishExpression","parseCallExpressionArguments","parseAsyncArrowWithTypeParameters","parseSubscripts","subscriptState","isLookaheadToken_lt","typeArguments","shouldParseTypes","flowParseTypeParameterInstantiationCallOrNew","targs","parseNewArguments","parseArrowExpression","hasFlowComment","nextToken","readToken_mult_modulo","readToken_pipe_amp","file","program","fileNode","parseTopLevel","skipFlowComment","hasFlowCommentCompletion","skipBlockComment","shiftToFirstNonWhiteSpace","includes","ch2","ch3","enumName","memberName","toUpperCase","suppliedType","explicitType","message","endOfInit","literal","parseBooleanLiteral","init","flowEnumMemberInit","expectedType","flowEnumErrorInvalidMemberInitializer","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","memberNode","flowEnumMemberRaw","flowEnumErrorInvalidMemberName","flowEnumErrorDuplicateMemberName","add","flowEnumCheckExplicitTypeMismatch","flowEnumErrorBooleanMemberNotInitialized","flowEnumErrorNumberMemberNotInitialized","initializedMembers","_i","flowEnumErrorStringMemberInconsistentlyInitailized","_i2","flowEnumErrorInvalidExplicitType","nameLoc","flowEnumParseExplicitType","flowEnumMembers","flowEnumStringMembers","boolsLen","numsLen","strsLen","defaultedLen","_i3","_members$defaultedMem","_i4","_members$defaultedMem2","flowEnumErrorInconsistentMemberValues","flowEnumBody","nextTokenStart","afterNext","typescript","isLiteralPropertyName","allowedModifiers","modifier","tsTryParse","tsNextTokenCanFollowModifier","bind","modified","tsParseModifier","hasOwnProperty","parseElement","tsIsListTerminator","tsParseDelimitedListWorker","expectSuccess","bracket","skipFirstToken","tsParseDelimitedList","qualifier","tsParseEntityName","tsParseTypeArguments","allowReservedWords","typeName","lhs","parameterName","tsParseTypeAnnotation","asserts","exprName","tsParseImportType","parseIdentifierName","constraint","tsEatThenParseType","tsParseTypeParameters","tsParseBracketedList","tsParseTypeParameter","tsParseTypeReference","returnToken","signature","returnTokenRequired","tsTryParseTypeParameters","parameters","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","parseBindingList","tsFillSignature","tsParseTypeMemberSemicolon","tsLookAhead","tsIsUnambiguouslyIndexSignature","tsTryParseTypeAnnotation","readonly","nodeAny","tsParseSignatureMember","tsParsePropertyOrMethodSignature","idx","tsTryParseIndexSignature","tsParseObjectTypeMembers","tsParseList","tsParseTypeMember","tsIsIdentifier","tsExpectThenParseType","tsParseMappedTypeParameter","nameType","tsParseType","tsTryParseType","elementTypes","tsParseTupleElementType","seenOptionalElement","labeledElements","elementNode","_labeledElements","isLabeled","labeledNode","optionalTypeNode","restNode","parseTemplate","parseTemplateSubstitution","thisKeyword","tsParseThisTypeNode","tsParseThisTypePredicate","keywordTypeFromName","lookaheadCharCode","tsParseLiteralTypeNode","parseMaybeUnary","tsParseThisTypeOrThisTypePredicate","tsParseTypeQuery","tsIsStartOfMappedType","tsParseMappedType","tsParseTypeLiteral","tsParseTupleType","tsParseParenthesizedType","tsParseTemplateLiteralType","tsParseNonArrayType","objectType","indexType","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","kw","tsParseTypeOperator","tsParseInferType","tsParseArrayTypeOrHigher","parseConstituentType","tsParseUnionOrIntersectionType","tsParseIntersectionTypeOrHigher","tsIsUnambiguouslyStartOfFunctionType","braceStackCounter","tsSkipParameterStart","tsInType","t","tsParseTypePredicateAsserts","thisTypePredicate","typePredicateVariable","tsParseTypePredicatePrefix","containsEsc","eatColon","tsParseNonConditionalType","checkType","extendsType","trueType","falseType","tsIsStartOfFunctionType","tsParseFunctionOrConstructorType","tsParseUnionTypeOrHigher","tsTryNextParseConstantContext","tsNextThenParseType","descriptor","originalStart","delimitedList","tsParseExpressionWithTypeArguments","tsParseHeritageClause","cb","oldContext","tsDoThenParseType","initializer","isConst","BIND_TS_ENUM","tsParseEnumMember","parseBlockOrModuleBlockBody","nested","inner","tsParseModuleOrNamespaceDeclaration","prodParam","tsParseModuleBlock","global","isExport","moduleReference","tsParseModuleReference","tsIsExternalModuleReference","tsParseExternalModuleReference","f","res","nany","isLineTerminator","starttype","tsInDeclareContext","parseFunctionStatement","parseClass","tsParseEnumDeclaration","parseVarStatement","tsParseAmbientExternalModuleDeclaration","tsParseDeclaration","tsTryParseDeclare","mod","tsCheckLineTerminatorAndMatch","cls","abstract","tsParseInterfaceDeclaration","tsParseTypeAliasDeclaration","tokenType","oldMaybeInArrowParameters","tsTryParseAndCatch","tsTryParseTypeOrTypePredicateAnnotation","tsInNoContext","tsIsDeclarationStart","decorators","accessibility","parseAccessModifier","parseAssignableListItemTypes","elt","pp","parameter","bodilessType","isDeclareContext","registerFunctionStatementId","items","isInParens","tsCheckForInvalidTypeCasts","nonNullExpression","atPossibleAsyncArrow","asyncArrowFn","tsTryParseGenericAsyncArrowFunction","parseTaggedTemplateExpression","leftStartPos","leftStartLoc","minPrec","reScan_lt_gt","parseExprOp","checkKeywords","ahead","tsParseImportEqualsDeclaration","importNode","isAbstractClass","parseStatementContent","tsParseModifiers","callParseClassMember","parseClassMemberWithIsStatic","methodOrProp","tsParseExpressionStatement","isDeclare","tsTryParseExportDeclaration","resetStartLocation","definite","parseClassPropertyAnnotation","_typeCast","_typeCast2","_jsx4","_typeCast3","typeCast","_typeParameters","tsParseTypeAssertion","parseBindingAtom","parseMaybeDecoratorArguments","readToken_lt_gt","canHaveLeadingDecorator","baseCount","getGetterSetterExpectedParamCount","firstParam","getObjectOrClassMethodParams","parseCatchClauseParam","oldIsDeclareContext","v8intrinsic","v8IntrinsicStart","identifier","parseV8Intrinsic","placeholders","expectedNode","assertNoSpace","finishPlaceholder","isFinished","parsePlaceholder","verifyBreakContinue","parseBlock","parseFunctionId","takeDecorators","oldStrict","parseClassBody","expectPlugin","isUnparsedContextual","startsWith","nextTokenStartSince","maybeParseExportDefaultSpecifier","filter","checkExport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","parseImportSource","mixinPluginNames","keys","defaultOptions","sourceType","sourceFilename","startLine","allowAwaitOutsideFunction","allowReturnOutsideFunction","allowImportExportEverywhere","allowSuperOutsideMethod","allowUndeclaredExports","strictMode","ranges","tokens","createParenthesizedExpressions","errorRecovery","State","endLoc","errors","potentialArrowAt","inPipeline","topicContext","maxNumOfResolvableTopics","maxTopicIndex","soloAwait","inFSharpPipelineDirectBody","labels","decoratorStack","comments","trailingComments","leadingComments","commentStack","commentPreviousNode","lastTokStartLoc","strictErrors","exportedIdentifiers","tokensLength","curPosition","skipArrays","_isDigit","VALID_REGEX_FLAGS","forbiddenNumericSeparatorSiblings","decBinOct","hex","allowedNumericSeparatorSiblings","bin","oct","dec","Token","ExpressionErrors","shorthandAssign","doubleProto","Node","parser","range","innerComments","unwrapParenthesizedExpression","ExpressionScope","ArrowHeadParsingScope","iterator","ExpressionScopeHandler","isCertainlyParameterDeclaration","canBeArrowParameterDeclaration","recordDeclarationError","iterateErrors","clearDeclarationError","newExpressionScope","loopLabel","switchLabel","loneSurrogate","ClassScope","privateNames","loneAccessors","ClassScopeHandler","oldClassScope","_Array$from","from","classScope","redefined","CLASS_ELEMENT_KIND_GETTER","accessor","get","oldStatic","newStatic","_this$stack","Parser","sawUnambiguousESM","ambiguousScriptDifferentAst","takeAllComments","lastElement","j","splice","newTrailingComments","leadingComment","firstChild","lastChild","lastInStack","adjustCommentsAfterTrailingComma","firstTrailingCommentIndex","findIndex","offset","lastIndex","index","getLineInfo","errorTemplate","raiseWithData","data","getLocationForPosition","replace","_","_raise","errorContext","err","SyntaxError","isLookahead","checkKeywordEscapes","pushToken","old","curr","clear","skipSpace","codePointAt","block","text","pushComment","startSkip","loop","skipLineComment","readToken_interpreter","nextPos","readNumber","readRegexp","width","size","next2","readToken_dot","readToken_question","readRadixNumber","readString","readToken_slash","readToken_caret","readToken_plus_min","readToken_eq_excl","readToken_numberSign","escaped","charAt","content","mods","char","charCode","radix","len","forceLen","allowNumSeparator","forbiddenSiblings","allowedSiblings","total","Infinity","prev","Number","isNaN","isBigInt","readInt","startsWithDot","isFloat","isDecimal","hasExponent","isOctal","hasLeadingZero","integer","recordStrictModeErrors","underscorePos","parseFloat","throwOnInvalid","codePos","readHexChar","readEscapedChar","containsInvalid","inTemplate","readCodePoint","octalStr","octal","n","escStart","identifierCheck","esc","readWord1","parent","update","op","nameStart","nameEnd","messageOrType","missingPlugin","names","join","fn","oldState","abortSignal","andThrow","isPrivateName","processComment","locationNode","_node$extra3","expressionScope","recordParenthesizedIdentifierError","_node$extra2","isLast","raiseRestNotLast","checkToRestConversion","arg","raiseTrailingCommaAfterRest","toReferencedListDeep","parseObjectLike","closeCharCode","allowEmpty","elts","first","parseRestBinding","checkCommaAfterRest","parseDecorator","parseAssignableListItem","_startLoc","_startPos","_left","checkClashes","disallowLetBinding","strictModeChanged","_expr$properties","isObjectMethod","_expr$elements","elem","isRecord","protoRef","computed","used","paramFlags","disallowIn","disallowInAnd","parseExpressionBase","allowInAnd","expressions","parseYield","ownExpressionErrors","parseMaybeConditional","checkExpressionErrors","parseExprOps","shouldExitDescending","prec","checkPipelineAtInfixOperator","logical","coalesce","parseExprOpRightExpr","nextOp","withTopicPermittingContext","parseSmartPipelineBody","parseExprOpBaseRightExpr","withSoloAwaitPermittingContext","parseFSharpPipelineBody","isAwaitAllowed","parseAwait","isDelete","parseUpdate","parseExprSubscripts","maybeAsyncArrow","parseBind","parseCoverCallAndAsyncArrowHead","parseMember","parseMaybePrivateName","usePrivateName","getPrivateNameSV","parseNoCallExpr","validateAsPattern","tag","quasi","_node$arguments","possibleAsyncArrow","dynamicImport","allowPlaceholder","nodeForExtra","oldInFSharpPipelineDirectBody","parseExprListItem","_call$extra","parseSuper","parseImportMetaProperty","parseFunction","parseAsyncArrowUnaryFunction","parseDo","parseFunctionOrFunctionSent","parseDecorators","parseNewOrNewTarget","primaryTopicReferenceIsAllowedInCurrentTopicContext","registerTopicReference","nextCh","lookaheadCh","expectOnePlugin","oldLabels","meta","parseMetaProperty","propertyName","innerStartPos","innerStartLoc","spreadStart","optionalCommaStart","spreadNodeStartPos","spreadNodeStartLoc","innerEndPos","innerEndLoc","arrowNode","metaProp","parseNew","isOptionalChain","parseExprList","isTagged","cooked","tail","curElt","parseTemplateElement","quasis","propHash","create","parsePropertyDefinition","checkProto","parseSpread","maybeAsyncOrAccessorProp","keyName","_params","checkGetterSetterParams","oldInPropertyName","generator","isExpression","hasStrictModeDirective","nonSimple","isSimpleParamList","errorPos","_node$params","recordAsyncArrowParametersError","recordParameterInitializerError","delegate","childExpression","checkSmartPipelineBodyEarlyErrors","parseSmartPipelineBodyInStyle","isSimpleReference","topicReferenceWasUsedInCurrentTopicContext","callback","outerContextTopicState","outerContextSoloAwaitState","ret","interpreter","parseInterpreterDirective","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseWhileStatement","parseWithStatement","parseEmptyStatement","nextTokenCharCode","isAsyncFunction","maybeName","parseLabeledStatement","allowExport","currentContextDecorators","decorator","isBreak","lab","withTopicForbiddingContext","parseHeaderExpression","awaitAt","parseFor","parseVar","declarations","parseForIn","description","declarationPosition","discriminant","cases","cur","sawDefault","isCase","simple","handler","clause","finalizer","_this$state$labels","statementStart","allowDirectives","createNewLexicalScope","afterBlockParse","parsedNonDirective","setStrict","isForIn","await","isFor","isTypescript","parseMaybeAssignDisallowIn","statement","isHangingStatement","requireId","constructorAllowsSuper","hadConstructor","hadStaticBlock","parseClassStaticBlock","publicMethod","privateMethod","publicProp","privateProp","publicMember","parseClassElementName","isPrivate","isSimple","maybeQuestionTokenStart","parsePostMemberNameModifiers","pushClassPrivateProperty","pushClassProperty","_member$decorators","SCOPE_CLASS","declarePrivateName","CLASS_ELEMENT_KIND_SETTER","parseInitializer","hasDefault","parseAfterDefault","hasStar","parseAfterNamespace","isFromRequired","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","FUNC_STATEMENT","l","hasFrom","nextAfterFrom","assertions","maybeParseImportAssertions","checkNames","isDefault","isFrom","checkDuplicateExports","_declaration$extra","_node$specifiers","exportedName","_node$declaration$dec","_i5","_node$properties","_i6","_node$elements","nodes","surrogate","toString","parseNext","maybeParseModuleAttributes","attrs","attrNames","parseAssertEntries","parseImportSpecifierLocal","parseImportSpecifier","opts","_Object$keys","getOptions","getScopeHandler","pluginMap","pluginsMap","getParser","decoratorsBeforeExport","validatePlugins","pluginsFromOptions","pluginList","parserClassCache","getParserClass","_options","ast","moduleError","_unused2","getExpression","tokTypes"],"mappings":"CAACA,OAAyB,iBAAIA,OAAyB,kBAAK,IAAIC,KAAK,CAAC,CAAC,GAAG,CAEpEC,KACA,SAAUC,EAAQC,EAASC,GAEjC,aAGAC,OAAOC,eAAeH,EAAS,aAAc,CAAEI,OAAO,IAEtD,MAAMC,GAAa,EACbC,GAAa,EACbC,GAAS,EAETC,GAAS,EAEf,MAAMC,EACJC,YAAYC,EAAOC,EAAO,IACxBC,KAAKF,WAAQ,EACbE,KAAKC,aAAU,EACfD,KAAKR,gBAAa,EAClBQ,KAAKP,gBAAa,EAClBO,KAAKE,sBAAmB,EACxBF,KAAKN,YAAS,EACdM,KAAKG,cAAW,EAChBH,KAAKL,YAAS,EACdK,KAAKI,aAAU,EACfJ,KAAKK,WAAQ,EACbL,KAAKM,mBAAgB,EACrBN,KAAKF,MAAQA,EACbE,KAAKC,QAAUF,EAAKE,QACpBD,KAAKR,aAAeO,EAAKP,WACzBQ,KAAKP,aAAeM,EAAKN,WACzBO,KAAKE,mBAAqBH,EAAKG,iBAC/BF,KAAKN,SAAWK,EAAKL,OACrBM,KAAKG,WAAaJ,EAAKI,SACvBH,KAAKL,SAAWI,EAAKJ,OACrBK,KAAKI,UAAYL,EAAKK,QACtBJ,KAAKK,MAAsB,MAAdN,EAAKM,MAAgBN,EAAKM,MAAQ,KAC/CL,KAAKM,cAAgB,MAIzB,MAAMC,EAAW,IAAIC,IAErB,SAASC,EAAcC,EAAMC,EAAU,IACrCA,EAAQV,QAAUS,EAClB,MAAME,EAAQ,IAAIhB,EAAUc,EAAMC,GAElC,OADAJ,EAASM,IAAIH,EAAME,GACZA,EAGT,SAASE,EAAYJ,EAAML,GACzB,OAAO,IAAIT,EAAUc,EAAM,CACzBlB,WAAAA,EACAa,MAAAA,IAIJ,MAAMU,EAAQ,CACZC,IAAK,IAAIpB,EAAU,MAAO,CACxBH,WAAAA,IAEFwB,OAAQ,IAAIrB,EAAU,SAAU,CAC9BH,WAAAA,IAEFyB,QAAS,IAAItB,EAAU,UAAW,CAChCH,WAAAA,IAEF0B,OAAQ,IAAIvB,EAAU,SAAU,CAC9BH,WAAAA,IAEF2B,OAAQ,IAAIxB,EAAU,SAAU,CAC9BH,WAAAA,IAEFiB,KAAM,IAAId,EAAU,OAAQ,CAC1BH,WAAAA,IAEF4B,IAAK,IAAIzB,EAAU,OACnB0B,SAAU,IAAI1B,EAAU,IAAK,CAC3BJ,WAAAA,EACAC,WAAAA,IAEF8B,aAAc,IAAI3B,EAAU,KAAM,CAChCJ,WAAAA,EACAC,WAAAA,IAEF+B,YAAa,IAAI5B,EAAU,KAAM,CAC/BJ,WAAAA,EACAC,WAAAA,IAEFgC,SAAU,IAAI7B,EAAU,KACxB8B,YAAa,IAAI9B,EAAU,MAC3B+B,OAAQ,IAAI/B,EAAU,IAAK,CACzBJ,WAAAA,EACAC,WAAAA,IAEFmC,UAAW,IAAIhC,EAAU,KAAM,CAC7BJ,WAAAA,EACAC,WAAAA,IAEFoC,WAAY,IAAIjC,EAAU,KAAM,CAC9BJ,WAAAA,EACAC,WAAAA,IAEFqC,OAAQ,IAAIlC,EAAU,KACtBmC,UAAW,IAAInC,EAAU,MACzBoC,OAAQ,IAAIpC,EAAU,IAAK,CACzBJ,WAAAA,EACAC,WAAAA,IAEFwC,OAAQ,IAAIrC,EAAU,KACtBsC,MAAO,IAAItC,EAAU,IAAK,CACxBJ,WAAAA,IAEF2C,KAAM,IAAIvC,EAAU,IAAK,CACvBJ,WAAAA,IAEF4C,MAAO,IAAIxC,EAAU,IAAK,CACxBJ,WAAAA,IAEF6C,YAAa,IAAIzC,EAAU,KAAM,CAC/BJ,WAAAA,IAEF8C,IAAK,IAAI1C,EAAU,KACnB2C,SAAU,IAAI3C,EAAU,IAAK,CAC3BJ,WAAAA,IAEFgD,YAAa,IAAI5C,EAAU,MAC3B6C,MAAO,IAAI7C,EAAU,KAAM,CACzBJ,WAAAA,IAEFkD,SAAU,IAAI9C,EAAU,YACxB+C,SAAU,IAAI/C,EAAU,MAAO,CAC7BJ,WAAAA,IAEFoD,UAAW,IAAIhD,EAAU,IAAK,CAC5BH,WAAAA,IAEFoD,aAAc,IAAIjD,EAAU,KAAM,CAChCJ,WAAAA,EACAC,WAAAA,IAEFqD,GAAI,IAAIlD,EAAU,KAClBmD,KAAM,IAAInD,EAAU,IAAK,CACvBH,WAAAA,IAEFuD,qBAAsB,IAAIpD,EAAU,SACpCqD,GAAI,IAAIrD,EAAU,IAAK,CACrBJ,WAAAA,EACAW,SAzIa,OA2If+C,OAAQ,IAAItD,EAAU,KAAM,CAC1BJ,WAAAA,EACAW,SA7Ia,OA+IfgD,OAAQ,IAAIvD,EAAU,QAAS,CAC7BD,OAAAA,EACAS,SA/IY,EAgJZX,WAAAA,IAEF2D,KAAM,IAAIxD,EAAU,IAAK,CACvBJ,WAAAA,EACAG,OAAAA,EACAF,WAAAA,IAEF4D,MAAO,IAAIzD,EAAU,IAAK,CACxBJ,WAAAA,EACAG,OAAAA,EACAF,WAAAA,IAEF6D,SAAUxC,EAAY,KAAM,GAC5ByC,kBAAmBzC,EAAY,KAAM,GACrC0C,UAAW1C,EAAY,KAAM,GAC7B2C,WAAY3C,EAAY,KAAM,GAC9B4C,UAAW5C,EAAY,IAAK,GAC5B6C,WAAY7C,EAAY,IAAK,GAC7B8C,WAAY9C,EAAY,IAAK,GAC7B+C,SAAU/C,EAAY,gBAAiB,GACvCgD,WAAYhD,EAAY,YAAa,GACrCiD,SAAUjD,EAAY,YAAa,GACnCkD,QAAS,IAAIpE,EAAU,MAAO,CAC5BJ,WAAAA,EACAa,MAAO,EACPV,OAAAA,EACAF,WAAAA,IAEFwE,OAAQ,IAAIrE,EAAU,IAAK,CACzBJ,WAAAA,EACAa,MAAO,GACPZ,WAAAA,IAEFyE,KAAM,IAAItE,EAAU,IAAK,CACvBS,MAAO,KAET8D,MAAOrD,EAAY,IAAK,IACxBsD,SAAU,IAAIxE,EAAU,KAAM,CAC5BJ,WAAAA,EACAa,MAAO,GACPH,kBAAkB,IAEpBmE,OAAQ5D,EAAc,SACtB6D,MAAO7D,EAAc,OAAQ,CAC3BjB,WAAAA,IAEF+E,OAAQ9D,EAAc,SACtB+D,UAAW/D,EAAc,YACzBgE,UAAWhE,EAAc,YACzBiE,SAAUjE,EAAc,UAAW,CACjCjB,WAAAA,IAEFmF,IAAKlE,EAAc,KAAM,CACvBf,OAAAA,EACAF,WAAAA,IAEFoF,MAAOnE,EAAc,OAAQ,CAC3BjB,WAAAA,IAEFqF,SAAUpE,EAAc,WACxBqE,KAAMrE,EAAc,MAAO,CACzBf,OAAAA,IAEFqF,UAAWtE,EAAc,WAAY,CACnChB,WAAAA,IAEFuF,IAAKvE,EAAc,MACnBwE,QAASxE,EAAc,SAAU,CAC/BjB,WAAAA,IAEF0F,QAASzE,EAAc,UACvB0E,OAAQ1E,EAAc,QAAS,CAC7BjB,WAAAA,EACAG,OAAAA,EACAF,WAAAA,IAEF2F,KAAM3E,EAAc,OACpB4E,KAAM5E,EAAc,OACpB6E,OAAQ7E,EAAc,SACtB8E,OAAQ9E,EAAc,QAAS,CAC7Bf,OAAAA,IAEF8F,MAAO/E,EAAc,QACrBgF,KAAMhF,EAAc,MAAO,CACzBjB,WAAAA,EACAC,WAAAA,IAEFiG,MAAOjF,EAAc,OAAQ,CAC3BhB,WAAAA,IAEFkG,OAAQlF,EAAc,QAAS,CAC7BhB,WAAAA,IAEFmG,OAAQnF,EAAc,QAAS,CAC7BhB,WAAAA,IAEFoG,SAAUpF,EAAc,UAAW,CACjCjB,WAAAA,IAEFsG,QAASrF,EAAc,UACvBsF,QAAStF,EAAc,SAAU,CAC/BhB,WAAAA,IAEFuG,MAAOvF,EAAc,OAAQ,CAC3BhB,WAAAA,IAEFwG,MAAOxF,EAAc,OAAQ,CAC3BhB,WAAAA,IAEFyG,OAAQzF,EAAc,QAAS,CAC7BhB,WAAAA,IAEF0G,IAAK1F,EAAc,KAAM,CACvBjB,WAAAA,EACAa,MAAO,IAET+F,YAAa3F,EAAc,aAAc,CACvCjB,WAAAA,EACAa,MAAO,IAETgG,QAAS5F,EAAc,SAAU,CAC/BjB,WAAAA,EACAG,OAAAA,EACAF,WAAAA,IAEF6G,MAAO7F,EAAc,OAAQ,CAC3BjB,WAAAA,EACAG,OAAAA,EACAF,WAAAA,IAEF8G,QAAS9F,EAAc,SAAU,CAC/BjB,WAAAA,EACAG,OAAAA,EACAF,WAAAA,KAIE+G,EAAY,yBACZC,EAAa,IAAIC,OAAOF,EAAUG,OAAQ,KAChD,SAASC,EAAUC,GACjB,OAAQA,GACN,KAAK,GACL,KAAK,GACL,KAAK,KACL,KAAK,KACH,OAAO,EAET,QACE,OAAO,GAGb,MAAMC,EAAiB,gCACvB,SAASC,EAAaF,GACpB,OAAQA,GACN,KAAK,EACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,IACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,MACL,KAAK,MACH,OAAO,EAET,QACE,OAAO,GAIb,MAAMG,EACJnH,YAAYoH,EAAMC,GAChBlH,KAAKiH,UAAO,EACZjH,KAAKmH,YAAS,EACdnH,KAAKiH,KAAOA,EACZjH,KAAKmH,OAASD,GAIlB,MAAME,EACJvH,YAAYwH,EAAOC,GACjBtH,KAAKqH,WAAQ,EACbrH,KAAKsH,SAAM,EACXtH,KAAKuH,cAAW,EAChBvH,KAAKwH,oBAAiB,EACtBxH,KAAKqH,MAAQA,EACbrH,KAAKsH,IAAMA,GAkCf,SAASG,EAAKC,GACZ,OAAOA,EAAMA,EAAMC,OAAS,GAgM9B,MAAMC,EAAgBvI,OAAOwI,OAAO,CAClCC,oBAAqB,gCACrBC,iBAAkB,6DAClBC,sCAAuC,0EACvCC,uBAAwB,6DACxBC,+BAAgC,oDAChCC,uBAAwB,kFACxBC,wBAAyB,iDACzBC,eAAgB,6CAChBC,eAAgB,gDAChBC,uBAAwB,wDACxBC,sBAAuB,mDACvBC,6BAA8B,4DAC9BC,sBAAuB,2CACvBC,mBAAoB,yCACpBC,uBAAwB,mCACxBC,8BAA+B,qCAC/BC,sBAAuB,mKACvBC,qBAAsB,kFACtBC,qBAAsB,mHACtBC,mBAAoB,iDACpBC,qBAAsB,+CACtBC,mBAAoB,0CACpBC,uBAAwB,qGACxBC,qBAAsB,0CACtBC,uBAAwB,8CACxBC,gBAAiB,uEACjBC,eAAgB,qCAChBC,qBAAsB,oCACtBC,qBAAsB,2CACtBC,iBAAkB,oCAClBC,2BAA4B,yBAC5BC,sBAAuB,uIACvBC,8BAA+B,gEAC/BC,uBAAwB,2DACxBC,kCAAmC,qEACnCC,qBAAsB,iBACtBC,6BAA8B,4EAC9BC,cAAe,+BACfC,sBAAuB,oGACvBC,gCAAiC,4DACjCC,gBAAiB,+BACjBC,2BAA4B,kCAC5BC,yBAA0B,iCAC1BC,wBAAyB,4DACzBC,oBAAqB,sEACrBC,qBAAsB,wBACtBC,iBAAkB,2BAClBC,eAAgB,kBAChBC,aAAc,8BACdC,sBAAuB,gCACvBC,8BAA+B,sCAC/BC,2BAA4B,gCAC5BC,kBAAmB,wBACnBC,WAAY,+BACZC,kBAAmB,uCACnBC,cAAe,iBACfC,yBAA0B,gEAC1BC,yBAA0B,4BAC1BC,+BAAgC,2CAChCC,8BAA+B,kCAC/BC,8BAA+B,4BAC/BC,sBAAuB,wEACvBC,6BAA8B,mCAC9BC,mBAAoB,iCACpBC,oBAAqB,8EACrBC,0BAA2B,uCAC3BC,qBAAsB,kCACtBC,iBAAkB,2BAClBC,sBAAuB,8DACvBC,qBAAsB,4CACtBC,0BAA2B,qFAC3BC,iCAAkC,+CAClCC,4BAA6B,8DAC7BC,kCAAmC,yDACnCC,iCAAkC,gEAClCC,sBAAuB,6BACvBC,yBAA0B,2BAC1BC,kBAAmB,8BACnBC,iBAAkB,kCAClBC,iBAAkB,mCAClBC,iCAAkC,6FAClCC,kBAAmB,wFACnBC,sBAAuB,0DACvBC,2BAA4B,4DAC5BC,UAAW,sBACXC,mBAAoB,gDACpBC,iBAAkB,uCAClBC,oBAAqB,mGACrBC,+BAAgC,iEAChCC,+BAAgC,oEAChCC,oBAAqB,8DACrBC,uBAAwB,sEACxBC,kCAAmC,+FACnCC,oBAAqB,wGACrBC,yBAA0B,6BAC1BC,0CAA2C,mIAC3CC,4CAA6C,qIAC7CC,6CAA8C,sIAC9CC,cAAe,mDACfC,kBAAmB,+CACnBC,eAAgB,0HAChBC,gBAAiB,uDACjBC,aAAc,yCACdC,oBAAqB,mCACrBC,2BAA4B,8BAC5BC,eAAgB,qFAChBC,oBAAqB,wDACrBC,mBAAoB,uDACpBC,WAAY,wBACZC,gBAAiB,kJACjBC,kBAAmB,4CACnBC,kBAAmB,iDACnBC,yCAA0C,kIAC1CC,2CAA4C,oIAC5CC,4CAA6C,qIAC7CC,8BAA+B,kCAC/BC,iCAAkC,0FAClCC,yBAA0B,oCAC1BC,uBAAwB,yDACxBC,kBAAmB,0BACnBC,2BAA4B,6DAC5BC,6BAA8B,kEAC9BC,oBAAqB,2CACrBC,2BAA4B,yDAC5BC,uBAAwB,0JACxBC,uBAAwB,gCACxBC,gBAAiB,sDACjBC,gBAAiB,wBACjBC,mCAAoC,mFACpCC,gBAAiB,kDACjBC,2BAA4B,qDAC5BC,yBAA0B,8EAC1BC,kBAAmB,qDACnBC,wBAAyB,+CACzBC,8BAA+B,mDAC/BC,6BAA8B,kEAC9BC,iBAAkB,qHAClBC,oBAAqB,uBACrBC,mBAAoB,kCACpBC,mBAAoB,+BACpBC,qBAAsB,wBACtBC,iBAAkB,4CAClBC,uBAAwB,uDACxBC,iBAAkB,uDAClBC,0BAA2B,sDA8T7B,MAAMC,EACJlR,YAAYe,EAAOoQ,EAAQC,EAAeC,GACxClR,KAAKY,WAAQ,EACbZ,KAAKgR,YAAS,EACdhR,KAAKiR,mBAAgB,EACrBjR,KAAKkR,cAAW,EAChBlR,KAAKY,MAAQA,EACbZ,KAAKgR,SAAWA,EAChBhR,KAAKiR,gBAAkBA,EACvBjR,KAAKkR,SAAWA,GAIpB,MAAMC,EAAU,CACdC,eAAgB,IAAIL,EAAW,KAAK,GACpCM,gBAAiB,IAAIN,EAAW,KAAK,GACrCO,iBAAkB,IAAIP,EAAW,MAAM,GACvCQ,cAAe,IAAIR,EAAW,MAAM,GACpCS,eAAgB,IAAIT,EAAW,KAAK,GACpCU,gBAAiB,IAAIV,EAAW,KAAK,GACrCrO,SAAU,IAAIqO,EAAW,KAAK,GAAM,GAAMW,GAAKA,EAAEC,kBACjDC,mBAAoB,IAAIb,EAAW,YAAY,GAC/Cc,kBAAmB,IAAId,EAAW,YAAY,IAGhDhQ,EAAMkB,OAAO3B,cAAgBS,EAAMe,OAAOxB,cAAgB,WACxD,GAAkC,IAA9BN,KAAK8R,MAAMC,QAAQpK,OAErB,YADA3H,KAAK8R,MAAME,aAAc,GAI3B,IAAIC,EAAMjS,KAAK8R,MAAMC,QAAQG,MAEzBD,IAAQd,EAAQC,gBAA8C,aAA5BpR,KAAKmS,aAAavR,QACtDqR,EAAMjS,KAAK8R,MAAMC,QAAQG,OAG3BlS,KAAK8R,MAAME,aAAeC,EAAIjB,QAGhCjQ,EAAML,KAAKJ,cAAgB,SAAU8R,GACnC,IAAIC,GAAU,EAEVD,IAAarR,EAAMuB,MACI,OAArBtC,KAAK8R,MAAMvS,OAAmBS,KAAK8R,MAAME,aAAeI,IAAarR,EAAMgE,WAAaqN,IAAarR,EAAM6E,SAC7GyM,GAAU,IAIdrS,KAAK8R,MAAME,YAAcK,EAErBrS,KAAK8R,MAAMQ,aACbtS,KAAK8R,MAAMQ,YAAa,IAI5BvR,EAAMY,OAAOrB,cAAgB,SAAU8R,GACrCpS,KAAK8R,MAAMC,QAAQ/S,KAAKgB,KAAKuS,aAAaH,GAAYjB,EAAQC,eAAiBD,EAAQE,iBACvFrR,KAAK8R,MAAME,aAAc,GAG3BjR,EAAM8B,aAAavC,cAAgB,WACjCN,KAAK8R,MAAMC,QAAQ/S,KAAKmS,EAAQI,eAChCvR,KAAK8R,MAAME,aAAc,GAG3BjR,EAAMiB,OAAO1B,cAAgB,SAAU8R,GACrC,MAAMI,EAAkBJ,IAAarR,EAAMiE,KAAOoN,IAAarR,EAAM+D,MAAQsN,IAAarR,EAAMyE,OAAS4M,IAAarR,EAAMwE,OAC5HvF,KAAK8R,MAAMC,QAAQ/S,KAAKwT,EAAkBrB,EAAQK,eAAiBL,EAAQM,iBAC3EzR,KAAK8R,MAAME,aAAc,GAG3BjR,EAAMoC,OAAO7C,cAAgB,aAE7BS,EAAMgE,UAAUzE,cAAgBS,EAAM6E,OAAOtF,cAAgB,SAAU8R,IACjEA,EAAS5S,YAAc4S,IAAarR,EAAMoB,MAAQiQ,IAAarR,EAAM6D,OAAWwN,IAAarR,EAAMkE,SAAWjF,KAAKyS,0BAA+BL,IAAarR,EAAMqB,OAASgQ,IAAarR,EAAMY,SAAW3B,KAAKmS,eAAiBhB,EAAQuB,OAG5O1S,KAAK8R,MAAMC,QAAQ/S,KAAKmS,EAAQU,mBAFhC7R,KAAK8R,MAAMC,QAAQ/S,KAAKmS,EAAQS,oBAKlC5R,KAAK8R,MAAME,aAAc,GAG3BjR,EAAM6B,UAAUtC,cAAgB,WAC1BN,KAAKmS,eAAiBhB,EAAQzO,SAChC1C,KAAK8R,MAAMC,QAAQG,MAEnBlS,KAAK8R,MAAMC,QAAQ/S,KAAKmS,EAAQzO,UAGlC1C,KAAK8R,MAAME,aAAc,GAG3BjR,EAAMc,WAAWvB,cAAgB,WAC/BN,KAAK8R,MAAMC,QAAQ/S,KAAKmS,EAAQG,kBAChCtR,KAAK8R,MAAME,aAAc,GAG3B,IAAIW,EAA+B,wrIAC/BC,EAA0B,ujFAC9B,MAAMC,EAA0B,IAAInM,OAAO,IAAMiM,EAA+B,KAC1EG,EAAqB,IAAIpM,OAAO,IAAMiM,EAA+BC,EAA0B,KACrGD,EAA+BC,EAA0B,KACzD,MAAMG,EAA6B,CAAC,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,IAAK,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,IAAK,IAAK,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,KAAM,EAAG,KAAM,GAAI,EAAG,KAAM,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,KAAM,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,KAAM,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,KAAM,GAAI,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,KAAM,IAAK,GAAI,GAAI,EAAG,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,KAAM,MAAO,GAAI,KAAM,GAAI,IAAK,EAAG,KAAM,GAAI,KAAM,KAAM,IAAK,KAAM,MAC3wDC,EAAwB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,MAAO,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,MAAO,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,KAAM,GAAI,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,IAAK,GAAI,KAAM,EAAG,IAAK,EAAG,EAAG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"},"name":"static/chunks/18012ef3.e7338780f50214fc57f1.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[6],{\n\n/***/ \"oGoC\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass TokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.updateContext = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n\n}\nconst keywords = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = new TokenType(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return new TokenType(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nconst types = {\n  num: new TokenType(\"num\", {\n    startsExpr\n  }),\n  bigint: new TokenType(\"bigint\", {\n    startsExpr\n  }),\n  decimal: new TokenType(\"decimal\", {\n    startsExpr\n  }),\n  regexp: new TokenType(\"regexp\", {\n    startsExpr\n  }),\n  string: new TokenType(\"string\", {\n    startsExpr\n  }),\n  name: new TokenType(\"name\", {\n    startsExpr\n  }),\n  eof: new TokenType(\"eof\"),\n  bracketL: new TokenType(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: new TokenType(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: new TokenType(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: new TokenType(\"]\"),\n  bracketBarR: new TokenType(\"|]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: new TokenType(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: new TokenType(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", {\n    beforeExpr\n  }),\n  semi: new TokenType(\";\", {\n    beforeExpr\n  }),\n  colon: new TokenType(\":\", {\n    beforeExpr\n  }),\n  doubleColon: new TokenType(\"::\", {\n    beforeExpr\n  }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", {\n    beforeExpr\n  }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", {\n    beforeExpr\n  }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", {\n    beforeExpr\n  }),\n  backQuote: new TokenType(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: new TokenType(\"#!...\"),\n  eq: new TokenType(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: new TokenType(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: new TokenType(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: new TokenType(\"%\", {\n    beforeExpr,\n    binop: 10,\n    startsExpr\n  }),\n  star: new TokenType(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  })\n};\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass Position {\n  constructor(line, col) {\n    this.line = void 0;\n    this.column = void 0;\n    this.line = line;\n    this.column = col;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction getLineInfo(input, offset) {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(name) {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin, name) {\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n\n}\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  }\n\n  adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {\n    if (this.state.leadingComments.length === 0) {\n      return;\n    }\n\n    let lastElement = null;\n    let i = elements.length;\n\n    while (lastElement === null && i > 0) {\n      lastElement = elements[--i];\n    }\n\n    if (lastElement === null) {\n      return;\n    }\n\n    for (let j = 0; j < this.state.leadingComments.length; j++) {\n      if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n        this.state.leadingComments.splice(j, 1);\n        j--;\n      }\n    }\n\n    const newTrailingComments = [];\n\n    for (let i = 0; i < this.state.leadingComments.length; i++) {\n      const leadingComment = this.state.leadingComments[i];\n\n      if (leadingComment.end < node.end) {\n        newTrailingComments.push(leadingComment);\n\n        if (!takeAllComments) {\n          this.state.leadingComments.splice(i, 1);\n          i--;\n        }\n      } else {\n        if (node.trailingComments === undefined) {\n          node.trailingComments = [];\n        }\n\n        node.trailingComments.push(leadingComment);\n      }\n    }\n\n    if (takeAllComments) this.state.leadingComments = [];\n\n    if (newTrailingComments.length > 0) {\n      lastElement.trailingComments = newTrailingComments;\n    } else if (lastElement.trailingComments !== undefined) {\n      lastElement.trailingComments = [];\n    }\n  }\n\n  processComment(node) {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n    const stack = this.state.commentStack;\n    let firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        this.state.trailingComments.length = 0;\n      }\n    } else if (stack.length > 0) {\n      const lastInStack = last(stack);\n\n      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n        trailingComments = lastInStack.trailingComments;\n        delete lastInStack.trailingComments;\n      }\n    }\n\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild;\n\n    if (firstChild) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties);\n          break;\n\n        case \"ObjectPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties, true);\n          break;\n\n        case \"CallExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.arguments);\n          break;\n\n        case \"ArrayExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements);\n          break;\n\n        case \"ArrayPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements, true);\n          break;\n      }\n    } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === \"ImportSpecifier\" && node.type !== \"ImportSpecifier\" || this.state.commentPreviousNode.type === \"ExportSpecifier\" && node.type !== \"ExportSpecifier\")) {\n      this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        } else {\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        }\n\n        const leadingComments = this.state.leadingComments.slice(0, i);\n\n        if (leadingComments.length) {\n          node.leadingComments = leadingComments;\n        }\n\n        trailingComments = this.state.leadingComments.slice(i);\n\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n        node.innerComments = trailingComments;\n      } else {\n        const firstTrailingCommentIndex = trailingComments.findIndex(comment => comment.end >= node.end);\n\n        if (firstTrailingCommentIndex > 0) {\n          node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);\n          node.trailingComments = trailingComments.slice(firstTrailingCommentIndex);\n        } else {\n          node.trailingComments = trailingComments;\n        }\n      }\n    }\n\n    stack.push(node);\n  }\n\n}\n\nconst ErrorMessages = Object.freeze({\n  AccessorIsGenerator: \"A %0ter cannot be a generator\",\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function\",\n  AwaitExpressionFormalParameter: \"await is not allowed in async function parameters\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions\",\n  BadGetterArity: \"getter must not have any formal parameters\",\n  BadSetterArity: \"setter must have exactly one formal parameter\",\n  BadSetterRestParameter: \"setter function argument must not be a rest parameter\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor\",\n  ConstructorIsAsync: \"Constructor can't be an async function\",\n  ConstructorIsGenerator: \"Constructor can't be a generator\",\n  DeclarationMissingInitializer: \"%0 require an initialization value\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block\",\n  DeletePrivateField: \"Deleting a private field is not allowed\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: \"`%0` has already been exported. Exported identifiers must be unique.\",\n  DuplicateProto: \"Redefinition of __proto__ property\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag\",\n  DuplicateStaticBlock: \"Duplicate static block in the same class\",\n  ElementAfterRest: \"Rest element must be last element\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape\",\n  ExportBindingIsString: \"A string literal cannot be used as an exported binding without `from`.\\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?\",\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'\",\n  ForInOfLoopInitializer: \"%0 loop variable declaration may not have an initializer\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block\",\n  IllegalBreakContinue: \"Unsyntactic %0\",\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list\",\n  IllegalReturn: \"'return' outside of function\",\n  ImportBindingIsString: 'A string literal cannot be used as an imported binding.\\n- Did you mean `import { \"%0\" as foo }`?',\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments\",\n  ImportCallArity: \"import() requires exactly %0\",\n  ImportCallNotNewExpression: \"Cannot use new with import(...)\",\n  ImportCallSpreadArgument: \"... is not allowed in import()\",\n  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: \"module\"'`,\n  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral\",\n  InvalidCodePoint: \"Code point out of bounds\",\n  InvalidDecimal: \"Invalid decimal\",\n  InvalidDigit: \"Expected number in radix %0\",\n  InvalidEscapeSequence: \"Bad character escape sequence\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template\",\n  InvalidEscapedReservedWord: \"Escape sequence in keyword %0\",\n  InvalidIdentifier: \"Invalid identifier %0\",\n  InvalidLhs: \"Invalid left-hand side in %0\",\n  InvalidLhsBinding: \"Binding invalid left-hand side in %0\",\n  InvalidNumber: \"Invalid number\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'\",\n  InvalidOrUnexpectedToken: \"Unexpected character '%0'\",\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern\",\n  InvalidPrivateFieldResolution: \"Private name #%0 is not defined\",\n  InvalidPropertyBindingPattern: \"Binding member expression\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument\",\n  LabelRedeclaration: \"Label '%0' is already declared\",\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'\",\n  MalformedRegExpFlags: \"Invalid regular expression flag\",\n  MissingClassName: \"A class name is required\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values\",\n  ModuleAttributesWithDuplicateKeys: 'Duplicate key \"%0\" is not allowed in module attributes',\n  ModuleExportNameHasLoneSurrogate: \"An export name cannot include a lone surrogate, found '\\\\u%0'\",\n  ModuleExportUndefined: \"Export '%0' is not defined\",\n  MultipleDefaultsInSwitch: \"Multiple default clauses\",\n  NewlineAfterThrow: \"Illegal newline after throw\",\n  NoCatchOrFinally: \"Missing catch or finally clause\",\n  NumberIdentifier: \"Identifier directly after number\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",\n  ObsoleteAwaitStar: \"await* has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"constructors in/after an Optional Chain are not allowed\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain\",\n  ParamDupe: \"Argument name clash\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter\",\n  PatternHasMethod: \"Object pattern can't contain methods\",\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding\",\n  PrimaryTopicRequiresSmartPipeline: \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",\n  PrivateInExpectedIn: \"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)\",\n  PrivateNameRedeclaration: \"Duplicate private name #%0\",\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",\n  StaticPrototype: \"Classes may not have static property named prototype\",\n  StrictDelete: \"Deleting local variable in strict mode\",\n  StrictEvalArguments: \"Assigning to '%0' in strict mode\",\n  StrictEvalArgumentsBinding: \"Binding '%0' in strict mode\",\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode\",\n  StrictWith: \"'with' in strict mode\",\n  SuperNotAllowed: \"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super\",\n  TrailingDecorator: \"Decorators must be attached to a class element\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level\",\n  UnexpectedKeyword: \"Unexpected keyword '%0'\",\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context\",\n  UnexpectedNewTarget: \"new.target can only be used in functions\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits\",\n  UnexpectedPrivateField: \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n  UnexpectedReservedWord: \"Unexpected reserved word '%0'\",\n  UnexpectedSuper: \"super is only allowed in object methods and classes\",\n  UnexpectedToken: \"Unexpected token '%0'\",\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"import can only be used in import() or import.meta\",\n  UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1\",\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties\",\n  UnsupportedSuper: \"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",\n  UnterminatedComment: \"Unterminated comment\",\n  UnterminatedRegExp: \"Unterminated regular expression\",\n  UnterminatedString: \"Unterminated string constant\",\n  UnterminatedTemplate: \"Unterminated template\",\n  VarRedeclaration: \"Identifier '%0' has already been declared\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0\"\n});\n\nclass ParserError extends CommentsParser {\n  getLocationForPosition(pos) {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);\n    return loc;\n  }\n\n  raise(pos, errorTemplate, ...params) {\n    return this.raiseWithData(pos, undefined, errorTemplate, ...params);\n  }\n\n  raiseWithData(pos, data, errorTemplate, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = errorTemplate.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n    return this._raise(Object.assign({\n      loc,\n      pos\n    }, data), message);\n  }\n\n  _raise(errorContext, message) {\n    const err = new SyntaxError(message);\n    Object.assign(err, errorContext);\n\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n\n}\n\nvar estree = (superClass => class extends superClass {\n  estreeParseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  estreeParseBigIntLiteral(value) {\n    let bigInt;\n\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  estreeParseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.extra.expressionValue;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) == null ? void 0 : _stmt$expression$extr.parenthesized);\n  }\n\n  stmtToDirective(stmt) {\n    const directive = super.stmtToDirective(stmt);\n    const value = stmt.expression.value;\n    this.addExtra(directive.value, \"expressionValue\", value);\n    return directive;\n  }\n\n  parseBlockBody(node, ...args) {\n    super.parseBlockBody(node, ...args);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    switch (this.state.type) {\n      case types.num:\n      case types.string:\n        return this.estreeParseLiteral(this.state.value);\n\n      case types.regexp:\n        return this.estreeParseRegExpLiteral(this.state.value);\n\n      case types.bigint:\n        return this.estreeParseBigIntLiteral(this.state.value);\n\n      case types.decimal:\n        return this.estreeParseDecimalLiteral(this.state.value);\n\n      case types._null:\n        return this.estreeParseLiteral(null);\n\n      case types._true:\n        return this.estreeParseLiteral(true);\n\n      case types._false:\n        return this.estreeParseLiteral(false);\n\n      default:\n        return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    const node = super.parseLiteral(value, type, startPos, startLoc);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    type = type === \"ClassMethod\" ? \"MethodDefinition\" : type;\n    return this.finishNode(node, type);\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") node.kind = \"init\";\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.toAssignable(node.value, isLHS);\n      return node;\n    }\n\n    return super.toAssignable(node, isLHS);\n  }\n\n  toAssignableObjectExpressionProp(prop, ...args) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);\n    } else if (prop.method) {\n      this.raise(prop.key.start, ErrorMessages.PatternHasMethod);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, ...args);\n    }\n  }\n\n  finishCallExpression(node, optional) {\n    super.finishCallExpression(node, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n\n    super.toReferencedArguments(node);\n  }\n\n  parseExport(node) {\n    super.parseExport(node);\n\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n        break;\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n\n    return node;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n\n    return super.hasPropertyAsPrivateName(node);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"ChainExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n\n});\n\nclass TokContext {\n  constructor(token, isExpr, preserveSpace, override) {\n    this.token = void 0;\n    this.isExpr = void 0;\n    this.preserveSpace = void 0;\n    this.override = void 0;\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  }\n\n}\nconst types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  recordExpression: new TokContext(\"#{\", true),\n  templateQuasi: new TokContext(\"${\", false),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, p => p.readTmplToken()),\n  functionExpression: new TokContext(\"function\", true),\n  functionStatement: new TokContext(\"function\", false)\n};\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  let out = this.state.context.pop();\n\n  if (out === types$1.braceStatement && this.curContext().token === \"function\") {\n    out = this.state.context.pop();\n  }\n\n  this.state.exprAllowed = !out.isExpr;\n};\n\ntypes.name.updateContext = function (prevType) {\n  let allowed = false;\n\n  if (prevType !== types.dot) {\n    if (this.state.value === \"of\" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class) {\n      allowed = true;\n    }\n  }\n\n  this.state.exprAllowed = allowed;\n\n  if (this.state.isIterator) {\n    this.state.isIterator = false;\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {};\n\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && this.hasPrecedingLineBreak()) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.state.context.push(types$1.functionExpression);\n  } else {\n    this.state.context.push(types$1.functionStatement);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.braceHashL.updateContext = function () {\n  this.state.context.push(types$1.recordExpression);\n  this.state.exprAllowed = true;\n};\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords$1 = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords$1.has(word);\n}\n\nconst keywordRelationalOperator = /^in(stanceof)?$/;\nfunction isIteratorStart(current, next) {\n  return current === 64 && next === 64;\n}\n\nconst SCOPE_OTHER = 0b00000000,\n      SCOPE_PROGRAM = 0b00000001,\n      SCOPE_FUNCTION = 0b00000010,\n      SCOPE_ARROW = 0b00000100,\n      SCOPE_SIMPLE_CATCH = 0b00001000,\n      SCOPE_SUPER = 0b00010000,\n      SCOPE_DIRECT_SUPER = 0b00100000,\n      SCOPE_CLASS = 0b01000000,\n      SCOPE_TS_MODULE = 0b10000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b00000000001,\n      BIND_KIND_TYPE = 0b00000000010,\n      BIND_SCOPE_VAR = 0b00000000100,\n      BIND_SCOPE_LEXICAL = 0b00000001000,\n      BIND_SCOPE_FUNCTION = 0b00000010000,\n      BIND_FLAGS_NONE = 0b00001000000,\n      BIND_FLAGS_CLASS = 0b00010000000,\n      BIND_FLAGS_TS_ENUM = 0b00100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b01000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b10000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n      CLASS_ELEMENT_KIND_GETTER = 0b010,\n      CLASS_ELEMENT_KIND_SETTER = 0b001,\n      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n      CLASS_ELEMENT_OTHER = 0;\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = Object.freeze({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",\n  AssignReservedType: \"Cannot overwrite reserved type %0\",\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement\",\n  EnumBooleanMemberNotInitialized: \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n  EnumDuplicateMemberName: \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n  EnumInconsistentMemberValues: \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n  EnumInvalidExplicitType: \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidExplicitTypeUnknownSupplied: \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidMemberInitializerPrimaryType: \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n  EnumInvalidMemberInitializerSymbolType: \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n  EnumInvalidMemberInitializerUnknownType: \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n  EnumInvalidMemberName: \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n  EnumNumberMemberNotInitialized: \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n  EnumStringMemberInconsistentlyInitailized: \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment\",\n  OptionalBindingPattern: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  SpreadVariance: \"Spread properties cannot have variance\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object\",\n  UnexpectedReservedType: \"Unexpected reserved type %0\",\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\"',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",\n  UnsupportedDeclareExportKind: \"`declare export %0` is not supported. Use `%1` instead\",\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module\",\n  UnterminatedFlowComment: \"Unterminated flow-comment\"\n});\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state) {\n  return (state.type === types.name || !!state.type.keyword) && state.value !== \"from\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => {\n  var _temp;\n\n  return _temp = class extends superClass {\n    constructor(options, input) {\n      super(options, input);\n      this.flowPragma = void 0;\n      this.flowPragma = undefined;\n    }\n\n    shouldParseTypes() {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums() {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type, val) {\n      if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n\n      return super.finishToken(type, val);\n    }\n\n    addComment(comment) {\n      if (this.flowPragma === undefined) {\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n        if (!matches) ; else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n\n      return super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok) {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || types.colon);\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate() {\n      const node = this.startNode();\n      const moduloLoc = this.state.startLoc;\n      const moduloPos = this.state.start;\n      this.expect(types.modulo);\n      const checksLoc = this.state.startLoc;\n      this.expectContextual(\"checks\");\n\n      if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);\n      }\n\n      if (this.eat(types.parenL)) {\n        node.value = this.parseExpression();\n        this.expect(types.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser() {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(types.colon);\n      let type = null;\n      let predicate = null;\n\n      if (this.match(types.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n\n        if (this.match(types.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(node) {\n      this.next();\n      this.flowParseInterfaceish(node, true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(node) {\n      this.next();\n      const id = node.id = this.parseIdentifier();\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode();\n\n      if (this.isRelational(\"<\")) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(types.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      this.expect(types.parenR);\n      [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n      this.resetEndLocation(id);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(node, insideModule) {\n      if (this.match(types._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(types._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(types._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(\"module\")) {\n        if (this.match(types.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);\n          }\n\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(\"type\")) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(\"opaque\")) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(\"interface\")) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(types._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        throw this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(node) {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(true);\n      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(node) {\n      this.scope.enter(SCOPE_OTHER);\n\n      if (this.match(types.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = node.body = this.startNode();\n      const body = bodyNode.body = [];\n      this.expect(types.braceL);\n\n      while (!this.match(types.braceR)) {\n        let bodyNode = this.startNode();\n\n        if (this.match(types._import)) {\n          this.next();\n\n          if (!this.isContextual(\"type\") && !this.match(types._typeof)) {\n            this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);\n          }\n\n          this.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\"declare\", FlowErrors.UnsupportedStatementInDeclareModule);\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n      this.expect(types.braceR);\n      this.finishNode(bodyNode, \"BlockStatement\");\n      let kind = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n          }\n\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);\n          }\n\n          if (kind === \"ES\") {\n            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n          }\n\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(node, insideModule) {\n      this.expect(types._export);\n\n      if (this.eat(types._default)) {\n        if (this.match(types._function) || this.match(types._class)) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n\n        node.default = true;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (this.match(types._const) || this.isLet() || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !insideModule) {\n          const label = this.state.value;\n          const suggestion = exportSuggestions[label];\n          throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);\n        }\n\n        if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual(\"opaque\")) {\n            node.declaration = this.flowParseDeclare(this.startNode());\n            node.default = false;\n            return this.finishNode(node, \"DeclareExportDeclaration\");\n          } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) {\n            node = this.parseExport(node);\n\n            if (node.type === \"ExportNamedDeclaration\") {\n              node.type = \"ExportDeclaration\";\n              node.default = false;\n              delete node.exportKind;\n            }\n\n            node.type = \"Declare\" + node.type;\n            return node;\n          }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(node) {\n      this.next();\n      this.expectContextual(\"exports\");\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(node) {\n      this.next();\n      this.flowParseTypeAlias(node);\n      node.type = \"DeclareTypeAlias\";\n      return node;\n    }\n\n    flowParseDeclareOpaqueType(node) {\n      this.next();\n      this.flowParseOpaqueType(node, true);\n      node.type = \"DeclareOpaqueType\";\n      return node;\n    }\n\n    flowParseDeclareInterface(node) {\n      this.next();\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    flowParseInterfaceish(node, isClass = false) {\n      node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n      this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n      node.implements = [];\n      node.mixins = [];\n\n      if (this.eat(types._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(types.comma));\n      }\n\n      if (this.isContextual(\"mixins\")) {\n        this.next();\n\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      if (this.isContextual(\"implements\")) {\n        this.next();\n\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false\n      });\n    }\n\n    flowParseInterfaceExtends() {\n      const node = this.startNode();\n      node.id = this.flowParseQualifiedTypeIdentifier();\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node) {\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word) {\n      if (word === \"_\") {\n        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);\n      }\n    }\n\n    checkReservedType(word, startLoc, declaration) {\n      if (!reservedTypes.has(word)) return;\n      this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);\n    }\n\n    flowParseRestrictedIdentifier(liberal, declaration) {\n      this.checkReservedType(this.state.value, this.state.start, declaration);\n      return this.parseIdentifier(liberal);\n    }\n\n    flowParseTypeAlias(node) {\n      node.id = this.flowParseRestrictedIdentifier(false, true);\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(types.eq);\n      this.semicolon();\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(node, declare) {\n      this.expectContextual(\"type\");\n      node.id = this.flowParseRestrictedIdentifier(true, true);\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.supertype = null;\n\n      if (this.match(types.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(types.colon);\n      }\n\n      node.impltype = null;\n\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(types.eq);\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    flowParseTypeParameter(requireDefault = false) {\n      const nodeStart = this.state.start;\n      const node = this.startNode();\n      const variance = this.flowParseVariance();\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      node.variance = variance;\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(types.eq)) {\n        this.eat(types.eq);\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration() {\n      const oldInType = this.state.inType;\n      const node = this.startNode();\n      node.params = [];\n      this.state.inType = true;\n\n      if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      } while (!this.isRelational(\">\"));\n\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation() {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n      this.state.inType = true;\n      this.expectRelational(\"<\");\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseType());\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      }\n\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew() {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n      this.state.inType = true;\n      this.expectRelational(\"<\");\n\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      }\n\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType() {\n      const node = this.startNode();\n      this.expectContextual(\"interface\");\n      node.extends = [];\n\n      if (this.eat(types._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false\n      });\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey() {\n      return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(node, isStatic, variance) {\n      node.static = isStatic;\n\n      if (this.lookahead().type === types.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n\n      this.expect(types.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(node, isStatic) {\n      node.static = isStatic;\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(types.bracketR);\n      this.expect(types.bracketR);\n\n      if (this.isRelational(\"<\") || this.match(types.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n      } else {\n        node.method = false;\n\n        if (this.eat(types.question)) {\n          node.optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n      }\n\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(node) {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(types.parenL);\n\n      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam());\n\n        if (!this.match(types.parenR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      if (this.eat(types.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam();\n      }\n\n      this.expect(types.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(node, isStatic) {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact\n    }) {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const nodeStart = this.startNode();\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n      let endDelim;\n      let exact;\n      let inexact = false;\n\n      if (allowExact && this.match(types.braceBarL)) {\n        this.expect(types.braceBarL);\n        endDelim = types.braceBarR;\n        exact = true;\n      } else {\n        this.expect(types.braceL);\n        endDelim = types.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStart = null;\n        let inexactStart = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(\"proto\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n            this.next();\n            protoStart = this.state.start;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(\"static\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(types.bracketL)) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (this.eat(types.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.start);\n            }\n\n            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n          } else {\n            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n          }\n        } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n            const lookahead = this.lookahead();\n\n            if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStart = this.state.lastTokStart;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n          this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);\n        }\n      }\n\n      this.expect(endDelim);\n\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n      this.state.inType = oldInType;\n      return out;\n    }\n\n    flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {\n      if (this.eat(types.ellipsis)) {\n        const isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);\n          } else if (!allowInexact) {\n            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);\n          }\n\n          if (variance) {\n            this.raise(variance.start, FlowErrors.InexactVariance);\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);\n        }\n\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.raise(variance.start, FlowErrors.SpreadVariance);\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStart != null;\n        node.kind = kind;\n        let optional = false;\n\n        if (this.isRelational(\"<\") || this.match(types.parenL)) {\n          node.method = true;\n\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n          node.method = false;\n\n          if (this.eat(types.question)) {\n            optional = true;\n          }\n\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    flowCheckGetterSetterParams(property) {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const start = property.start;\n      const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (length !== paramCount) {\n        if (property.kind === \"get\") {\n          this.raise(start, ErrorMessages.BadGetterArity);\n        } else {\n          this.raise(start, ErrorMessages.BadSetterArity);\n        }\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(start, ErrorMessages.BadSetterRestParameter);\n      }\n    }\n\n    flowObjectTypeSemicolon() {\n      if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n      startPos = startPos || this.state.start;\n      startLoc = startLoc || this.state.startLoc;\n      let node = id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(types.dot)) {\n        const node2 = this.startNodeAt(startPos, startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(startPos, startLoc, id) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType() {\n      const node = this.startNode();\n      this.expect(types._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType() {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(types.bracketL);\n\n      while (this.state.pos < this.length && !this.match(types.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(types.bracketR)) break;\n        this.expect(types.comma);\n      }\n\n      this.expect(types.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam() {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode();\n      const lh = this.lookahead();\n\n      if (lh.type === types.colon || lh.type === types.question) {\n        name = this.parseIdentifier();\n\n        if (this.eat(types.question)) {\n          optional = true;\n        }\n\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(type) {\n      const node = this.startNodeAt(type.start, type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params = []) {\n      let rest = null;\n\n      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam());\n\n        if (!this.match(types.parenR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      if (this.eat(types.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam();\n      }\n\n      return {\n        params,\n        rest\n      };\n    }\n\n    flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startPos, startLoc, id);\n      }\n    }\n\n    flowParsePrimaryType() {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case types.name:\n          if (this.isContextual(\"interface\")) {\n            return this.flowParseInterfaceType();\n          }\n\n          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n        case types.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true\n          });\n\n        case types.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false\n          });\n\n        case types.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case types.relational:\n          if (this.state.value === \"<\") {\n            node.typeParameters = this.flowParseTypeParameterDeclaration();\n            this.expect(types.parenL);\n            tmp = this.flowParseFunctionTypeParams();\n            node.params = tmp.params;\n            node.rest = tmp.rest;\n            this.expect(types.parenR);\n            this.expect(types.arrow);\n            node.returnType = this.flowParseType();\n            return this.finishNode(node, \"FunctionTypeAnnotation\");\n          }\n\n          break;\n\n        case types.parenL:\n          this.next();\n\n          if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n            if (this.match(types.name)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== types.question && token !== types.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n              this.expect(types.parenR);\n              return type;\n            } else {\n              this.eat(types.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          this.expect(types.parenR);\n          this.expect(types.arrow);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case types.string:\n          return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n        case types._true:\n        case types._false:\n          node.value = this.match(types._true);\n          this.next();\n          return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n        case types.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n\n            if (this.match(types.num)) {\n              return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", node.start, node.loc.start);\n            }\n\n            if (this.match(types.bigint)) {\n              return this.parseLiteral(-this.state.value, \"BigIntLiteralTypeAnnotation\", node.start, node.loc.start);\n            }\n\n            throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);\n          }\n\n          throw this.unexpected();\n\n        case types.num:\n          return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n        case types.bigint:\n          return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n        case types._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case types._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case types._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case types.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        default:\n          if (this.state.type.keyword === \"typeof\") {\n            return this.flowParseTypeofType();\n          } else if (this.state.type.keyword) {\n            const label = this.state.type.label;\n            this.next();\n            return super.createIdentifier(node, label);\n          }\n\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParsePostfixType() {\n      const startPos = this.state.start,\n            startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n\n      while (this.match(types.bracketL) && !this.canInsertSemicolon()) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.elementType = type;\n        this.expect(types.bracketL);\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      }\n\n      return type;\n    }\n\n    flowParsePrefixType() {\n      const node = this.startNode();\n\n      if (this.eat(types.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens() {\n      const param = this.flowParsePrefixType();\n\n      if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n        const node = this.startNodeAt(param.start, param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n\n      return param;\n    }\n\n    flowParseIntersectionType() {\n      const node = this.startNode();\n      this.eat(types.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n\n      while (this.eat(types.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n\n      return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType() {\n      const node = this.startNode();\n      this.eat(types.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n\n      while (this.eat(types.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n\n      return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType() {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation() {\n      if (this.state.type === types.name && this.state.value === \"_\") {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startPos, startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation() {\n      const node = this.startNode();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n      if (this.match(types.colon)) {\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n\n      return ident;\n    }\n\n    typeCastToParameter(node) {\n      node.expression.typeAnnotation = node.typeAnnotation;\n      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n      return node.expression;\n    }\n\n    flowParseVariance() {\n      let variance = null;\n\n      if (this.match(types.plusMin)) {\n        variance = this.startNode();\n\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n\n        this.next();\n        this.finishNode(variance, \"Variance\");\n      }\n\n      return variance;\n    }\n\n    parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n      if (allowExpressionBody) {\n        return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      }\n\n      return super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish(node, type, isMethod = false) {\n      if (this.match(types.colon)) {\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n      }\n\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    parseStatement(context, topLevel) {\n      if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type === types.name || isKeyword(lookahead.value)) {\n          const node = this.startNode();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n\n      const stmt = super.parseStatement(context, topLevel);\n\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n\n      return stmt;\n    }\n\n    parseExpressionStatement(node, expr) {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n            return this.flowParseDeclare(node);\n          }\n        } else if (this.match(types.name)) {\n          if (expr.name === \"interface\") {\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr);\n    }\n\n    shouldParseExportDeclaration() {\n      return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || this.shouldParseEnums() && this.isContextual(\"enum\") || super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier() {\n      if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value === \"opaque\" || this.shouldParseEnums() && this.state.value === \"enum\")) {\n        return false;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression() {\n      if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n      if (!this.match(types.question)) return expr;\n\n      if (refNeedsArrowPos) {\n        const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n        if (!result.node) {\n          refNeedsArrowPos.start = result.error.pos || this.state.start;\n          return expr;\n        }\n\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n\n      this.expect(types.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startPos, startLoc);\n      let {\n        consequent,\n        failed\n      } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({\n            consequent,\n            failed\n          } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n          ({\n            consequent,\n            failed\n          } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(types.colon);\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined, undefined));\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent() {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(types.colon);\n      this.state.noArrowParamsConversionAt.pop();\n      return {\n        consequent,\n        failed\n      };\n    }\n\n    getArrowLikeExpressions(node, disallowInvalid) {\n      const stack = [node];\n      const arrows = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            this.finishArrowValidation(node);\n          } else {\n            arrows.push(node);\n          }\n\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n    }\n\n    finishArrowValidation(node) {\n      var _node$extra;\n\n      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);\n      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt(node, parse) {\n      let result;\n\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(node, startPos, startLoc) {\n      node = super.parseParenItem(node, startPos, startLoc);\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(types.colon)) {\n        const typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node) {\n      if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExport(node) {\n      const decl = super.parseExport(node);\n\n      if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n        decl.exportKind = decl.exportKind || \"value\";\n      }\n\n      return decl;\n    }\n\n    parseExportDeclaration(node) {\n      if (this.isContextual(\"type\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(types.braceL)) {\n          node.specifiers = this.parseExportSpecifiers();\n          this.parseExportFrom(node);\n          return null;\n        } else {\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(\"opaque\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(\"interface\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node) {\n      if (super.eatExportStar(...arguments)) return true;\n\n      if (this.isContextual(\"type\") && this.lookahead().type === types.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node) {\n      const pos = this.state.start;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(pos);\n      }\n\n      return hasNamespace;\n    }\n\n    parseClassId(node, isStatement, optionalId) {\n      super.parseClassId(node, isStatement, optionalId);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(classBody, member, state) {\n      const pos = this.state.start;\n\n      if (this.isContextual(\"declare\")) {\n        if (this.parseClassMemberFromModifier(classBody, member)) {\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\") {\n          this.raise(pos, FlowErrors.DeclareClassElement);\n        } else if (member.value) {\n          this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);\n        }\n      }\n    }\n\n    getTokenFromCode(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 123 && next === 124) {\n        return this.finishOp(types.braceBarL, 2);\n      } else if (this.state.inType && (code === 62 || code === 60)) {\n        return this.finishOp(types.relational, 1);\n      } else if (this.state.inType && code === 63) {\n        return this.finishOp(types.question, 1);\n      } else if (isIteratorStart(code, next)) {\n        this.state.isIterator = true;\n        return super.readWord();\n      } else {\n        return super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node, isBinding) {\n      switch (node.type) {\n        case \"Identifier\":\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"AssignmentPattern\":\n          return true;\n\n        case \"ObjectExpression\":\n          {\n            const last = node.properties.length - 1;\n            return node.properties.every((prop, i) => {\n              return prop.type !== \"ObjectMethod\" && (i === last || prop.type === \"SpreadElement\") && this.isAssignable(prop);\n            });\n          }\n\n        case \"ObjectProperty\":\n          return this.isAssignable(node.value);\n\n        case \"SpreadElement\":\n          return this.isAssignable(node.argument);\n\n        case \"ArrayExpression\":\n          return node.elements.every(element => this.isAssignable(element));\n\n        case \"AssignmentExpression\":\n          return node.operator === \"=\";\n\n        case \"ParenthesizedExpression\":\n        case \"TypeCastExpression\":\n          return this.isAssignable(node.expression);\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return !isBinding;\n\n        default:\n          return false;\n      }\n    }\n\n    toAssignable(node, isLHS = false) {\n      if (node.type === \"TypeCastExpression\") {\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n      } else {\n        return super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableList(exprList, trailingCommaPos, isLHS) {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n\n        if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n\n      return super.toAssignableList(exprList, trailingCommaPos, isLHS);\n    }\n\n    toReferencedList(exprList, isParenthesizedExpr) {\n      for (let i = 0; i < exprList.length; i++) {\n        var _expr$extra;\n\n        const expr = exprList[i];\n\n        if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) == null ? void 0 : _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    checkLVal(expr, ...args) {\n      if (expr.type !== \"TypeCastExpression\") {\n        return super.checkLVal(expr, ...args);\n      }\n    }\n\n    parseClassProperty(node) {\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(node) {\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      return super.parseClassPrivateProperty(node);\n    }\n\n    isClassMethod() {\n      return this.isRelational(\"<\") || super.isClassMethod();\n    }\n\n    isClassProperty() {\n      return this.match(types.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method) {\n      return !this.match(types.colon) && super.isNonstaticConstructor(method);\n    }\n\n    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n      if (method.variance) {\n        this.unexpected(method.variance.start);\n      }\n\n      delete method.variance;\n\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    }\n\n    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n      if (method.variance) {\n        this.unexpected(method.variance.start);\n      }\n\n      delete method.variance;\n\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    parseClassSuper(node) {\n      super.parseClassSuper(node);\n\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      if (this.isContextual(\"implements\")) {\n        this.next();\n        const implemented = node.implements = [];\n\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(true);\n\n          if (this.isRelational(\"<\")) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(types.comma));\n      }\n    }\n\n    parsePropertyName(node, isPrivateNameAllowed) {\n      const variance = this.flowParseVariance();\n      const key = super.parsePropertyName(node, isPrivateNameAllowed);\n      node.variance = variance;\n      return key;\n    }\n\n    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n      if (prop.variance) {\n        this.unexpected(prop.variance.start);\n      }\n\n      delete prop.variance;\n      let typeParameters;\n\n      if (this.isRelational(\"<\") && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(types.parenL)) this.unexpected();\n      }\n\n      super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n\n      if (typeParameters) {\n        (prop.value || prop).typeParameters = typeParameters;\n      }\n    }\n\n    parseAssignableListItemTypes(param) {\n      if (this.eat(types.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(param.start, FlowErrors.OptionalBindingPattern);\n        }\n\n        param.optional = true;\n      }\n\n      if (this.match(types.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(startPos, startLoc, left) {\n      const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n      if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);\n      }\n\n      return node;\n    }\n\n    shouldParseDefaultImport(node) {\n      if (!hasTypeImportKind(node)) {\n        return super.shouldParseDefaultImport(node);\n      }\n\n      return isMaybeDefaultImport(this.state);\n    }\n\n    parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, type));\n    }\n\n    maybeParseDefaultImportSpecifier(node) {\n      node.importKind = \"value\";\n      let kind = null;\n\n      if (this.match(types._typeof)) {\n        kind = \"typeof\";\n      } else if (this.isContextual(\"type\")) {\n        kind = \"type\";\n      }\n\n      if (kind) {\n        const lh = this.lookahead();\n\n        if (kind === \"type\" && lh.type === types.star) {\n          this.unexpected(lh.start);\n        }\n\n        if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      return super.maybeParseDefaultImportSpecifier(node);\n    }\n\n    parseImportSpecifier(node) {\n      const specifier = this.startNode();\n      const firstIdentLoc = this.state.start;\n      const firstIdent = this.parseModuleExportName();\n      let specifierTypeKind = null;\n\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n\n      if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n\n        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = as_ident.__clone();\n        } else {\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n\n        if (this.eatContextual(\"as\")) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = specifier.imported.__clone();\n        }\n      } else {\n        if (firstIdent.type === \"StringLiteral\") {\n          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);\n        }\n\n        isBinding = true;\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = specifier.imported.__clone();\n      }\n\n      const nodeIsTypeImport = hasTypeImportKind(node);\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (nodeIsTypeImport && specifierIsTypeImport) {\n        this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);\n      }\n\n      if (nodeIsTypeImport || specifierIsTypeImport) {\n        this.checkReservedType(specifier.local.name, specifier.local.start, true);\n      }\n\n      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n        this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n      }\n\n      this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n    }\n\n    parseFunctionParams(node, allowModifiers) {\n      const kind = node.kind;\n\n      if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    parseVarId(decl, kind) {\n      super.parseVarId(decl, kind);\n\n      if (this.match(types.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id);\n      }\n    }\n\n    parseAsyncArrowFromCallExpression(node, call) {\n      if (this.match(types.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    shouldParseAsyncArrow() {\n      return this.match(types.colon) || super.shouldParseAsyncArrow();\n    }\n\n    parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n      var _jsx;\n\n      let state = null;\n      let jsx;\n\n      if (this.hasPlugin(\"jsx\") && (this.match(types.jsxTagStart) || this.isRelational(\"<\"))) {\n        state = this.state.clone();\n        jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);\n        if (!jsx.error) return jsx.node;\n        const {\n          context\n        } = this.state;\n\n        if (context[context.length - 1] === types$1.j_oTag) {\n          context.length -= 2;\n        } else if (context[context.length - 1] === types$1.j_expr) {\n          context.length -= 1;\n        }\n      }\n\n      if (((_jsx = jsx) == null ? void 0 : _jsx.error) || this.isRelational(\"<\")) {\n        var _jsx2, _jsx3;\n\n        state = state || this.state.clone();\n        let typeParameters;\n        const arrow = this.tryParse(abort => {\n          var _arrowExpression$extr;\n\n          typeParameters = this.flowParseTypeParameterDeclaration();\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);\n            this.resetStartLocationFromNode(result, typeParameters);\n            return result;\n          });\n\n          if (arrowExpression.type !== \"ArrowFunctionExpression\" && ((_arrowExpression$extr = arrowExpression.extra) == null ? void 0 : _arrowExpression$extr.parenthesized)) {\n            abort();\n          }\n\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n          return arrowExpression;\n        }, state);\n        let arrowExpression = null;\n\n        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n          if (!arrow.error && !arrow.aborted) {\n            if (arrow.node.async) {\n              this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);\n            }\n\n            return arrow.node;\n          }\n\n          arrowExpression = arrow.node;\n        }\n\n        if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n        throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);\n    }\n\n    parseArrow(node) {\n      if (this.match(types.colon)) {\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n          const typeNode = this.startNode();\n          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(types.arrow)) this.unexpected();\n          return typeNode;\n        });\n        if (result.thrown) return null;\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow() {\n      return this.match(types.colon) || super.shouldParseArrow();\n    }\n\n    setArrowFunctionParameters(node, params) {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(node, allowDuplicates, isArrowFunction) {\n      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        return;\n      }\n\n      return super.checkParams(...arguments);\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow) {\n      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n    }\n\n    parseSubscripts(base, startPos, startLoc, noCalls) {\n      if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n        this.next();\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (base.type === \"Identifier\" && base.name === \"async\" && this.isRelational(\"<\")) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n        const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startPos, startLoc, noCalls);\n    }\n\n    parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n      if (this.match(types.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n\n        this.next();\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(types.parenL);\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, true);\n      } else if (!noCalls && this.shouldParseTypes() && this.isRelational(\"<\")) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const result = this.tryParse(() => {\n          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(types.parenL);\n          node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n          if (subscriptState.optionalChainMember) node.optional = false;\n          return this.finishCallExpression(node, subscriptState.optionalChainMember);\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n    }\n\n    parseNewArguments(node) {\n      let targs = null;\n\n      if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n      }\n\n      node.typeArguments = targs;\n      super.parseNewArguments(node);\n    }\n\n    parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n      const node = this.startNodeAt(startPos, startLoc);\n      this.parseFunctionParams(node);\n      if (!this.parseArrow(node)) return;\n      return this.parseArrowExpression(node, undefined, true);\n    }\n\n    readToken_mult_modulo(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 42 && next === 47 && this.state.hasFlowComment) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 124 && next === 125) {\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file, program) {\n      const fileNode = super.parseTopLevel(file, program);\n\n      if (this.state.hasFlowComment) {\n        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);\n      }\n\n      return fileNode;\n    }\n\n    skipBlockComment() {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          this.unexpected(null, FlowErrors.NestedFlowComment);\n        }\n\n        this.hasFlowCommentCompletion();\n        this.state.pos += this.skipFlowComment();\n        this.state.hasFlowComment = true;\n        return;\n      }\n\n      if (this.state.hasFlowComment) {\n        const end = this.input.indexOf(\"*-/\", this.state.pos += 2);\n\n        if (end === -1) {\n          throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);\n        }\n\n        this.state.pos = end + 3;\n        return;\n      }\n\n      super.skipBlockComment();\n    }\n\n    skipFlowComment() {\n      const {\n        pos\n      } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n\n      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === 58 && ch3 === 58) {\n        return shiftToFirstNonWhiteSpace + 2;\n      }\n\n      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n        return shiftToFirstNonWhiteSpace + 12;\n      }\n\n      if (ch2 === 58 && ch3 !== 58) {\n        return shiftToFirstNonWhiteSpace;\n      }\n\n      return false;\n    }\n\n    hasFlowCommentCompletion() {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n\n      if (end === -1) {\n        throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);\n      }\n    }\n\n    flowEnumErrorBooleanMemberNotInitialized(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);\n    }\n\n    flowEnumErrorInvalidMemberName(pos, {\n      enumName,\n      memberName\n    }) {\n      const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n      this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);\n    }\n\n    flowEnumErrorDuplicateMemberName(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);\n    }\n\n    flowEnumErrorInconsistentMemberValues(pos, {\n      enumName\n    }) {\n      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);\n    }\n\n    flowEnumErrorInvalidExplicitType(pos, {\n      enumName,\n      suppliedType\n    }) {\n      return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);\n    }\n\n    flowEnumErrorInvalidMemberInitializer(pos, {\n      enumName,\n      explicitType,\n      memberName\n    }) {\n      let message = null;\n\n      switch (explicitType) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;\n          break;\n\n        case \"symbol\":\n          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;\n          break;\n\n        default:\n          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;\n      }\n\n      return this.raise(pos, message, enumName, memberName, explicitType);\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitailized(pos, {\n      enumName\n    }) {\n      this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);\n    }\n\n    flowEnumMemberInit() {\n      const startPos = this.state.start;\n\n      const endOfInit = () => this.match(types.comma) || this.match(types.braceR);\n\n      switch (this.state.type) {\n        case types.num:\n          {\n            const literal = this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n            if (endOfInit()) {\n              return {\n                type: \"number\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        case types.string:\n          {\n            const literal = this.parseLiteral(this.state.value, \"StringLiteral\");\n\n            if (endOfInit()) {\n              return {\n                type: \"string\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        case types._true:\n        case types._false:\n          {\n            const literal = this.parseBooleanLiteral();\n\n            if (endOfInit()) {\n              return {\n                type: \"boolean\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        default:\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n      }\n    }\n\n    flowEnumMemberRaw() {\n      const pos = this.state.start;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(types.eq) ? this.flowEnumMemberInit() : {\n        type: \"none\",\n        pos\n      };\n      return {\n        id,\n        init\n      };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {\n      const {\n        explicitType\n      } = context;\n\n      if (explicitType === null) {\n        return;\n      }\n\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(pos, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType\n    }) {\n      const seenNames = new Set();\n      const members = {\n        booleanMembers: [],\n        numberMembers: [],\n        stringMembers: [],\n        defaultedMembers: []\n      };\n\n      while (!this.match(types.braceR)) {\n        const memberNode = this.startNode();\n        const {\n          id,\n          init\n        } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n\n        if (memberName === \"\") {\n          continue;\n        }\n\n        if (/^[a-z]/.test(memberName)) {\n          this.flowEnumErrorInvalidMemberName(id.start, {\n            enumName,\n            memberName\n          });\n        }\n\n        if (seenNames.has(memberName)) {\n          this.flowEnumErrorDuplicateMemberName(id.start, {\n            enumName,\n            memberName\n          });\n        }\n\n        seenNames.add(memberName);\n        const context = {\n          enumName,\n          explicitType,\n          memberName\n        };\n        memberNode.id = id;\n\n        switch (init.type) {\n          case \"boolean\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"boolean\");\n              memberNode.init = init.value;\n              members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n              break;\n            }\n\n          case \"number\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n              memberNode.init = init.value;\n              members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n              break;\n            }\n\n          case \"string\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n              memberNode.init = init.value;\n              members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n              break;\n            }\n\n          case \"invalid\":\n            {\n              throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n            }\n\n          case \"none\":\n            {\n              switch (explicitType) {\n                case \"boolean\":\n                  this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);\n                  break;\n\n                case \"number\":\n                  this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                  break;\n\n                default:\n                  members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n              }\n            }\n        }\n\n        if (!this.match(types.braceR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      return members;\n    }\n\n    flowEnumStringMembers(initializedMembers, defaultedMembers, {\n      enumName\n    }) {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (let _i = 0; _i < initializedMembers.length; _i++) {\n          const member = initializedMembers[_i];\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n            enumName\n          });\n        }\n\n        return defaultedMembers;\n      } else {\n        for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {\n          const member = defaultedMembers[_i2];\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n            enumName\n          });\n        }\n\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName\n    }) {\n      if (this.eatContextual(\"of\")) {\n        if (!this.match(types.name)) {\n          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: null\n          });\n        }\n\n        const {\n          value\n        } = this.state;\n        this.next();\n\n        if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n          this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: value\n          });\n        }\n\n        return value;\n      }\n\n      return null;\n    }\n\n    flowEnumBody(node, {\n      enumName,\n      nameLoc\n    }) {\n      const explicitType = this.flowEnumParseExplicitType({\n        enumName\n      });\n      this.expect(types.braceL);\n      const members = this.flowEnumMembers({\n        enumName,\n        explicitType\n      });\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n            enumName\n          });\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n\n        default:\n          {\n            const empty = () => {\n              node.members = [];\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumStringBody\");\n            };\n\n            node.explicitType = false;\n            const boolsLen = members.booleanMembers.length;\n            const numsLen = members.numberMembers.length;\n            const strsLen = members.stringMembers.length;\n            const defaultedLen = members.defaultedMembers.length;\n\n            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n              return empty();\n            } else if (!boolsLen && !numsLen) {\n              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n                enumName\n              });\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumStringBody\");\n            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n              for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {\n                const member = _members$defaultedMem[_i3];\n                this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                  enumName,\n                  memberName: member.id.name\n                });\n              }\n\n              node.members = members.booleanMembers;\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumBooleanBody\");\n            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n              for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {\n                const member = _members$defaultedMem2[_i4];\n                this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                  enumName,\n                  memberName: member.id.name\n                });\n              }\n\n              node.members = members.numberMembers;\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumNumberBody\");\n            } else {\n              this.flowEnumErrorInconsistentMemberValues(nameLoc, {\n                enumName\n              });\n              return empty();\n            }\n          }\n      }\n    }\n\n    flowParseEnumDeclaration(node) {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), {\n        enumName: id.name,\n        nameLoc: id.start\n      });\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    updateContext(prevType) {\n      if (this.match(types.name) && this.state.value === \"of\" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === \"interface\") {\n        this.state.exprAllowed = false;\n      } else {\n        super.updateContext(prevType);\n      }\n    }\n\n    isLookaheadToken_lt() {\n      const next = this.nextTokenStart();\n\n      if (this.input.charCodeAt(next) === 60) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return afterNext !== 60 && afterNext !== 61;\n      }\n\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n\n  }, _temp;\n});\n\nconst entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\nconst JsxErrors = Object.freeze({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression\",\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>\",\n  MissingClosingTagElement: \"Expected corresponding JSX closing tag for <%0>\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text\",\n  UnterminatedJsxContent: \"Unterminated JSX contents\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", {\n  beforeExpr: true\n});\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", {\n  startsExpr: true\n});\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr);\n  this.state.context.push(types$1.j_oTag);\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  const out = this.state.context.pop();\n\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.exprAllowed) {\n              ++this.state.pos;\n              return this.finishToken(types.jsxTagStart);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(types.jsxText, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(types.string, out);\n  }\n\n  jsxReadEntity() {\n    let str = \"\";\n    let count = 0;\n    let entity;\n    let ch = this.input[this.state.pos];\n    const startPos = ++this.state.pos;\n\n    while (this.state.pos < this.length && count++ < 10) {\n      ch = this.input[this.state.pos++];\n\n      if (ch === \";\") {\n        if (str[0] === \"#\") {\n          if (str[1] === \"x\") {\n            str = str.substr(2);\n\n            if (HEX_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 16));\n            }\n          } else {\n            str = str.substr(1);\n\n            if (DECIMAL_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 10));\n            }\n          }\n        } else {\n          entity = entities[str];\n        }\n\n        break;\n      }\n\n      str += ch;\n    }\n\n    if (!entity) {\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    return entity;\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(types.jsxName)) {\n      node.name = this.state.value;\n    } else if (this.state.type.keyword) {\n      node.name = this.state.type.keyword;\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(types.colon)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(types.dot)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case types.braceL:\n        node = this.startNode();\n        this.next();\n        node = this.jsxParseExpressionContainer(node);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(node.start, JsxErrors.AttributeIsEmpty);\n        }\n\n        return node;\n\n      case types.jsxTagStart:\n      case types.string:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node) {\n    if (this.match(types.braceR)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.eat(types.braceL)) {\n      this.expect(types.ellipsis);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.expect(types.braceR);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(types.slash);\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case types.jsxTagStart:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(types.slash)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case types.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case types.braceL:\n            {\n              const node = this.startNode();\n              this.next();\n\n              if (this.match(types.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.isRelational(\"<\")) {\n      throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(types.jsxText)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(types.jsxTagStart)) {\n      return this.jsxParseElement();\n    } else if (this.isRelational(\"<\") && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.finishToken(types.jsxTagStart);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inPropertyName) return super.getTokenFromCode(code);\n    const context = this.curContext();\n\n    if (context === types$1.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types$1.j_oTag || context === types$1.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagEnd);\n      }\n\n      if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(types.jsxTagStart);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    if (this.match(types.braceL)) {\n      const curContext = this.curContext();\n\n      if (curContext === types$1.j_oTag) {\n        this.state.context.push(types$1.braceExpression);\n      } else if (curContext === types$1.j_expr) {\n        this.state.context.push(types$1.templateQuasi);\n      } else {\n        super.updateContext(prevType);\n      }\n\n      this.state.exprAllowed = true;\n    } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n      this.state.context.length -= 2;\n      this.state.context.push(types$1.j_cTag);\n      this.state.exprAllowed = false;\n    } else {\n      return super.updateContext(prevType);\n    }\n  }\n\n});\n\nclass Scope {\n  constructor(flags) {\n    this.flags = void 0;\n    this.var = [];\n    this.lexical = [];\n    this.functions = [];\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(raise, inModule) {\n    this.scopeStack = [];\n    this.undefinedExports = new Map();\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScope().flags & SCOPE_CLASS) > 0;\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, pos) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.push(name);\n      } else {\n        scope.lexical.push(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.push(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, pos) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, ErrorMessages.VarRedeclaration, name);\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;\n    }\n\n    return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {\n      this.undefinedExports.set(id.name, id.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if (scope.flags & SCOPE_VAR) {\n        return scope;\n      }\n    }\n  }\n\n  currentThisScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {\n        return scope;\n      }\n    }\n  }\n\n}\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = [];\n    this.enums = [];\n    this.constEnums = [];\n    this.classes = [];\n    this.exportOnlyBindings = [];\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.push(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.indexOf(name) > -1) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.indexOf(name) > -1;\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {\n      if (scope.lexical.indexOf(name) > -1) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst PARAM = 0b0000,\n      PARAM_YIELD = 0b0001,\n      PARAM_AWAIT = 0b0010,\n      PARAM_RETURN = 0b0100,\n      PARAM_IN = 0b1000;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n  get hasIn() {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nconst TSErrors = Object.freeze({\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateModifier: \"Duplicate modifier: '%0'\",\n  EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier\",\n  IndexSignatureHasAccessibility: \"Index signatures cannot have an accessibility modifier ('%0')\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier\",\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MixedLabeledAndUnlabeledElements: \"Tuple members must all have names or all not have names.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: \"Private elements cannot have an accessibility modifier ('%0')\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\"\n});\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nvar typescript = (superClass => class extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return this.match(types.name);\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return (this.match(types.bracketL) || this.match(types.braceL) || this.match(types.star) || this.match(types.ellipsis) || this.match(types.hash) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n\n  tsParseModifier(allowedModifiers) {\n    if (!this.match(types.name)) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n      return modifier;\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers(modified, allowedModifiers) {\n    for (;;) {\n      const startPos = this.state.start;\n      const modifier = this.tsParseModifier(allowedModifiers);\n      if (!modifier) break;\n\n      if (Object.hasOwnProperty.call(modified, modifier)) {\n        this.raise(startPos, TSErrors.DuplicateModifier, modifier);\n      }\n\n      modified[modifier] = true;\n    }\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(types.braceR);\n\n      case \"HeritageClauseElement\":\n        return this.match(types.braceL);\n\n      case \"TupleElementTypes\":\n        return this.match(types.bracketR);\n\n      case \"TypeParametersOrArguments\":\n        return this.isRelational(\">\");\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n    const result = [];\n\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(types.comma)) {\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(types.comma);\n      }\n\n      return undefined;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(types.bracketL);\n      } else {\n        this.expectRelational(\"<\");\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement);\n\n    if (bracket) {\n      this.expect(types.bracketR);\n    } else {\n      this.expectRelational(\">\");\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(types._import);\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);\n    }\n\n    node.argument = this.parseExprAtom();\n    this.expect(types.parenR);\n\n    if (this.eat(types.dot)) {\n      node.qualifier = this.tsParseEntityName(true);\n    }\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords) {\n    let entity = this.parseIdentifier();\n\n    while (this.eat(types.dot)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(false);\n\n    if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n\n    if (this.match(types._import)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(true);\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsEatThenParseType(types._extends);\n    node.default = this.tsEatThenParseType(types.eq);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters() {\n    if (this.isRelational(\"<\")) {\n      return this.tsParseTypeParameters();\n    }\n  }\n\n  tsParseTypeParameters() {\n    const node = this.startNode();\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), false, true);\n\n    if (node.params.length === 0) {\n      this.raise(node.start, TSErrors.EmptyTypeParameters);\n    }\n\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type === types._const) {\n      this.next();\n      return this.tsParseTypeReference();\n    }\n\n    return null;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === types.arrow;\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(types.parenL);\n    signature.parameters = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return this.parseBindingList(types.parenR, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(types.comma)) {\n      this.semicolon();\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(types.colon, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    return this.eat(types.name) && this.match(types.colon);\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(types.bracketL);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(types.bracketR);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(types.question)) node.optional = true;\n    const nodeAny = node;\n\n    if (!readonly && (this.match(types.parenL) || this.isRelational(\"<\"))) {\n      const method = nodeAny;\n      this.tsFillSignature(types.colon, method);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(types._new)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    const readonly = !!this.tsParseModifier([\"readonly\"]);\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      if (readonly) node.readonly = true;\n      return idx;\n    }\n\n    this.parsePropertyName(node, false);\n    return this.tsParsePropertyOrMethodSignature(node, readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(types.braceL);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(types.braceR);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(types.plusMin)) {\n      return this.isContextual(\"readonly\");\n    }\n\n    if (this.isContextual(\"readonly\")) {\n      this.next();\n    }\n\n    if (!this.match(types.bracketL)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(types._in);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsExpectThenParseType(types._in);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (this.match(types.plusMin)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(\"readonly\");\n    } else if (this.eatContextual(\"readonly\")) {\n      node.readonly = true;\n    }\n\n    this.expect(types.bracketL);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(\"as\") ? this.tsParseType() : null;\n    this.expect(types.bracketR);\n\n    if (this.match(types.plusMin)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(types.question);\n    } else if (this.eat(types.question)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    let labeledElements = null;\n    node.elementTypes.forEach(elementNode => {\n      var _labeledElements;\n\n      let {\n        type\n      } = elementNode;\n\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);\n      }\n\n      seenOptionalElement = seenOptionalElement || type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\";\n\n      if (type === \"TSRestType\") {\n        elementNode = elementNode.typeAnnotation;\n        type = elementNode.type;\n      }\n\n      const isLabeled = type === \"TSNamedTupleMember\";\n      labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;\n\n      if (labeledElements !== isLabeled) {\n        this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    const {\n      start: startPos,\n      startLoc\n    } = this.state;\n    const rest = this.eat(types.ellipsis);\n    let type = this.tsParseType();\n    const optional = this.eat(types.question);\n    const labeled = this.eat(types.colon);\n\n    if (labeled) {\n      const labeledNode = this.startNodeAtNode(type);\n      labeledNode.optional = optional;\n\n      if (type.type === \"TSTypeReference\" && !type.typeParameters && type.typeName.type === \"Identifier\") {\n        labeledNode.label = type.typeName;\n      } else {\n        this.raise(type.start, TSErrors.InvalidTupleMemberLabel);\n        labeledNode.label = type;\n      }\n\n      labeledNode.elementType = this.tsParseType();\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    if (rest) {\n      const restNode = this.startNodeAt(startPos, startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(types.parenL);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      this.expect(types._new);\n    }\n\n    this.tsFillSignature(types.arrow, node);\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case types.num:\n        case types.bigint:\n        case types.string:\n        case types._true:\n        case types._false:\n          return this.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = this.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case types.name:\n      case types._void:\n      case types._null:\n        {\n          const type = this.match(types._void) ? \"TSVoidKeyword\" : this.match(types._null) ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n          if (type !== undefined && this.lookaheadCharCode() !== 46) {\n            const node = this.startNode();\n            this.next();\n            return this.finishNode(node, type);\n          }\n\n          return this.tsParseTypeReference();\n        }\n\n      case types.string:\n      case types.num:\n      case types.bigint:\n      case types._true:\n      case types._false:\n        return this.tsParseLiteralTypeNode();\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n\n          if (nextToken.type !== types.num && nextToken.type !== types.bigint) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case types._this:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case types._typeof:\n        return this.tsParseTypeQuery();\n\n      case types._import:\n        return this.tsParseImportType();\n\n      case types.braceL:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case types.bracketL:\n        return this.tsParseTupleType();\n\n      case types.parenL:\n        return this.tsParseParenthesizedType();\n\n      case types.backQuote:\n        return this.tsParseTemplateLiteralType();\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {\n      if (this.match(types.bracketR)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator(operator) {\n    const node = this.startNode();\n    this.expectContextual(operator);\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(node.start, TSErrors.UnexpectedReadonly);\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(\"infer\");\n    const typeParameter = this.startNode();\n    typeParameter.name = this.parseIdentifierName(typeParameter.start);\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const operator = [\"keyof\", \"unique\", \"readonly\"].find(kw => this.isContextual(kw));\n    return operator ? this.tsParseTypeOperator(operator) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    this.eat(operator);\n    let type = parseConstituentType();\n\n    if (this.match(operator)) {\n      const types = [type];\n\n      while (this.eat(operator)) {\n        types.push(parseConstituentType());\n      }\n\n      const node = this.startNodeAtNode(type);\n      node.types = types;\n      type = this.finishNode(node, kind);\n    }\n\n    return type;\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.isRelational(\"<\")) {\n      return true;\n    }\n\n    return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (this.match(types.name) || this.match(types._this)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(types.braceL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.braceL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.braceR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    if (this.match(types.bracketL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.bracketL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.bracketR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(types.parenR) || this.match(types.ellipsis)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {\n        return true;\n      }\n\n      if (this.match(types.parenR)) {\n        this.next();\n\n        if (this.match(types.arrow)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(types._this)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          const node = this.startNodeAtNode(t);\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        const node = this.startNodeAtNode(t);\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      const node = this.startNodeAtNode(t);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(types.colon);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (!this.match(types.name) || this.state.value !== \"asserts\" || this.hasPrecedingLineBreak()) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!this.match(types.name) && !this.match(types._this)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, \"asserts\");\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(types.colon);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsParseNonConditionalType();\n    this.expect(types.question);\n    node.trueType = this.tsParseType();\n    this.expect(types.colon);\n    node.falseType = this.tsParseType();\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(types._new)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expectRelational(\">\");\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(descriptor) {\n    const originalStart = this.state.start;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n\n    if (!delimitedList.length) {\n      this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);\n    }\n\n    return delimitedList;\n  }\n\n  tsParseExpressionWithTypeArguments() {\n    const node = this.startNode();\n    node.expression = this.tsParseEntityName(false);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n  }\n\n  tsParseInterfaceDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript interface declaration\", BIND_TS_INTERFACE);\n    node.typeParameters = this.tsTryParseTypeParameters();\n\n    if (this.eat(types._extends)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript type alias\", BIND_TS_TYPE);\n    node.typeParameters = this.tsTryParseTypeParameters();\n    node.typeAnnotation = this.tsInType(() => {\n      this.expect(types.eq);\n\n      if (this.isContextual(\"intrinsic\") && this.lookahead().type !== types.dot) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n\n    if (this.eat(types.eq)) {\n      node.initializer = this.parseMaybeAssignAllowIn();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, isConst) {\n    if (isConst) node.const = true;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript enum declaration\", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);\n    this.expect(types.braceL);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.braceL);\n    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkLVal(node.id, \"module or namespace declaration\", BIND_TS_NAMESPACE);\n    }\n\n    if (this.eat(types.dot)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(\"global\")) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(types.braceL)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"import equals declaration\", BIND_LEXICAL);\n    this.expect(types.eq);\n    node.moduleReference = this.tsParseModuleReference();\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(\"require\") && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(\"require\");\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      throw this.unexpected();\n    }\n\n    node.expression = this.parseExprAtom();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(\"let\")) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    return this.tsInDeclareContext(() => {\n      switch (starttype) {\n        case types._function:\n          nany.declare = true;\n          return this.parseFunctionStatement(nany, false, true);\n\n        case types._class:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n\n        case types._const:\n          if (this.match(types._const) && this.isLookaheadContextual(\"enum\")) {\n            this.expect(types._const);\n            this.expectContextual(\"enum\");\n            return this.tsParseEnumDeclaration(nany, true);\n          }\n\n        case types._var:\n          kind = kind || this.state.value;\n          return this.parseVarStatement(nany, kind);\n\n        case types.name:\n          {\n            const value = this.state.value;\n\n            if (value === \"global\") {\n              return this.tsParseAmbientExternalModuleDeclaration(nany);\n            } else {\n              return this.tsParseDeclaration(nany, value, true);\n            }\n          }\n      }\n    });\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(types.braceL)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {\n          const cls = node;\n          cls.abstract = true;\n\n          if (next) {\n            this.next();\n\n            if (!this.match(types._class)) {\n              this.unexpected(null, types._class);\n            }\n          }\n\n          return this.parseClass(cls, true, false);\n        }\n\n        break;\n\n      case \"enum\":\n        if (next || this.match(types.name)) {\n          if (next) this.next();\n          return this.tsParseEnumDeclaration(node, false);\n        }\n\n        break;\n\n      case \"interface\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseInterfaceDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (next) this.next();\n\n        if (this.match(types.string)) {\n          return this.tsParseAmbientExternalModuleDeclaration(node);\n        } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminatorAndMatch(tokenType, next) {\n    return (next || this.match(tokenType)) && !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.isRelational(\"<\")) {\n      return undefined;\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(types.arrow);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    if (!res) {\n      return undefined;\n    }\n\n    return this.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expectRelational(\"<\");\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n\n    if (node.params.length === 0) {\n      this.raise(node.start, TSErrors.EmptyTypeArguments);\n    }\n\n    this.state.exprAllowed = false;\n    this.expectRelational(\">\");\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    if (this.match(types.name)) {\n      switch (this.state.value) {\n        case \"abstract\":\n        case \"declare\":\n        case \"enum\":\n        case \"interface\":\n        case \"module\":\n        case \"namespace\":\n        case \"type\":\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n\n    if (allowModifiers !== undefined) {\n      accessibility = this.parseAccessModifier();\n      readonly = !!this.tsParseModifier([\"readonly\"]);\n\n      if (allowModifiers === false && (accessibility || readonly)) {\n        this.raise(startPos, TSErrors.UnexpectedParameterModifier);\n      }\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {\n      this.finishNode(node, bodilessType);\n      return;\n    }\n\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isDeclareContext) {\n      this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);\n\n      if (node.declare) {\n        super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        return;\n      }\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkLVal(node.id, \"function name\", BIND_TS_AMBIENT);\n    } else {\n      super.registerFunctionStatementId(...arguments);\n    }\n  }\n\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);\n      }\n    });\n  }\n\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n\n  parseArrayLike(...args) {\n    const node = super.parseArrayLike(...args);\n\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {\n      this.state.exprAllowed = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    if (this.isRelational(\"<\")) {\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (typeArguments) {\n          if (!noCalls && this.eat(types.parenL)) {\n            node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n            this.tsCheckForInvalidTypeCasts(node.arguments);\n            node.typeParameters = typeArguments;\n            return this.finishCallExpression(node, state.optionalChainMember);\n          } else if (this.match(types.backQuote)) {\n            const result = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n            result.typeParameters = typeArguments;\n            return result;\n          }\n        }\n\n        this.unexpected();\n      });\n      if (result) return result;\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewArguments(node) {\n    if (this.isRelational(\"<\")) {\n      const typeParameters = this.tsTryParseAndCatch(() => {\n        const args = this.tsParseTypeArguments();\n        if (!this.match(types.parenL)) this.unexpected();\n        return args;\n      });\n\n      if (typeParameters) {\n        node.typeParameters = typeParameters;\n      }\n    }\n\n    super.parseNewArguments(node);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {\n      const ahead = this.lookahead();\n\n      if (this.match(types.name) && ahead.type === types.eq) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n\n      if (this.isContextual(\"type\") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === \"from\")) {\n        node.importKind = \"type\";\n        this.next();\n      }\n    }\n\n    if (!node.importKind) {\n      node.importKind = \"value\";\n    }\n\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(importNode.start, \"A type-only import can specify a default import or named bindings, but not both.\");\n    }\n\n    return importNode;\n  }\n\n  parseExport(node) {\n    if (this.match(types._import)) {\n      this.expect(types._import);\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(types.eq)) {\n      const assign = node;\n      assign.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(\"as\")) {\n      const decl = node;\n      this.expectContextual(\"namespace\");\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(\"type\") && this.lookahead().type === types.braceL) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(\"abstract\") && this.lookahead().type === types._class;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      this.parseClass(cls, true, true);\n      cls.abstract = true;\n      return cls;\n    }\n\n    if (this.state.value === \"interface\") {\n      const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.state.type === types._const) {\n      const ahead = this.lookahead();\n\n      if (ahead.type === types.name && ahead.value === \"enum\") {\n        const node = this.startNode();\n        this.expect(types._const);\n        this.expectContextual(\"enum\");\n        return this.tsParseEnumDeclaration(node, true);\n      }\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  parseClassMember(classBody, member, state) {\n    this.tsParseModifiers(member, [\"declare\"]);\n    const accessibility = this.parseAccessModifier();\n    if (accessibility) member.accessibility = accessibility;\n    this.tsParseModifiers(member, [\"declare\"]);\n\n    const callParseClassMember = () => {\n      super.parseClassMember(classBody, member, state);\n    };\n\n    if (member.declare) {\n      this.tsInDeclareContext(callParseClassMember);\n    } else {\n      callParseClassMember();\n    }\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    this.tsParseModifiers(member, [\"abstract\", \"readonly\", \"declare\"]);\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (member.abstract) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAbstract);\n      }\n\n      if (isStatic) {\n        this.raise(member.start, TSErrors.IndexSignatureHasStatic);\n      }\n\n      if (member.accessibility) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);\n      }\n\n      if (member.declare) {\n        this.raise(member.start, TSErrors.IndexSignatureHasDeclare);\n      }\n\n      return;\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(types.question);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);\n    }\n\n    if (methodOrProp.declare && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n    if (!refNeedsArrowPos || !this.match(types.question)) {\n      return super.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n    if (!result.node) {\n      refNeedsArrowPos.start = result.error.pos || this.state.start;\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(\"declare\");\n    let declaration;\n\n    if (this.match(types.name)) {\n      declaration = this.tsTryParseExportDeclaration();\n    }\n\n    if (!declaration) {\n      declaration = super.parseExportDeclaration(node);\n    }\n\n    if (declaration && (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare)) {\n      node.exportKind = \"type\";\n    }\n\n    if (declaration && isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(types.bang)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (this.state.isDeclareContext && this.match(types.eq)) {\n      this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(node.start, TSErrors.PrivateElementHasAbstract);\n    }\n\n    if (node.accessibility) {\n      this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n\n    if (typeParameters && isConstructor) {\n      this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);\n    }\n\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.tsParseTypeArguments();\n    }\n\n    if (this.eatContextual(\"implements\")) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, ...args) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    super.parseObjPropValue(prop, ...args);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && this.eat(types.bang)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(...args) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;\n\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.match(types.jsxTagStart)) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (!((_jsx = jsx) == null ? void 0 : _jsx.error) && !this.isRelational(\"<\")) {\n      return super.parseMaybeAssign(...args);\n    }\n\n    let typeParameters;\n    state = state || this.state.clone();\n    const arrow = this.tryParse(abort => {\n      var _typeParameters;\n\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(...args);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || expr.extra && expr.extra.parenthesized) {\n        abort();\n      }\n\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) return arrow.node;\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      return arrow.node;\n    }\n\n    if ((_typeCast = typeCast) == null ? void 0 : _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.thrown) throw typeCast.error;\n    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n        if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\" && !this.state.isDeclareContext && !this.state.inType) {\n        this.raise(param.start, TSErrors.PatternIsOptional);\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n\n      case \"TSParameterProperty\":\n        return super.toAssignable(node, isLHS);\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        node.expression = this.toAssignable(node.expression, isLHS);\n        return node;\n\n      default:\n        return super.toAssignable(node, isLHS);\n    }\n  }\n\n  checkLVal(expr, contextDescription, ...args) {\n    switch (expr.type) {\n      case \"TSTypeCastExpression\":\n        return;\n\n      case \"TSParameterProperty\":\n        this.checkLVal(expr.parameter, \"parameter property\", ...args);\n        return;\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        this.checkLVal(expr.expression, contextDescription, ...args);\n        return;\n\n      default:\n        super.checkLVal(expr, contextDescription, ...args);\n        return;\n    }\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types._this:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsParseTypeArguments();\n\n      if (this.match(types.parenL)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(this.state.start, types.parenL);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(...args) {\n    const node = super.parseMaybeDefault(...args);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  reScan_lt_gt() {\n    if (this.match(types.relational)) {\n      const code = this.input.charCodeAt(this.state.start);\n\n      if (code === 60 || code === 62) {\n        this.state.pos -= 1;\n        this.readToken_lt_gt(code);\n      }\n    }\n  }\n\n  toAssignableList(exprList) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if (!expr) continue;\n\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          exprList[i] = this.typeCastToParameter(expr);\n          break;\n\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (!this.state.maybeInArrowParameters) {\n            exprList[i] = this.typeCastToParameter(expr);\n          } else {\n            this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);\n          }\n\n          break;\n      }\n    }\n\n    return super.toAssignableList(...arguments);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && firstParam.type === \"Identifier\" && firstParam.name === \"this\";\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n\n    return param;\n  }\n\n  tsInDeclareContext(cb) {\n    const oldIsDeclareContext = this.state.isDeclareContext;\n    this.state.isDeclareContext = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.isDeclareContext = oldIsDeclareContext;\n    }\n  }\n\n});\n\ntypes.placeholder = new TokenType(\"%%\", {\n  startsExpr: true\n});\nvar placeholders = (superClass => class extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(types.placeholder)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      this.expect(types.placeholder);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(types.placeholder, 2);\n    }\n\n    return super.getTokenFromCode(...arguments);\n  }\n\n  parseExprAtom() {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n  }\n\n  parseIdentifier() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n  }\n\n  checkReservedWord(word) {\n    if (word !== undefined) super.checkReservedWord(...arguments);\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n  }\n\n  checkLVal(expr) {\n    if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n  }\n\n  toAssignable(node) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n      return node;\n    }\n\n    return super.toAssignable(...arguments);\n  }\n\n  verifyBreakContinue(node) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(...arguments);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(...arguments);\n    }\n\n    if (this.match(types.colon)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = this.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock() {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n  }\n\n  parseFunctionId() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    this.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(...arguments);\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types._default)) {\n      const next = this.nextTokenStart();\n\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(types.placeholder.label, this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(...arguments);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers == null ? void 0 : specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(...arguments);\n    node.specifiers = [];\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    this.finishNode(specifier, \"ImportDefaultSpecifier\");\n    node.specifiers.push(specifier);\n\n    if (this.eat(types.comma)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(\"from\");\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n  }\n\n});\n\nvar v8intrinsic = (superClass => class extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(types.modulo)) {\n      const v8IntrinsicStart = this.state.start;\n      const node = this.startNode();\n      this.eat(types.modulo);\n\n      if (this.match(types.name)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(types.parenL)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStart);\n    }\n  }\n\n  parseExprAtom() {\n    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n  }\n\n});\n\nfunction hasPlugin(plugins, name) {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"smart\", \"fsharp\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, \"pipelineOperator\", \"proposal\"))) {\n    throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \" + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(\", \"));\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    if (hasPlugin(plugins, \"importAssertions\")) {\n      throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");\n    }\n\n    const moduleAttributesVerionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n\n    if (moduleAttributesVerionPluginOption !== \"may-2020\") {\n      throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"recordAndTuple\") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {\n    const key = _Object$keys[_i];\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nclass State {\n  constructor() {\n    this.strict = void 0;\n    this.curLine = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.maybeInArrowParameters = false;\n    this.inPipeline = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.inPropertyName = false;\n    this.hasFlowComment = false;\n    this.isIterator = false;\n    this.isDeclareContext = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.comments = [];\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n    this.commentPreviousNode = null;\n    this.pos = 0;\n    this.lineStart = 0;\n    this.type = types.eof;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.lastTokEnd = 0;\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n    this.containsEsc = false;\n    this.strictErrors = new Map();\n    this.exportedIdentifiers = [];\n    this.tokensLength = 0;\n  }\n\n  init(options) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n    this.curLine = options.startLine;\n    this.startLoc = this.endLoc = this.curPosition();\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst VALID_REGEX_FLAGS = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]);\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n  hex: [46, 88, 95, 120]\n};\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [48, 49];\nallowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];\nallowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];\nallowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends ParserError {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    if (!this.isLookahead) {\n      this.checkKeywordEscapes();\n\n      if (this.options.tokens) {\n        this.pushToken(new Token(this.state));\n      }\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = old.clone(true);\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    const skip = skipWhiteSpace.exec(this.input);\n    return pos + skip[0].length;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n\n    if (strict) {\n      this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    const curContext = this.curContext();\n    if (!(curContext == null ? void 0 : curContext.preserveSpace)) this.skipSpace();\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(types.eof);\n      return;\n    }\n\n    const override = curContext == null ? void 0 : curContext.override;\n\n    if (override) {\n      override(this);\n    } else {\n      this.getTokenFromCode(this.input.codePointAt(this.state.pos));\n    }\n  }\n\n  pushComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    this.state.comments.push(comment);\n    this.addComment(comment);\n  }\n\n  skipBlockComment() {\n    const startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", this.state.pos + 2);\n    if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    let match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipSpace() {\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) this.updateContext(prevType);\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.input.charCodeAt(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);\n    }\n\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);\n      }\n\n      if (next === 123) {\n        this.finishToken(types.braceHashL);\n      } else {\n        this.finishToken(types.bracketHashL);\n      }\n\n      this.state.pos += 2;\n    } else {\n      this.finishOp(types.hash, 1);\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.dot);\n    }\n  }\n\n  readToken_slash() {\n    if (this.state.exprAllowed && !this.state.inType) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.slash, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(types.interpreterDirective, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? types.star : types.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    const exprAllowed = this.state.exprAllowed;\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61 && !exprAllowed) {\n      width++;\n      type = types.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(types.pipeline, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.bracketBarR, 2);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n\n      this.finishOp(types.incDec, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.plusMin, 1);\n    }\n  }\n\n  readToken_lt_gt(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    let size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(types.assign, size + 1);\n        return;\n      }\n\n      this.finishOp(types.bitShift, size);\n      return;\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    this.finishOp(types.relational, size);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(types.arrow);\n      return;\n    }\n\n    this.finishOp(code === 61 ? types.eq : types.bang, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(types.nullishCoalescing, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(types.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.question);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(types.parenL);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(types.parenR);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(types.semi);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(types.comma);\n        return;\n\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.bracketBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.bracketL);\n        }\n\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(types.bracketR);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.braceBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.braceL);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(types.braceR);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.colon);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        ++this.state.pos;\n        this.finishToken(types.backQuote);\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(types.tilde, 1);\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(types.at);\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord();\n          return;\n        }\n\n    }\n\n    throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const start = this.state.pos;\n    let escaped, inClass;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(start, ErrorMessages.UnterminatedRegExp);\n      }\n\n      const ch = this.input.charAt(this.state.pos);\n\n      if (lineBreak.test(ch)) {\n        throw this.raise(start, ErrorMessages.UnterminatedRegExp);\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      }\n\n      ++this.state.pos;\n    }\n\n    const content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    let mods = \"\";\n\n    while (this.state.pos < this.length) {\n      const char = this.input[this.state.pos];\n      const charCode = this.input.codePointAt(this.state.pos);\n\n      if (VALID_REGEX_FLAGS.has(char)) {\n        if (mods.indexOf(char) > -1) {\n          this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);\n        }\n      } else if (isIdentifierChar(charCode) || charCode === 92) {\n        this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);\n      } else {\n        break;\n      }\n\n      ++this.state.pos;\n      mods += char;\n    }\n\n    this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen, allowNumSeparator = true) {\n    const start = this.state.pos;\n    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (code === 95) {\n        const prev = this.input.charCodeAt(this.state.pos - 1);\n        const next = this.input.charCodeAt(this.state.pos + 1);\n\n        if (allowedSiblings.indexOf(next) === -1) {\n          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);\n        } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);\n        }\n\n        if (!allowNumSeparator) {\n          this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);\n        }\n\n        ++this.state.pos;\n        continue;\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) {\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);\n    }\n\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(start, ErrorMessages.InvalidDecimal);\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    this.finishToken(types.num, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, ErrorMessages.InvalidNumber);\n    }\n\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);\n\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n\n        if (underscorePos > 0) {\n          this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);\n        }\n      }\n\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) {\n        this.raise(start, ErrorMessages.InvalidOrMissingExponent);\n      }\n\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(start, ErrorMessages.InvalidBigIntLiteral);\n      }\n\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.pos);\n\n      if (hasExponent || hasLeadingZero) {\n        this.raise(start, ErrorMessages.InvalidDecimal);\n      }\n\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(types.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(types.num, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === 123) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, true, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, ErrorMessages.InvalidCodePoint);\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n\n    return code;\n  }\n\n  readString(quote) {\n    let out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (ch === 8232 || ch === 8233) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(types.string, out);\n  }\n\n  readTmplToken() {\n    let out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(types.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(types.backQuote);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(types.template, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  recordStrictModeErrors(pos, message) {\n    if (this.state.strict && !this.state.strictErrors.has(pos)) {\n      this.raise(pos, message);\n    } else {\n      this.state.strictErrors.set(pos, message);\n    }\n  }\n\n  readEscapedChar(inTemplate) {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          const code = this.readHexChar(2, false, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          const code = this.readCodePoint(throwOnInvalid);\n          return code === null ? null : String.fromCodePoint(code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\u000b\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n\n      case 8232:\n      case 8233:\n        return \"\";\n\n      case 56:\n      case 57:\n        if (inTemplate) {\n          return null;\n        } else {\n          this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);\n        }\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          const codePos = this.state.pos - 1;\n          const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);\n          let octalStr = match[0];\n          let octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n\n          if (octalStr !== \"0\" || next === 56 || next === 57) {\n            if (inTemplate) {\n              return null;\n            } else {\n              this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  readHexChar(len, forceLen, throwOnInvalid) {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, ErrorMessages.InvalidEscapeSequence);\n      } else {\n        this.state.pos = codePos - 1;\n      }\n    }\n\n    return n;\n  }\n\n  readWord1() {\n    let word = \"\";\n    this.state.containsEsc = false;\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    while (this.state.pos < this.length) {\n      const ch = this.input.codePointAt(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (this.state.isIterator && ch === 64) {\n        ++this.state.pos;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  isIterator(word) {\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\n  }\n\n  readWord() {\n    const word = this.readWord1();\n    const type = keywords.get(word) || types.name;\n\n    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {\n      this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);\n    }\n\n    this.finishToken(type, word);\n  }\n\n  checkKeywordEscapes() {\n    const kw = this.state.type.keyword;\n\n    if (kw && this.state.containsEsc) {\n      this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);\n    }\n  }\n\n  braceIsBlock(prevType) {\n    const parent = this.curContext();\n\n    if (parent === types$1.functionExpression || parent === types$1.functionStatement) {\n      return true;\n    }\n\n    if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {\n      return !parent.isExpr;\n    }\n\n    if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {\n      return this.hasPrecedingLineBreak();\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return parent === types$1.braceStatement;\n    }\n\n    if (prevType === types._var || prevType === types._const || prevType === types.name) {\n      return false;\n    }\n\n    if (prevType === types.relational) {\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  }\n\n  updateContext(prevType) {\n    const type = this.state.type;\n    let update;\n\n    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  }\n\n}\n\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, val) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    extra[key] = val;\n  }\n\n  isRelational(op) {\n    return this.match(types.relational) && this.state.value === op;\n  }\n\n  expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, types.relational);\n    }\n  }\n\n  isContextual(name) {\n    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(name) {\n    return this.isContextual(name) && this.eat(types.name);\n  }\n\n  expectContextual(name, message) {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  }\n\n  canInsertSemicolon() {\n    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  }\n\n  isLineTerminator() {\n    return this.eat(types.semi) || this.canInsertSemicolon();\n  }\n\n  semicolon() {\n    if (!this.isLineTerminator()) this.unexpected(null, types.semi);\n  }\n\n  expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  assertNoSpace(message = \"Unexpected space.\") {\n    if (this.state.start > this.state.lastTokEnd) {\n      this.raise(this.state.lastTokEnd, message);\n    }\n  }\n\n  unexpected(pos, messageOrType = \"Unexpected token\") {\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = `Unexpected token, expected \"${messageOrType.label}\"`;\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  }\n\n  expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: [name]\n      }, `This experimental syntax requires enabling the parser plugin: '${name}'`);\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names, pos) {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: names\n      }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\", \")}'`);\n    }\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssign,\n      doubleProto\n    } = refExpressionErrors;\n    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;\n\n    if (shorthandAssign >= 0) {\n      this.unexpected(shorthandAssign);\n    }\n\n    if (doubleProto >= 0) {\n      this.raise(doubleProto, ErrorMessages.DuplicateProto);\n    }\n  }\n\n  isLiteralPropertyName() {\n    return this.match(types.name) || !!this.state.type.keyword || this.match(types.string) || this.match(types.num) || this.match(types.bigint) || this.match(types.decimal);\n  }\n\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssign = -1;\n    this.doubleProto = -1;\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.loc = void 0;\n    this.range = void 0;\n    this.leadingComments = void 0;\n    this.trailingComments = void 0;\n    this.innerComments = void 0;\n    this.extra = void 0;\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser == null ? void 0 : parser.options.ranges) this.range = [pos, 0];\n    if (parser == null ? void 0 : parser.filename) this.loc.filename = parser.filename;\n  }\n\n  __clone() {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  }\n\n}\n\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, pos, loc) {\n\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n\n    let parenthesized = undefined;\n\n    if (node.type === \"ParenthesizedExpression\" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {\n      parenthesized = unwrapParenthesizedExpression(node);\n\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n        }\n      } else {\n        this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (isLast && prop.type === \"RestElement\" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {\n            this.raiseRestNotLast(node.extra.trailingComma);\n          }\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value, isLHS);\n        break;\n\n      case \"SpreadElement\":\n        {\n          this.checkToRestConversion(node);\n          node.type = \"RestElement\";\n          const arg = node.argument;\n          this.toAssignable(arg, isLHS);\n          break;\n        }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      const error = prop.kind === \"get\" || prop.kind === \"set\" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos, isLHS) {\n    let end = exprList.length;\n\n    if (end) {\n      const last = exprList[end - 1];\n\n      if ((last == null ? void 0 : last.type) === \"RestElement\") {\n        --end;\n      } else if ((last == null ? void 0 : last.type) === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        let arg = last.argument;\n        this.toAssignable(arg, isLHS);\n        arg = unwrapParenthesizedExpression(arg);\n\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\" && arg.type !== \"ObjectPattern\") {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n\n      if (elt) {\n        this.toAssignable(elt, isLHS);\n\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n\n    return exprList;\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (let _i = 0; _i < exprList.length; _i++) {\n      const expr = exprList[_i];\n\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors, refNeedsArrowPos) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types.bracketL:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case types.braceL:\n        return this.parseObjectLike(types.braceR, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n      }\n\n      if (allowEmpty && this.match(types.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(types.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n\n        if (this.match(types.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);\n        }\n\n        while (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    var _startLoc, _startPos, _left;\n\n    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;\n    startPos = (_startPos = startPos) != null ? _startPos : this.state.start;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(types.eq)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {\n    switch (expr.type) {\n      case \"Identifier\":\n        {\n          const {\n            name\n          } = expr;\n\n          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {\n            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);\n          }\n\n          if (checkClashes) {\n            if (checkClashes.has(name)) {\n              this.raise(expr.start, ErrorMessages.ParamDupe);\n            } else {\n              checkClashes.add(name);\n            }\n          }\n\n          if (disallowLetBinding && name === \"let\") {\n            this.raise(expr.start, ErrorMessages.LetInLexicalBinding);\n          }\n\n          if (!(bindingType & BIND_NONE)) {\n            this.scope.declareName(name, bindingType, expr.start);\n          }\n\n          break;\n        }\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {\n          let prop = _expr$properties[_i2];\n          if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;\n          this.checkLVal(prop, \"object destructuring pattern\", bindingType, checkClashes, disallowLetBinding);\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {\n          const elem = _expr$elements[_i3];\n\n          if (elem) {\n            this.checkLVal(elem, \"array destructuring pattern\", bindingType, checkClashes, disallowLetBinding);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, \"assignment pattern\", bindingType, checkClashes);\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, \"rest element\", bindingType, checkClashes);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, \"parenthesized expression\", bindingType, checkClashes);\n        break;\n\n      default:\n        {\n          this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);\n        }\n    }\n  }\n\n  checkToRestConversion(node) {\n    if (node.argument.type !== \"Identifier\" && node.argument.type !== \"MemberExpression\") {\n      this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.match(types.comma)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos) {\n    throw this.raise(pos, ErrorMessages.ElementAfterRest);\n  }\n\n  raiseTrailingCommaAfterRest(pos) {\n    this.raise(pos, ErrorMessages.RestTrailingComma);\n  }\n\n}\n\nconst kExpression = 0,\n      kMaybeArrowParameterDeclaration = 1,\n      kMaybeAsyncArrowParameterDeclaration = 2,\n      kParameterDeclaration = 3;\n\nclass ExpressionScope {\n  constructor(type = kExpression) {\n    this.type = void 0;\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration() {\n    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n\n}\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.errors = new Map();\n  }\n\n  recordDeclarationError(pos, message) {\n    this.errors.set(pos, message);\n  }\n\n  clearDeclarationError(pos) {\n    this.errors.delete(pos);\n  }\n\n  iterateErrors(iterator) {\n    this.errors.forEach(iterator);\n  }\n\n}\n\nclass ExpressionScopeHandler {\n  constructor(raise) {\n    this.stack = [new ExpressionScope()];\n    this.raise = raise;\n  }\n\n  enter(scope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  recordParameterInitializerError(pos, message) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(pos, message);\n      } else {\n        return;\n      }\n\n      scope = stack[--i];\n    }\n\n    this.raise(pos, message);\n  }\n\n  recordParenthesizedIdentifierError(pos, message) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.raise(pos, message);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(pos, message);\n    } else {\n      return;\n    }\n  }\n\n  recordAsyncArrowParametersError(pos, message) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(pos, message);\n      }\n\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors((message, pos) => {\n      this.raise(pos, message);\n      let i = stack.length - 2;\n      let scope = stack[i];\n\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(pos);\n        scope = stack[--i];\n      }\n    });\n  }\n\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\n\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(key.start, ErrorMessages.RecordNoProto);\n        return;\n      }\n\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProto === -1) {\n            refExpressionErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raise(key.start, ErrorMessages.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n\n  getExpression() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(types.eof)) {\n      this.unexpected();\n    }\n\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    return expr;\n  }\n\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  parseExpressionBase(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n\n    if (this.match(types.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));\n  }\n\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(\"yield\")) {\n      if (this.prodParam.hasYield) {\n        this.state.exprAllowed = true;\n        let left = this.parseYield();\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    if (this.match(types.parenL) || this.match(types.name)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors, refNeedsArrowPos);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.state.type.isAssign) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(types.eq)) {\n        node.left = this.toAssignable(left, true);\n        refExpressionErrors.doubleProto = -1;\n      } else {\n        node.left = left;\n      }\n\n      if (refExpressionErrors.shorthandAssign >= node.left.start) {\n        refExpressionErrors.shorthandAssign = -1;\n      }\n\n      this.checkLVal(left, \"assignment expression\");\n      this.next();\n      node.right = this.parseMaybeAssign();\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(refExpressionErrors, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);\n  }\n\n  parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n    if (this.eat(types.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprOps(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnary(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    let prec = this.state.type.binop;\n\n    if (prec != null && (this.prodParam.hasIn || !this.match(types._in))) {\n      if (prec > minPrec) {\n        const op = this.state.type;\n\n        if (op === types.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n\n          this.state.inPipeline = true;\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n\n        if (op === types.exponent && left.type === \"UnaryExpression\" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {\n          this.raise(left.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);\n        }\n\n        const logical = op === types.logicalOR || op === types.logicalAND;\n        const coalesce = op === types.nullishCoalescing;\n\n        if (coalesce) {\n          prec = types.logicalAND.binop;\n        }\n\n        this.next();\n\n        if (op === types.pipeline && this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\") {\n          if (this.match(types.name) && this.state.value === \"await\" && this.prodParam.hasAwait) {\n            throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n\n        if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {\n          throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case types.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"smart\":\n            return this.withTopicPermittingContext(() => {\n              return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (this.isContextual(\"await\") && this.isAwaitAllowed()) {\n      return this.parseAwait();\n    }\n\n    const update = this.match(types.incDec);\n    const node = this.startNode();\n\n    if (this.state.type.prefix) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(types._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      const isDelete = this.match(types._delete);\n      this.next();\n      node.argument = this.parseMaybeUnary();\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, ErrorMessages.StrictDelete);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(node.start, ErrorMessages.DeletePrivateField);\n        }\n      }\n\n      if (!update) {\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    return this.parseUpdate(node, update, refExpressionErrors);\n  }\n\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      this.checkLVal(node.argument, \"prefix operation\");\n      return this.finishNode(node, \"UpdateExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (this.match(types.backQuote)) {\n      return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (this.match(types.questionDot)) {\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(types.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);\n    } else if (optional || this.match(types.bracketL) || this.eat(types.dot)) {\n      return this.parseMember(base, startPos, startLoc, state, optional);\n    } else {\n      state.stop = true;\n      return base;\n    }\n  }\n\n  parseMember(base, startPos, startLoc, state, optional) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const computed = this.eat(types.bracketL);\n    node.object = base;\n    node.computed = computed;\n    const property = computed ? this.parseExpression() : this.parseMaybePrivateName(true);\n\n    if (this.isPrivateName(property)) {\n      if (node.object.type === \"Super\") {\n        this.raise(startPos, ErrorMessages.SuperPrivateField);\n      }\n\n      this.classScope.usePrivateName(this.getPrivateNameSV(property), property.start);\n    }\n\n    node.property = property;\n\n    if (computed) {\n      this.expect(types.bracketR);\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  parseBind(base, startPos, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n  }\n\n  parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    let node = this.startNodeAt(startPos, startLoc);\n    node.callee = base;\n\n    if (state.maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === \"Import\", base.type !== \"Super\", node);\n    }\n\n    this.finishCallExpression(node, state.optionalChainMember);\n\n    if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);\n    } else {\n      if (state.maybeAsyncArrow) {\n        this.expressionScope.exit();\n      }\n\n      this.toReferencedArguments(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  parseTaggedTemplateExpression(base, startPos, startLoc, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n\n    if (state.optionalChainMember) {\n      this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        if (!this.hasPlugin(\"moduleAttributes\")) {\n          this.expectPlugin(\"importAssertions\");\n        }\n      }\n\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? \"one or two arguments\" : \"one argument\");\n      } else {\n        for (let _i = 0, _node$arguments = node.arguments; _i < _node$arguments.length; _i++) {\n          const arg = _node$arguments[_i];\n\n          if (arg.type === \"SpreadElement\") {\n            this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);\n          }\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);\n          }\n\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, allowPlaceholder));\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.state.type === types.slash) this.readRegexp();\n    const canBeArrow = this.state.potentialArrowAt === this.state.start;\n    let node;\n\n    switch (this.state.type) {\n      case types._super:\n        return this.parseSuper();\n\n      case types._import:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.dot)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(types.parenL)) {\n          this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types.name:\n        {\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            if (this.match(types._function)) {\n              const last = this.state.context.length - 1;\n\n              if (this.state.context[last] !== types$1.functionStatement) {\n                throw new Error(\"Internal error\");\n              }\n\n              this.state.context[last] = types$1.functionExpression;\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), undefined, true);\n            } else if (this.match(types.name)) {\n              return this.parseAsyncArrowUnaryFunction(id);\n            }\n          }\n\n          if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n\n          return id;\n        }\n\n      case types._do:\n        {\n          return this.parseDo();\n        }\n\n      case types.regexp:\n        {\n          const value = this.state.value;\n          node = this.parseLiteral(value.value, \"RegExpLiteral\");\n          node.pattern = value.pattern;\n          node.flags = value.flags;\n          return node;\n        }\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case types.decimal:\n        return this.parseLiteral(this.state.value, \"DecimalLiteral\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case types._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case types._true:\n      case types._false:\n        return this.parseBooleanLiteral();\n\n      case types.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case types.bracketBarL:\n      case types.bracketHashL:\n        {\n          return this.parseArrayLike(this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR, false, true, refExpressionErrors);\n        }\n\n      case types.bracketL:\n        {\n          return this.parseArrayLike(types.bracketR, true, false, refExpressionErrors);\n        }\n\n      case types.braceBarL:\n      case types.braceHashL:\n        {\n          return this.parseObjectLike(this.state.type === types.braceBarL ? types.braceBarR : types.braceR, false, true, refExpressionErrors);\n        }\n\n      case types.braceL:\n        {\n          return this.parseObjectLike(types.braceR, false, false, refExpressionErrors);\n        }\n\n      case types._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case types.at:\n        this.parseDecorators();\n\n      case types._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case types._new:\n        return this.parseNewOrNewTarget();\n\n      case types.backQuote:\n        return this.parseTemplate(false);\n\n      case types.doubleColon:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, ErrorMessages.UnsupportedBind);\n          }\n        }\n\n      case types.hash:\n        {\n          if (this.state.inPipeline) {\n            node = this.startNode();\n\n            if (this.getPluginOption(\"pipelineOperator\", \"proposal\") !== \"smart\") {\n              this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);\n            }\n\n            this.next();\n\n            if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {\n              this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);\n            }\n\n            this.registerTopicReference();\n            return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n          }\n\n          const nextCh = this.input.codePointAt(this.state.end);\n\n          if (isIdentifierStart(nextCh) || nextCh === 92) {\n            const start = this.state.start;\n            node = this.parseMaybePrivateName(true);\n\n            if (this.match(types._in)) {\n              this.expectPlugin(\"privateIn\");\n              this.classScope.usePrivateName(node.id.name, node.start);\n            } else if (this.hasPlugin(\"privateIn\")) {\n              this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, node.id.name);\n            } else {\n              throw this.unexpected(start);\n            }\n\n            return node;\n          }\n        }\n\n      case types.relational:\n        {\n          if (this.state.value === \"<\") {\n            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n\n            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n                this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n              }\n          }\n        }\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseAsyncArrowUnaryFunction(id) {\n    const node = this.startNodeAtNode(id);\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);\n    }\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, params, true);\n    return node;\n  }\n\n  parseDo() {\n    this.expectPlugin(\"doExpressions\");\n    const node = this.startNode();\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    node.body = this.parseBlock();\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(node.start, ErrorMessages.SuperNotAllowed);\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(node.start, ErrorMessages.UnexpectedSuper);\n    }\n\n    if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n      this.raise(node.start, ErrorMessages.UnsupportedSuper);\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parseBooleanLiteral() {\n    const node = this.startNode();\n    node.value = this.match(types._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseMaybePrivateName(isPrivateNameAllowed) {\n    const isPrivate = this.match(types.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n\n      if (!isPrivateNameAllowed) {\n        this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);\n      }\n\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space between # and identifier\");\n      node.id = this.parseIdentifier(true);\n      return this.finishNode(node, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  }\n\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.prodParam.hasYield && this.match(types.dot)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n    }\n\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n\n    if (this.isContextual(\"meta\")) {\n      if (!this.inModule) {\n        this.raiseWithData(id.start, {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        }, ErrorMessages.ImportMetaOutsideModule);\n      }\n\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    const node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    const refNeedsArrowPos = {\n      start: 0\n    };\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(types.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma, refNeedsArrowPos.start || null);\n\n        if (this.match(types.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(types.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n        this.checkCommaAfterRest(41);\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos));\n      }\n    }\n\n    const innerEndPos = this.state.lastTokEnd;\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(types.parenR);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow() {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(types.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(types.dot)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        let error = ErrorMessages.UnexpectedNewTarget;\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        this.raise(metaProp.start, error);\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node);\n  }\n\n  parseNew(node) {\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);\n    } else if (this.eat(types.questionDot)) {\n      this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node) {\n    if (this.eat(types.parenL)) {\n      const args = this.parseExprList(types.parenR);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(types.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          break;\n        }\n      }\n\n      const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);\n\n      if (!isPattern) {\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(prop.start, ErrorMessages.InvalidRecordProperty);\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    this.state.exprAllowed = false;\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n\n    return this.finishNode(node, type);\n  }\n\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(types.bracketL) || this.match(types.star));\n  }\n\n  parsePropertyDefinition(isPattern, refExpressionErrors) {\n    let decorators = [];\n\n    if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);\n      }\n\n      while (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isGenerator = false;\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(types.ellipsis)) {\n      if (decorators.length) this.unexpected();\n\n      if (isPattern) {\n        this.next();\n        prop.argument = this.parseIdentifier();\n        this.checkCommaAfterRest(125);\n        return this.finishNode(prop, \"RestElement\");\n      }\n\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (isPattern || refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, false);\n\n    if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        isGenerator = this.eat(types.star);\n        this.parsePropertyName(prop, false);\n      }\n\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        prop.kind = keyName;\n\n        if (this.match(types.star)) {\n          isGenerator = true;\n          this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);\n          this.next();\n        }\n\n        this.parsePropertyName(prop, false);\n      }\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    return prop;\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n\n  checkGetterSetterParams(method) {\n    var _params;\n\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const start = method.start;\n\n    if (params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, ErrorMessages.BadGetterArity);\n      } else {\n        this.raise(start, ErrorMessages.BadSetterArity);\n      }\n    }\n\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(start, ErrorMessages.BadSetterRestParameter);\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n\n    if (isAsync || isGenerator || this.match(types.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else if (this.match(types.eq) && refExpressionErrors) {\n        if (refExpressionErrors.shorthandAssign === -1) {\n          refExpressionErrors.shorthandAssign = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else {\n        prop.value = prop.key.__clone();\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, isPrivateNameAllowed) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(types.bracketR);\n    } else {\n      const oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) || this.match(types.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);\n\n      if (!this.isPrivateName(prop.key)) {\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return node;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaPos) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n\n    if (!this.match(types.bracketL) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    }\n\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaPos) {\n    node.params = this.toAssignableList(params, trailingCommaPos, false);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(types.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n\n        if (hasStrictModeDirective && nonSimple) {\n          const errorPos = (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.end : node.start;\n          this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);\n        }\n\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkLVal(node.id, \"function name\", BIND_OUTSIDE, undefined, undefined, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.expressionScope.exit();\n      this.state.labels = oldLabels;\n    }\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = new Set();\n\n    for (let _i2 = 0, _node$params = node.params; _i2 < _node$params.length; _i2++) {\n      const param = _node$params[_i2];\n      this.checkLVal(param, \"function parameter list\", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {\n    let elt;\n\n    if (this.match(types.comma)) {\n      if (!allowEmpty) {\n        this.raise(this.state.pos, ErrorMessages.UnexpectedToken, \",\");\n      }\n\n      elt = null;\n    } else if (this.match(types.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(types.question)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n    const {\n      start,\n      type\n    } = this.state;\n\n    if (type === types.name) {\n      name = this.state.value;\n    } else if (type.keyword) {\n      name = type.keyword;\n      const curContext = this.curContext();\n\n      if ((type === types._class || type === types._function) && (curContext === types$1.functionStatement || curContext === types$1.functionExpression)) {\n        this.state.context.pop();\n      }\n    } else {\n      throw this.unexpected();\n    }\n\n    if (liberal) {\n      this.state.type = types.name;\n    } else {\n      this.checkReservedWord(name, start, !!type.keyword, false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (this.prodParam.hasYield && word === \"yield\") {\n      this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);\n      return;\n    }\n\n    if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);\n        return;\n      } else {\n        this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);\n      }\n    }\n\n    if (this.scope.inClass && !this.scope.inNonArrowFunction && word === \"arguments\") {\n      this.raise(startLoc, ErrorMessages.ArgumentsInClass);\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      if (!this.prodParam.hasAwait && word === \"await\") {\n        this.raise(startLoc, this.hasPlugin(\"topLevelAwait\") ? ErrorMessages.AwaitNotInAsyncContext : ErrorMessages.AwaitNotInAsyncFunction);\n      } else {\n        this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);\n      }\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n\n    return false;\n  }\n\n  parseAwait() {\n    const node = this.startNode();\n    this.next();\n    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);\n\n    if (this.eat(types.star)) {\n      this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin(\"v8intrinsic\") && this.match(types.modulo)) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary();\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);\n    this.next();\n\n    if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartPos) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);\n      }\n    }\n  }\n\n  parseSmartPipelineBody(childExpression, startPos, startLoc) {\n    this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);\n    return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);\n  }\n\n  checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {\n    if (this.match(types.arrow)) {\n      throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);\n    } else if (childExpression.type === \"SequenceExpression\") {\n      this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n    const isSimpleReference = this.isSimpleReference(childExpression);\n\n    if (isSimpleReference) {\n      bodyNode.callee = childExpression;\n    } else {\n      if (!this.topicReferenceWasUsedInCurrentTopicContext()) {\n        this.raise(startPos, ErrorMessages.PipelineTopicUnused);\n      }\n\n      bodyNode.expression = childExpression;\n    }\n\n    return this.finishNode(bodyNode, isSimpleReference ? \"PipelineBareFunction\" : \"PipelineTopicExpression\");\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  withTopicPermittingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withTopicForbiddingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  primaryTopicReferenceIsAllowedInCurrentTopicContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentTopicContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    program.sourceType = this.options.sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, types.eof);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {\n        const [name] = _Array$from[_i];\n        const pos = this.scope.undefinedExports.get(name);\n        this.raise(pos, ErrorMessages.ModuleExportUndefined, name);\n      }\n    }\n\n    file.program = this.finishNode(program, \"Program\");\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = this.tokens;\n    return this.finishNode(file, \"File\");\n  }\n\n  stmtToDirective(stmt) {\n    const expr = stmt.expression;\n    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    const directive = this.startNodeAt(stmt.start, stmt.loc.start);\n    const raw = this.input.slice(expr.start, expr.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(types.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const nextCh = this.input.charCodeAt(next);\n    if (nextCh === 91) return true;\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      let pos = next + 1;\n\n      while (isIdentifierChar(this.input.charCodeAt(pos))) {\n        ++pos;\n      }\n\n      const ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(types.at)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, ErrorMessages.StrictFunction);\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, ErrorMessages.SloppyFunction);\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case types._class:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types._const:\n      case types._var:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._import:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n              break;\n            }\n        }\n\n      case types._export:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === types._import) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raiseWithData(node.start, {\n        code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n      }, ErrorMessages.ImportOutsideModule);\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(types._class);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(types.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(types._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, ErrorMessages.DecoratorExportClass);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.eat(types.parenL)) {\n        expr = this.parseExpression();\n        this.expect(types.parenR);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(types.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(types.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, keyword) {\n    const isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, keyword) {\n    const isBreak = keyword === \"break\";\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(types.parenL);\n    const val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(types.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = -1;\n\n    if (this.isAwaitAllowed() && this.eatContextual(\"await\")) {\n      awaitAt = this.state.lastTokStart;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.parenL);\n\n    if (this.match(types.semi)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const isLet = this.isLet();\n\n    if (this.match(types._var) || this.match(types._const) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if ((this.match(types._in) || this.isContextual(\"of\")) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      this.toAssignable(init, true);\n      const description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n      this.checkLVal(init, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, ErrorMessages.IllegalReturn);\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(types.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(types.braceR);) {\n      if (this.match(types._case) || this.match(types._default)) {\n        const isCase = this.match(types._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(types.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, \"catch clause\", BIND_LEXICAL);\n    return param;\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(types._catch)) {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(types.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, ErrorMessages.NoCatchOrFinally);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, ErrorMessages.StrictWith);\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {\n      const label = _this$state$labels[_i2];\n\n      if (label.name === maybeName) {\n        this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);\n      }\n    }\n\n    const kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n\n    this.expect(types.braceL);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.match(types.semi) ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.match(types.parenR) ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(types._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? \"for-in\" : \"for-of\");\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, ErrorMessages.InvalidLhs, \"for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind) {\n    const declarations = node.declarations = [];\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n\n      if (this.eat(types.eq)) {\n        decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      } else {\n        if (kind === \"const\" && !(this.match(types._in) || this.isContextual(\"of\"))) {\n          if (!isTypescript) {\n            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, \"Const declarations\");\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n          this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, \"Complex binding patterns\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, \"variable declaration\", kind === \"var\" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== \"var\");\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(types.star) && isHangingStatement) {\n      this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);\n    }\n\n    node.generator = this.eat(types.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, false);\n    this.withTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || this.match(types.name) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    this.expect(types.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n  }\n\n  isClassMethod() {\n    return this.match(types.parenL);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(constructorAllowsSuper, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      constructorAllowsSuper,\n      hadConstructor: false,\n      hadStaticBlock: false\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(types.braceL);\n    this.withTopicForbiddingContext(() => {\n      while (!this.match(types.braceR)) {\n        if (this.eat(types.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);\n          }\n\n          continue;\n        }\n\n        if (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(member.start, ErrorMessages.DecoratorConstructor);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);\n    }\n\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n\n    return false;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(\"static\");\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      if (this.eat(types.braceL)) {\n        this.parseClassStaticBlock(classBody, member, state);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(types.star)) {\n      method.kind = \"method\";\n      this.parseClassElementName(method);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseClassElementName(member);\n    const isPrivate = this.isPrivateName(key);\n    const isSimple = key.type === \"Identifier\";\n    const maybeQuestionTokenStart = this.state.start;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, ErrorMessages.DuplicateConstructor);\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = state.constructorAllowsSuper;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isSimple && key.name === \"async\" && !containsEsc && !this.isLineTerminator()) {\n      const isGenerator = this.eat(types.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isSimple && (key.name === \"get\" || key.name === \"set\") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {\n      method.kind = key.name;\n      this.parseClassElementName(publicMethod);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassElementName(member) {\n    const key = this.parsePropertyName(member, true);\n\n    if (!member.computed && member.static && (key.name === \"prototype\" || key.value === \"prototype\")) {\n      this.raise(key.start, ErrorMessages.StaticPrototype);\n    }\n\n    if (this.isPrivateName(key) && this.getPrivateNameSV(key) === \"constructor\") {\n      this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);\n    }\n\n    return key;\n  }\n\n  parseClassStaticBlock(classBody, member, state) {\n    var _member$decorators;\n\n    this.expectPlugin(\"classStaticBlock\", member.start);\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(PARAM);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, types.braceR);\n    this.prodParam.exit();\n    this.expressionScope.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n\n    if (state.hadStaticBlock) {\n      this.raise(member.start, ErrorMessages.DuplicateStaticBlock);\n    }\n\n    if ((_member$decorators = member.decorators) == null ? void 0 : _member$decorators.length) {\n      this.raise(member.start, ErrorMessages.DecoratorStaticBlock);\n    }\n\n    state.hadStaticBlock = true;\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(prop.key.start, ErrorMessages.ConstructorClassField);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    if (!node.typeAnnotation || this.match(types.eq)) {\n      this.expectPlugin(\"classProperties\");\n    }\n\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseInitializer(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(types.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (this.match(types.name)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.checkLVal(node.id, \"class name\", bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, ErrorMessages.MissingClassName);\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(types.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, types.braceL);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(types._default)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, types.braceL);\n  }\n\n  eatExportStar(node) {\n    return this.eat(types.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(\"as\")) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(types.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      node.specifiers.push(...this.parseExportSpecifiers());\n      node.source = null;\n      node.declaration = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(\"async\")) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(types._function) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    } else if (this.match(types._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {\n      throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);\n    } else {\n      const res = this.parseMaybeAssignAllowIn();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name)) {\n      const value = this.state.value;\n\n      if (value === \"async\" && !this.state.containsEsc || value === \"let\") {\n        return false;\n      }\n\n      if ((value === \"type\" || value === \"interface\") && !this.state.containsEsc) {\n        const l = this.lookahead();\n\n        if (l.type === types.name && l.value !== \"from\" || l.type === types.braceL) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(types._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n\n    if (this.input.charCodeAt(next) === 44 || this.match(types.name) && hasFrom) {\n      return true;\n    }\n\n    if (this.match(types._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n\n    return false;\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n\n      if (assertions) {\n        node.assertions = assertions;\n      }\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.match(types.at)) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n\n          const declaration = node.declaration;\n\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) == null ? void 0 : _declaration$extra.parenthesized)) {\n            this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        for (let _i3 = 0, _node$specifiers = node.specifiers; _i3 < _node$specifiers.length; _i3++) {\n          const specifier = _node$specifiers[_i3];\n          const {\n            exported\n          } = specifier;\n          const exportedName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportedName);\n\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n\n            if (local.type === \"StringLiteral\") {\n              this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);\n            } else {\n              this.checkReservedWord(local.name, local.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (let _i4 = 0, _node$declaration$dec = node.declaration.declarations; _i4 < _node$declaration$dec.length; _i4++) {\n            const declaration = _node$declaration$dec[_i4];\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (let _i5 = 0, _node$properties = node.properties; _i5 < _node$properties.length; _i5++) {\n        const prop = _node$properties[_i5];\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (let _i6 = 0, _node$elements = node.elements; _i6 < _node$elements.length; _i6++) {\n        const elem = _node$elements[_i6];\n\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, name) {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raise(node.start, name === \"default\" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);\n    }\n\n    this.state.exportedIdentifiers.push(name);\n  }\n\n  parseExportSpecifiers() {\n    const nodes = [];\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }\n\n  parseModuleExportName() {\n    if (this.match(types.string)) {\n      this.expectPlugin(\"moduleStringNames\");\n      const result = this.parseLiteral(this.state.value, \"StringLiteral\");\n      const surrogate = result.value.match(loneSurrogate);\n\n      if (surrogate) {\n        this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));\n      }\n\n      return result;\n    }\n\n    return this.parseIdentifier(true);\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(types.string)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(types.comma);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(\"from\");\n    }\n\n    node.source = this.parseImportSource();\n    const assertions = this.maybeParseImportAssertions();\n\n    if (assertions) {\n      node.assertions = assertions;\n    } else {\n        const attributes = this.maybeParseModuleAttributes();\n\n        if (attributes) {\n          node.attributes = attributes;\n        }\n      }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(types.string)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return this.match(types.name);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  parseAssertEntries() {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(types.braceR)) {\n        break;\n      }\n\n      const node = this.startNode();\n      const keyName = this.state.value;\n\n      if (this.match(types.string)) {\n        node.key = this.parseLiteral(keyName, \"StringLiteral\");\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n\n      this.expect(types.colon);\n\n      if (keyName !== \"type\") {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, keyName);\n      }\n\n      if (attrNames.has(keyName)) {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);\n      }\n\n      attrNames.add(keyName);\n\n      if (!this.match(types.string)) {\n        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);\n      }\n\n      node.value = this.parseLiteral(this.state.value, \"StringLiteral\");\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(types.comma));\n\n    return attrs;\n  }\n\n  maybeParseModuleAttributes() {\n    if (this.match(types._with) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n\n    const attrs = [];\n    const attributes = new Set();\n\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);\n      }\n\n      attributes.add(node.key.name);\n      this.expect(types.colon);\n\n      if (!this.match(types.string)) {\n        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);\n      }\n\n      node.value = this.parseLiteral(this.state.value, \"StringLiteral\");\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(types.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    if (this.isContextual(\"assert\") && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n\n    this.eat(types.braceL);\n    const attrs = this.parseAssertEntries();\n    this.eat(types.braceR);\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(types.star)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(types.colon)) {\n          throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);\n        }\n\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    specifier.imported = this.parseModuleExportName();\n\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n\n      if (imported.type === \"StringLiteral\") {\n        throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);\n      }\n\n      this.checkReservedWord(imported.name, specifier.start, true, true);\n      specifier.local = imported.__clone();\n    }\n\n    this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n\n}\nclass ClassScopeHandler {\n  constructor(raise) {\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n  }\n\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n\n    for (let _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {\n      const [name, pos] = _Array$from[_i];\n\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, pos);\n        }\n      } else {\n        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);\n      }\n    }\n  }\n\n  declarePrivateName(name, elementType, pos) {\n    const classScope = this.current();\n    let redefined = classScope.privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && classScope.loneAccessors.get(name);\n\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) classScope.loneAccessors.delete(name);\n      } else if (!redefined) {\n        classScope.loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);\n    }\n\n    classScope.privateNames.add(name);\n    classScope.undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name, pos) {\n    let classScope;\n\n    for (let _i2 = 0, _this$stack = this.stack; _i2 < _this$stack.length; _i2++) {\n      classScope = _this$stack[_i2];\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, pos);\n    } else {\n      this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);\n    }\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    const ScopeHandler = this.getScopeHandler();\n    this.options = options;\n    this.inModule = this.options.sourceType === \"module\";\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n    this.prodParam = new ProductionParameterHandler();\n    this.classScope = new ClassScopeHandler(this.raise.bind(this));\n    this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (let _i = 0; _i < plugins.length; _i++) {\n    const plugin = plugins[_i];\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  var _options;\n\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options == null ? void 0 : options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (let _i = 0; _i < pluginList.length; _i++) {\n      const plugin = pluginList[_i];\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n//# sourceMappingURL=index.js.map\n\n\n/***/ })\n\n}]);"}